This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.dist/desktop.ini
css/desktop.ini
css/style.css
desktop.ini
index.html
js/app.js
js/change_orders.js
js/construction.js
js/dashboard.js
js/db.js
js/desktop.ini
js/dexie.min.js
js/dupa_library.js
js/dupa.js
js/library_management.js
js/materials.js
js/projects.js
js/reports.js
js/sequencing.js
js/takeoff.js
js/views.js
sample projects/bat-os Materials.json
sample projects/default multistory.json
sample projects/default project.json
sample projects/desktop.ini
sample projects/library.json
sample projects/materials_lib.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="sample projects/bat-os Materials.json">
{
  "materials": [
    {
      "name": "2x2x8 Coco Lumber",
      "unit": "Lengths",
      "unitPrice": 130
    },
    {
      "name": "C.W. Nails 4\"",
      "unit": "kilos",
      "unitPrice": 90
    },
    {
      "name": "Nylon",
      "unit": "Rolls",
      "unitPrice": 70
    },
    {
      "name": "Portland Cement",
      "unit": "Bags",
      "unitPrice": 190
    },
    {
      "name": "Mixing Sand",
      "unit": "Cu.M",
      "unitPrice": 1000
    },
    {
      "name": "3/4\" Crushed Gravel",
      "unit": "Cu.M",
      "unitPrice": 1650
    },
    {
      "name": "16 mm dia. Deformed Bars x 6m length",
      "unit": "Kilos",
      "unitPrice": 43
    },
    {
      "name": "#16 GI Tie wire",
      "unit": "Kilos",
      "unitPrice": 60
    },
    {
      "name": "12 mm dia. Deformed Bars x 6m length",
      "unit": "Kilos",
      "unitPrice": 43
    },
    {
      "name": "10mm dia. Deformed Bars x 6m length",
      "unit": "Kilos",
      "unitPrice": 43
    },
    {
      "name": "4\" Concrete Hollow Blocks",
      "unit": "Pcs",
      "unitPrice": 16
    },
    {
      "name": "Masonry Cement",
      "unit": "Bags",
      "unitPrice": 190
    },
    {
      "name": "GA16 2x6 C-Purlins",
      "unit": "Lengths",
      "unitPrice": 703
    },
    {
      "name": "Ga16 2x4 C-Purlins",
      "unit": "Lengths",
      "unitPrice": 559
    },
    {
      "name": "8mm DRB (Webbing)",
      "unit": "Lengths",
      "unitPrice": 95
    },
    {
      "name": "Welding Rod E 6013 (1/8)",
      "unit": "Kilos",
      "unitPrice": 135
    },
    {
      "name": "Red Lead Primer/Metal Primer",
      "unit": "Gals",
      "unitPrice": 465
    },
    {
      "name": "Paint thinner",
      "unit": "Qrts",
      "unitPrice": 99
    },
    {
      "name": "Rib Type Long Span Roofing",
      "unit": "Ln.M",
      "unitPrice": 350
    },
    {
      "name": "Wall Cap",
      "unit": "Ln.M",
      "unitPrice": 400
    },
    {
      "name": "Fascia",
      "unit": "Ln.M",
      "unitPrice": 400
    },
    {
      "name": "False Gutter",
      "unit": "Ln.M",
      "unitPrice": 400
    },
    {
      "name": "Tek screw",
      "unit": "Pcs",
      "unitPrice": 1.5
    },
    {
      "name": "Blind rivets",
      "unit": "Box",
      "unitPrice": 500
    },
    {
      "name": "Touch up Paint",
      "unit": "Qrt",
      "unitPrice": 250
    },
    {
      "name": "Sealant",
      "unit": "Qrt",
      "unitPrice": 220
    },
    {
      "name": "Cladding",
      "unit": "Sq.M",
      "unitPrice": 350
    },
    {
      "name": "Cladding Edge",
      "unit": "Lengths",
      "unitPrice": 100
    },
    {
      "name": "Tubular 2x2\"",
      "unit": "Lengths",
      "unitPrice": 550
    },
    {
      "name": "3.5mm Hardiflex Lite",
      "unit": "Sheets",
      "unitPrice": 585
    },
    {
      "name": "Metal Furring (25mm X 50 X 20 X 5m)",
      "unit": "Lengths",
      "unitPrice": 115
    },
    {
      "name": "Metal screw(Hardie drive Screw)n0.12 x 1/2\"",
      "unit": "Pcs",
      "unitPrice": 1.1
    },
    {
      "name": "1/8 x 1/2 Blind rivets",
      "unit": "Box",
      "unitPrice": 250
    },
    {
      "name": "Roll-Up Door",
      "unit": "Pcs",
      "unitPrice": 15000
    },
    {
      "name": "Panel Door",
      "unit": "Pcs",
      "unitPrice": 9000
    },
    {
      "name": "Door Jamb",
      "unit": "Pcs",
      "unitPrice": 2500
    },
    {
      "name": "Hinges & Door Accessories",
      "unit": "Lots",
      "unitPrice": 1100
    },
    {
      "name": "Door Painting",
      "unit": "Lots",
      "unitPrice": 1000
    },
    {
      "name": "PVC Door",
      "unit": "Pcs",
      "unitPrice": 2000
    },
    {
      "name": "Door Knob",
      "unit": "Pcs",
      "unitPrice": 350
    },
    {
      "name": "Window Set",
      "unit": "Lot",
      "unitPrice": 11000
    },
    {
      "name": "Outdoor Concrete Counter",
      "unit": "Pcs",
      "unitPrice": 1000
    },
    {
      "name": "20x20 cm Ceramic tiles (White)",
      "unit": "Pcs",
      "unitPrice": 45
    },
    {
      "name": "Clinic Counter (Granite top)",
      "unit": "Pcs",
      "unitPrice": 15000
    },
    {
      "name": "Concrete Counter",
      "unit": "Lot",
      "unitPrice": 1500
    },
    {
      "name": "Tile Grout (White)",
      "unit": "Bags",
      "unitPrice": 45
    },
    {
      "name": "Tile Trim (White)",
      "unit": "Lengths",
      "unitPrice": 115
    },
    {
      "name": "30x30 cm Ceramic Floor Tiles",
      "unit": "Pcs",
      "unitPrice": 75
    },
    {
      "name": "30x30 cm Ceramic wall tiles",
      "unit": "Pcs",
      "unitPrice": 75
    },
    {
      "name": "Tile Grout (Beige)",
      "unit": "Bags",
      "unitPrice": 45
    },
    {
      "name": "Skim Coat",
      "unit": "Bags",
      "unitPrice": 475
    },
    {
      "name": "Flat White Primer",
      "unit": "Gals",
      "unitPrice": 577.5
    },
    {
      "name": "Latex Color",
      "unit": "Gals",
      "unitPrice": 750
    },
    {
      "name": "Painting Consumables",
      "unit": "Lot",
      "unitPrice": 5244.19
    },
    {
      "name": "Submeter",
      "unit": "Pcs",
      "unitPrice": 1500
    },
    {
      "name": "Panel Board",
      "unit": "Pcs",
      "unitPrice": 3000
    },
    {
      "name": "60A 2p Breaker",
      "unit": "Pcs",
      "unitPrice": 750
    },
    {
      "name": "30A 2p Breaker",
      "unit": "Pcs",
      "unitPrice": 500
    },
    {
      "name": "15A 2p Breaker",
      "unit": "Pcs",
      "unitPrice": 400
    },
    {
      "name": "Lighting Fixtures",
      "unit": "Pcs",
      "unitPrice": 800
    },
    {
      "name": "Convenience Outlets",
      "unit": "Pcs",
      "unitPrice": 600
    },
    {
      "name": "#12 Wires",
      "unit": "Box",
      "unitPrice": 4385
    },
    {
      "name": "#14 Wires",
      "unit": "Box",
      "unitPrice": 2650
    },
    {
      "name": "#10 Wires",
      "unit": "Box",
      "unitPrice": 6442
    },
    {
      "name": "1/2\" PVC w/ junction boxes",
      "unit": "Lengths",
      "unitPrice": 155
    },
    {
      "name": "Main Valve",
      "unit": "Pcs",
      "unitPrice": 225
    },
    {
      "name": "Outdoor Sink W/ Accessories",
      "unit": "Pcs",
      "unitPrice": 2500
    },
    {
      "name": "Lavatory",
      "unit": "Pcs",
      "unitPrice": 3500
    },
    {
      "name": "Water Closet",
      "unit": "Pcs",
      "unitPrice": 6500
    },
    {
      "name": "Floor Drain",
      "unit": "Pcs",
      "unitPrice": 850
    },
    {
      "name": "Catch Basin",
      "unit": "Pcs",
      "unitPrice": 3000
    },
    {
      "name": "Water Line 1/2\"",
      "unit": "m",
      "unitPrice": 50
    },
    {
      "name": "Drainage Line",
      "unit": "m",
      "unitPrice": 240
    },
    {
      "name": "HDPE Septic Vault",
      "unit": "Pcs",
      "unitPrice": 11000
    },
    {
      "name": "Gate Accessories",
      "unit": "Lot",
      "unitPrice": 1000
    },
    {
      "name": "Frame 2\" Round Pipe",
      "unit": "Lengths",
      "unitPrice": 460
    },
    {
      "name": "Mesh Wire",
      "unit": "Sheets",
      "unitPrice": 315
    },
    {
      "name": "Plain Sheet",
      "unit": "Sheets",
      "unitPrice": 465
    },
    {
      "name": "Gate Accessories (Type 2)",
      "unit": "Lots",
      "unitPrice": 2000
    },
    {
      "name": "1\" Round Pipe",
      "unit": "Lengths",
      "unitPrice": 460
    },
    {
      "name": "Gate Accessories (Type 3)",
      "unit": "lots",
      "unitPrice": 500
    },
    {
      "name": "Epoxy Primer Black",
      "unit": "Gals",
      "unitPrice": 875
    },
    {
      "name": "Thinner",
      "unit": "Quarts",
      "unitPrice": 99
    },
    {
      "name": "Welding Rod",
      "unit": "Kilos",
      "unitPrice": 130
    }
  ],
  "resources": [],
  "crews": [],
  "crewComposition": []
}
</file>

<file path=".dist/desktop.ini">
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\113.0.1.0\GoogleDriveFS.exe,26
</file>

<file path="css/desktop.ini">
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\113.0.1.0\GoogleDriveFS.exe,26
</file>

<file path="desktop.ini">
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\113.0.1.0\GoogleDriveFS.exe,26
</file>

<file path="js/change_orders.js">
// Author: -REPLACE WITH YOUR NAME-
// OS support: -REPLACE WITH YOUR OS SUPPORT-
// Description: Logic for the Change Orders module.

const coProjectsListDiv = document.getElementById('co-projects-list');
const coListView = document.getElementById('co-list-view');
const coProjectName = document.getElementById('co-project-name');
const backToCoProjectsBtn = document.getElementById('back-to-co-projects');
const coTableBody = document.querySelector('#co-table tbody');
const addCoBtn = document.getElementById('add-co-btn');

const coModal = document.getElementById('co-modal');
const coModalClose = document.querySelector('.co-modal-close');
const coModalTitle = document.getElementById('co-modal-title');
const coForm = document.getElementById('co-form');
const coIdInput = document.getElementById('co-id');
const coDescriptionInput = document.getElementById('co-description');
const coDateInput = document.getElementById('co-date');
const coStatusSelect = document.getElementById('co-status');
const coItemsTableBody = document.querySelector('#co-items-table tbody');
const addCoItemBtn = document.getElementById('add-co-item-btn');

const coItemDupaModal = document.getElementById('co-item-dupa-modal');
const coItemDupaModalClose = document.querySelector('.co-item-dupa-modal-close');
const coItemDupaForm = document.getElementById('co-item-dupa-form');
const coItemIdInput = document.getElementById('co-item-id');

const coSelectNewItemBtn = document.getElementById('co-select-new-item-btn');
const coSelectExistingItemBtn = document.getElementById('co-select-existing-item-btn');
const coExistingItemForm = document.getElementById('co-existing-item-form');
const coOriginalItemSelect = document.getElementById('co-original-item-select');
const coItemQuantityChangeInput = document.getElementById('co-item-quantity-change');

const coLaborTbody = document.getElementById('co-labor-tbody');
const coMaterialTbody = document.getElementById('co-material-tbody');
const coEquipmentTbody = document.getElementById('co-equipment-tbody');

let currentCoProjectId = null;
let currentCoId = null;

const openCoModal = () => coModal.style.display = 'block';
const closeCoModal = () => coModal.style.display = 'none';
const openCoItemDupaModal = () => coItemDupaModal.style.display = 'block';
const closeCoItemDupaModal = () => coItemDupaModal.style.display = 'none';

const addCoLaborRow = (data = {}) => {
    const row = coLaborTbody.insertRow();
    row.innerHTML = `<td><input type="text" class="co-labor-type" value="${data.laborType || ''}" required></td><td><input type="number" class="co-labor-mandays" value="${data.mandays || ''}" step="any" min="0" required></td><td><input type="number" class="co-labor-rate" value="${data.rate || ''}" step="any" min="0" required></td><td><button type="button" class="btn-remove">X</button></td>`;
};

const addCoMaterialRow = (data = {}) => {
    const row = coMaterialTbody.insertRow();
    row.innerHTML = `<td><input type="text" class="co-material-name" value="${data.name || ''}" required></td><td><input type="number" class="co-material-qty" value="${data.quantity || ''}" step="any" min="0" required></td><td><input type="text" class="co-material-unit" value="${data.unit || ''}" required></td><td><input type="number" class="co-material-price" value="${data.unitPrice || ''}" step="any" min="0" required></td><td><button type="button" class="btn-remove">X</button></td>`;
};

const addCoEquipmentRow = (data = {}) => {
    const row = coEquipmentTbody.insertRow();
    row.innerHTML = `<td><input type="text" class="co-equipment-name" value="${data.name || ''}" required></td><td><input type="number" class="co-equipment-hours" value="${data.hours || ''}" step="any" min="0" required></td><td><input type="number" class="co-equipment-rate" value="${data.rate || ''}" step="any" min="0" required></td><td><button type="button" class="btn-remove">X</button></td>`;
};

const calculateChangeOrderDupaTotal = (dupa) => {
    if (!dupa || !dupa.directCosts) return 0;

    // Case 1: DUPA from "Modify Existing Item"
    if (dupa.directCosts[0]?.type === 'calculated') {
        return dupa.directCosts[0].total;
    }

    // Case 2: DUPA from old simplified "New Item" (for backward compatibility)
    if (dupa.directCosts[0]?.type === 'total') {
        const directCost = dupa.directCosts[0].total;
        const ocm = directCost * (dupa.indirectCosts.ocm / 100);
        const profit = directCost * (dupa.indirectCosts.profit / 100);
        const subtotal = directCost + ocm + profit;
        const taxes = subtotal * (dupa.indirectCosts.taxes / 100);
        return subtotal + taxes;
    }
    
    // Case 3: Detailed DUPA from "New Item" (the new detailed way)
    const directCostsTotal = dupa.directCosts.reduce((total, item) => {
        switch (item.type) {
            case 'labor': return total + (item.mandays * item.rate);
            case 'material': return total + (item.quantity * item.unitPrice);
            case 'equipment': return total + (item.hours * item.rate);
            default: return total;
        }
    }, 0);

    const ocmCost = directCostsTotal * (dupa.indirectCosts.ocm / 100);
    const profitCost = directCostsTotal * (dupa.indirectCosts.profit / 100);
    const totalBeforeTax = directCostsTotal + ocmCost + profitCost;
    const taxCost = totalBeforeTax * (dupa.indirectCosts.taxes / 100);
    return totalBeforeTax + taxCost;
};

const displayCoProjects = async () => {
    const allProjects = await db.projects.orderBy('projectName').toArray();
    coProjectsListDiv.innerHTML = '';
    allProjects.forEach(p => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary view-co-btn" data-id="${p.id}" data-name="${p.projectName}">Select</button>`;
        coProjectsListDiv.appendChild(item);
    });
};

const renderCoItems = async (changeOrderId) => {
    coItemsTableBody.innerHTML = '';
    const items = await db.changeOrderItems.where({ changeOrderId }).toArray();
    for (const item of items) {
        const dupa = await db.changeOrderDupas.get({ changeOrderItemId: item.id });
        const amount = calculateChangeOrderDupaTotal(dupa);
        const row = coItemsTableBody.insertRow();
        row.innerHTML = `
            <td>${item.scopeOfWork}</td>
            <td>${item.quantity}</td>
            <td>${item.unit}</td>
            <td>${amount.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td>
            <td class="actions-cell">
                <button type="button" class="btn btn-warning edit-co-item-btn" data-id="${item.id}" data-type="${item.originalQuantityId ? 'existing' : 'new'}">Edit</button>
                <button type="button" class="btn btn-danger delete-co-item-btn" data-id="${item.id}">Del</button>
            </td>
        `;
    }
};

const showChangeOrdersForProject = async (projectId, projectName) => {
    currentCoProjectId = projectId;
    coProjectName.textContent = `Change Orders: ${projectName}`;
    document.getElementById('co-project-list-view').classList.add('hidden');
    coListView.classList.remove('hidden');

    coTableBody.innerHTML = '';
    const changeOrders = await db.changeOrders.where({ projectId }).toArray();
    for (const order of changeOrders) {
        const items = await db.changeOrderItems.where({ changeOrderId: order.id }).toArray();
        let totalAmount = 0;
        for (const item of items) {
            const dupa = await db.changeOrderDupas.get({ changeOrderItemId: item.id });
            totalAmount += calculateChangeOrderDupaTotal(dupa);
        }
        const row = coTableBody.insertRow();
        row.innerHTML = `
            <td>${String(order.id).padStart(4, '0')}</td>
            <td>${order.description}</td>
            <td>${order.date}</td>
            <td>${order.status}</td>
            <td>${totalAmount.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td>
            <td class="actions-cell">
                <button class="btn btn-warning edit-co-btn" data-id="${order.id}">Edit</button>
            </td>
        `;
    }
};

function initializeChangeOrdersModule() {
    changeOrdersView.addEventListener('click', (e) => {
        if (e.target.classList.contains('view-co-btn')) {
            showChangeOrdersForProject(parseInt(e.target.dataset.id), e.target.dataset.name);
        }
    });

    backToCoProjectsBtn.addEventListener('click', () => {
        coListView.classList.add('hidden');
        document.getElementById('co-project-list-view').classList.remove('hidden');
    });

    addCoBtn.addEventListener('click', () => {
        currentCoId = null;
        coForm.reset();
        coIdInput.value = '';
        coDateInput.valueAsDate = new Date();
        coItemsTableBody.innerHTML = '';
        coModalTitle.textContent = 'New Change Order';
        openCoModal();
    });
    
    coModalClose.addEventListener('click', closeCoModal);
    coItemDupaModalClose.addEventListener('click', closeCoItemDupaModal);
    coItemTypeModalClose.addEventListener('click', closeCoItemTypeModal);
    coExistingItemModalClose.addEventListener('click', closeCoExistingItemModal);

    document.getElementById('co-add-labor-btn').addEventListener('click', () => addCoLaborRow());
    document.getElementById('co-add-material-btn').addEventListener('click', () => addCoMaterialRow());
    document.getElementById('co-add-equipment-btn').addEventListener('click', () => addCoEquipmentRow());

    coItemDupaModal.addEventListener('click', (e) => {
        if (e.target.classList.contains('btn-remove')) {
            e.target.closest('tr').remove();
        }
    });

    coForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const data = { projectId: currentCoProjectId, description: coDescriptionInput.value, date: coDateInput.value, status: coStatusSelect.value };
        if (currentCoId) {
            await db.changeOrders.update(currentCoId, data);
        } else {
            currentCoId = await db.changeOrders.add(data);
            coIdInput.value = currentCoId;
        }
        closeCoModal();
        await showChangeOrdersForProject(currentCoProjectId, coProjectName.textContent.replace('Change Orders: ', ''));
    });

    addCoItemBtn.addEventListener('click', () => {
        if (!currentCoId) {
            alert('Please save the Change Order details before adding items.');
            return;
        }
        openCoItemTypeModal();
    });
    
    coSelectNewItemBtn.addEventListener('click', () => {
        closeCoItemTypeModal();
        coItemDupaForm.reset();
        coItemIdInput.value = '';
        document.getElementById('co-original-quantity-id').value = '';
        coLaborTbody.innerHTML = '';
        coMaterialTbody.innerHTML = '';
        coEquipmentTbody.innerHTML = '';
        openCoItemDupaModal();
    });

    coSelectExistingItemBtn.addEventListener('click', async () => {
        closeCoItemTypeModal();
        coExistingItemForm.reset();
        const originalQuantities = await db.quantities.where({ projectId: currentCoProjectId }).toArray();
        coOriginalItemSelect.innerHTML = '<option value="">-- Select Original Task --</option>';
        originalQuantities.forEach(q => {
            coOriginalItemSelect.innerHTML += `<option value="${q.id}">${q.scopeOfWork}</option>`;
        });
        openCoExistingItemModal();
    });

    coExistingItemForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const originalQuantityId = parseInt(coOriginalItemSelect.value);
        const quantityChange = parseFloat(coItemQuantityChangeInput.value);
        if (!originalQuantityId || isNaN(quantityChange)) {
            alert('Please select an item and enter a valid quantity change.');
            return;
        }

        try {
            const originalQuantity = await db.quantities.get(originalQuantityId);
            const originalDupa = await db.dupas.where({ quantityId: originalQuantityId }).first();

            if (!originalQuantity || !originalDupa) {
                throw new Error("Original item or its DUPA could not be found.");
            }
            if (originalQuantity.quantity === 0) {
                throw new Error("Cannot base calculation on an item with zero quantity.");
            }
            
            const proportion = quantityChange / originalQuantity.quantity;

            closeCoExistingItemModal();
            coItemDupaForm.reset();
            coItemIdInput.value = '';
            coLaborTbody.innerHTML = '';
            coMaterialTbody.innerHTML = '';
            coEquipmentTbody.innerHTML = '';

            document.getElementById('co-original-quantity-id').value = originalQuantityId;
            document.getElementById('co-item-scope').value = `(VO) ${originalQuantity.scopeOfWork}`;
            document.getElementById('co-item-quantity').value = quantityChange;
            document.getElementById('co-item-unit').value = originalQuantity.unit;

            document.getElementById('co-item-dupa-duration').value = Math.round(originalDupa.duration * proportion);

            (originalDupa.directCosts || []).forEach(item => {
                const newItem = { ...item };
                if (newItem.type === 'labor') {
                    newItem.mandays *= proportion;
                    addCoLaborRow(newItem);
                }
                if (newItem.type === 'material') {
                    newItem.quantity *= proportion;
                    addCoMaterialRow(newItem);
                }
                if (newItem.type === 'equipment') {
                    newItem.hours *= proportion;
                    addCoEquipmentRow(newItem);
                }
            });

            document.getElementById('co-item-dupa-ocm').value = originalDupa.indirectCosts.ocm;
            document.getElementById('co-item-dupa-profit').value = originalDupa.indirectCosts.profit;
            document.getElementById('co-item-dupa-taxes').value = originalDupa.indirectCosts.taxes;

            openCoItemDupaModal();

        } catch (error) {
            console.error("Error preparing existing item modification:", error);
            alert(`An error occurred: ${error.message}`);
        }
    });

    coItemsTableBody.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.classList.contains('edit-co-item-btn')) {
            alert('Editing existing change order items is not yet implemented.');
        }
        if (target.classList.contains('delete-co-item-btn')) {
            const itemId = parseInt(target.dataset.id);
            if (confirm('Are you sure you want to delete this item?')) {
                await db.transaction('rw', db.changeOrderItems, db.changeOrderDupas, async () => {
                    await db.changeOrderDupas.where({ changeOrderItemId: itemId }).delete();
                    await db.changeOrderItems.delete(itemId);
                });
                await renderCoItems(currentCoId);
            }
        }
    });
    
    coTableBody.addEventListener('click', async (e) => {
        if(e.target.classList.contains('edit-co-btn')) {
            const orderId = parseInt(e.target.dataset.id);
            const order = await db.changeOrders.get(orderId);
            currentCoId = orderId;
            coIdInput.value = order.id;
            coDescriptionInput.value = order.description;
            coDateInput.value = order.date;
            coStatusSelect.value = order.status;
            coModalTitle.textContent = `Edit Change Order #${String(order.id).padStart(4, '0')}`;
            await renderCoItems(orderId);
            openCoModal();
        }
    });

    coItemDupaForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const itemId = coItemIdInput.value ? parseInt(coItemIdInput.value) : null;
        const originalQuantityIdValue = document.getElementById('co-original-quantity-id').value;
        
        const itemData = {
            changeOrderId: currentCoId,
            scopeOfWork: document.getElementById('co-item-scope').value,
            quantity: parseFloat(document.getElementById('co-item-quantity').value),
            unit: document.getElementById('co-item-unit').value
        };
        
        if (originalQuantityIdValue) {
            itemData.originalQuantityId = parseInt(originalQuantityIdValue);
        }
    
        const directCosts = [];
        coLaborTbody.querySelectorAll('tr').forEach(row => directCosts.push({ type: 'labor', laborType: row.querySelector('.co-labor-type').value, mandays: parseFloat(row.querySelector('.co-labor-mandays').value), rate: parseFloat(row.querySelector('.co-labor-rate').value) }));
        coMaterialTbody.querySelectorAll('tr').forEach(row => directCosts.push({ type: 'material', name: row.querySelector('.co-material-name').value, quantity: parseFloat(row.querySelector('.co-material-qty').value), unit: row.querySelector('.co-material-unit').value, unitPrice: parseFloat(row.querySelector('.co-material-price').value) }));
        coEquipmentTbody.querySelectorAll('tr').forEach(row => directCosts.push({ type: 'equipment', name: row.querySelector('.co-equipment-name').value, hours: parseFloat(row.querySelector('.co-equipment-hours').value), rate: parseFloat(row.querySelector('.co-equipment-rate').value) }));
    
        const dupaData = {
            duration: parseInt(document.getElementById('co-item-dupa-duration').value),
            directCosts: directCosts,
            indirectCosts: {
                ocm: parseFloat(document.getElementById('co-item-dupa-ocm').value),
                profit: parseFloat(document.getElementById('co-item-dupa-profit').value),
                taxes: parseFloat(document.getElementById('co-item-dupa-taxes').value)
            }
        };
    
        await db.transaction('rw', db.changeOrderItems, db.changeOrderDupas, async () => {
            if (itemId) {
                await db.changeOrderItems.update(itemId, itemData);
                const dupaToUpdate = await db.changeOrderDupas.get({ changeOrderItemId: itemId });
                await db.changeOrderDupas.update(dupaToUpdate.id, dupaData);
            } else {
                const newItemId = await db.changeOrderItems.add(itemData);
                dupaData.changeOrderItemId = newItemId;
                await db.changeOrderDupas.add(dupaData);
            }
        });
    
        document.getElementById('co-original-quantity-id').value = ''; 
        closeCoItemDupaModal();
        await renderCoItems(currentCoId);
    });
}
</file>

<file path="js/desktop.ini">
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\113.0.1.0\GoogleDriveFS.exe,26
</file>

<file path="js/dexie.min.js">
/*
 * Dexie.js - a minimalistic wrapper for IndexedDB
 * ===============================================
 *
 * By David Fahlander, david.fahlander@gmail.com
 *
 * Version 4.2.0, Wed Aug 13 2025
 *
 * https://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 */
 
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Dexie = factory());
})(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    }

    var _global = typeof globalThis !== 'undefined' ? globalThis :
        typeof self !== 'undefined' ? self :
            typeof window !== 'undefined' ? window :
                global;

    var keys = Object.keys;
    var isArray = Array.isArray;
    if (typeof Promise !== 'undefined' && !_global.Promise) {
        _global.Promise = Promise;
    }
    function extend(obj, extension) {
        if (typeof extension !== 'object')
            return obj;
        keys(extension).forEach(function (key) {
            obj[key] = extension[key];
        });
        return obj;
    }
    var getProto = Object.getPrototypeOf;
    var _hasOwn = {}.hasOwnProperty;
    function hasOwn(obj, prop) {
        return _hasOwn.call(obj, prop);
    }
    function props(proto, extension) {
        if (typeof extension === 'function')
            extension = extension(getProto(proto));
        (typeof Reflect === "undefined" ? keys : Reflect.ownKeys)(extension).forEach(function (key) {
            setProp(proto, key, extension[key]);
        });
    }
    var defineProperty = Object.defineProperty;
    function setProp(obj, prop, functionOrGetSet, options) {
        defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === 'function' ?
            { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :
            { value: functionOrGetSet, configurable: true, writable: true }, options));
    }
    function derive(Child) {
        return {
            from: function (Parent) {
                Child.prototype = Object.create(Parent.prototype);
                setProp(Child.prototype, "constructor", Child);
                return {
                    extend: props.bind(null, Child.prototype)
                };
            }
        };
    }
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    function getPropertyDescriptor(obj, prop) {
        var pd = getOwnPropertyDescriptor(obj, prop);
        var proto;
        return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
    }
    var _slice = [].slice;
    function slice(args, start, end) {
        return _slice.call(args, start, end);
    }
    function override(origFunc, overridedFactory) {
        return overridedFactory(origFunc);
    }
    function assert(b) {
        if (!b)
            throw new Error("Assertion Failed");
    }
    function asap$1(fn) {
        if (_global.setImmediate)
            setImmediate(fn);
        else
            setTimeout(fn, 0);
    }
    function arrayToObject(array, extractor) {
        return array.reduce(function (result, item, i) {
            var nameAndValue = extractor(item, i);
            if (nameAndValue)
                result[nameAndValue[0]] = nameAndValue[1];
            return result;
        }, {});
    }
    function getByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string' && hasOwn(obj, keyPath))
            return obj[keyPath];
        if (!keyPath)
            return obj;
        if (typeof keyPath !== 'string') {
            var rv = [];
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                var val = getByKeyPath(obj, keyPath[i]);
                rv.push(val);
            }
            return rv;
        }
        var period = keyPath.indexOf('.');
        if (period !== -1) {
            var innerObj = obj[keyPath.substr(0, period)];
            return innerObj == null ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));
        }
        return undefined;
    }
    function setByKeyPath(obj, keyPath, value) {
        if (!obj || keyPath === undefined)
            return;
        if ('isFrozen' in Object && Object.isFrozen(obj))
            return;
        if (typeof keyPath !== 'string' && 'length' in keyPath) {
            assert(typeof value !== 'string' && 'length' in value);
            for (var i = 0, l = keyPath.length; i < l; ++i) {
                setByKeyPath(obj, keyPath[i], value[i]);
            }
        }
        else {
            var period = keyPath.indexOf('.');
            if (period !== -1) {
                var currentKeyPath = keyPath.substr(0, period);
                var remainingKeyPath = keyPath.substr(period + 1);
                if (remainingKeyPath === "")
                    if (value === undefined) {
                        if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))
                            obj.splice(currentKeyPath, 1);
                        else
                            delete obj[currentKeyPath];
                    }
                    else
                        obj[currentKeyPath] = value;
                else {
                    var innerObj = obj[currentKeyPath];
                    if (!innerObj || !hasOwn(obj, currentKeyPath))
                        innerObj = (obj[currentKeyPath] = {});
                    setByKeyPath(innerObj, remainingKeyPath, value);
                }
            }
            else {
                if (value === undefined) {
                    if (isArray(obj) && !isNaN(parseInt(keyPath)))
                        obj.splice(keyPath, 1);
                    else
                        delete obj[keyPath];
                }
                else
                    obj[keyPath] = value;
            }
        }
    }
    function delByKeyPath(obj, keyPath) {
        if (typeof keyPath === 'string')
            setByKeyPath(obj, keyPath, undefined);
        else if ('length' in keyPath)
            [].map.call(keyPath, function (kp) {
                setByKeyPath(obj, kp, undefined);
            });
    }
    function shallowClone(obj) {
        var rv = {};
        for (var m in obj) {
            if (hasOwn(obj, m))
                rv[m] = obj[m];
        }
        return rv;
    }
    var concat = [].concat;
    function flatten(a) {
        return concat.apply([], a);
    }
    var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey"
        .split(',').concat(flatten([8, 16, 32, 64].map(function (num) { return ["Int", "Uint", "Float"].map(function (t) { return t + num + "Array"; }); }))).filter(function (t) { return _global[t]; });
    var intrinsicTypes = new Set(intrinsicTypeNames.map(function (t) { return _global[t]; }));
    function cloneSimpleObjectTree(o) {
        var rv = {};
        for (var k in o)
            if (hasOwn(o, k)) {
                var v = o[k];
                rv[k] = !v || typeof v !== 'object' || intrinsicTypes.has(v.constructor) ? v : cloneSimpleObjectTree(v);
            }
        return rv;
    }
    function objectIsEmpty(o) {
        for (var k in o)
            if (hasOwn(o, k))
                return false;
        return true;
    }
    var circularRefs = null;
    function deepClone(any) {
        circularRefs = new WeakMap();
        var rv = innerDeepClone(any);
        circularRefs = null;
        return rv;
    }
    function innerDeepClone(x) {
        if (!x || typeof x !== 'object')
            return x;
        var rv = circularRefs.get(x);
        if (rv)
            return rv;
        if (isArray(x)) {
            rv = [];
            circularRefs.set(x, rv);
            for (var i = 0, l = x.length; i < l; ++i) {
                rv.push(innerDeepClone(x[i]));
            }
        }
        else if (intrinsicTypes.has(x.constructor)) {
            rv = x;
        }
        else {
            var proto = getProto(x);
            rv = proto === Object.prototype ? {} : Object.create(proto);
            circularRefs.set(x, rv);
            for (var prop in x) {
                if (hasOwn(x, prop)) {
                    rv[prop] = innerDeepClone(x[prop]);
                }
            }
        }
        return rv;
    }
    var toString = {}.toString;
    function toStringTag(o) {
        return toString.call(o).slice(8, -1);
    }
    var iteratorSymbol = typeof Symbol !== 'undefined' ?
        Symbol.iterator :
        '@@iterator';
    var getIteratorOf = typeof iteratorSymbol === "symbol" ? function (x) {
        var i;
        return x != null && (i = x[iteratorSymbol]) && i.apply(x);
    } : function () { return null; };
    function delArrayItem(a, x) {
        var i = a.indexOf(x);
        if (i >= 0)
            a.splice(i, 1);
        return i >= 0;
    }
    var NO_CHAR_ARRAY = {};
    function getArrayOf(arrayLike) {
        var i, a, x, it;
        if (arguments.length === 1) {
            if (isArray(arrayLike))
                return arrayLike.slice();
            if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')
                return [arrayLike];
            if ((it = getIteratorOf(arrayLike))) {
                a = [];
                while ((x = it.next()), !x.done)
                    a.push(x.value);
                return a;
            }
            if (arrayLike == null)
                return [arrayLike];
            i = arrayLike.length;
            if (typeof i === 'number') {
                a = new Array(i);
                while (i--)
                    a[i] = arrayLike[i];
                return a;
            }
            return [arrayLike];
        }
        i = arguments.length;
        a = new Array(i);
        while (i--)
            a[i] = arguments[i];
        return a;
    }
    var isAsyncFunction = typeof Symbol !== 'undefined'
        ? function (fn) { return fn[Symbol.toStringTag] === 'AsyncFunction'; }
        : function () { return false; };

    var dexieErrorNames = [
        'Modify',
        'Bulk',
        'OpenFailed',
        'VersionChange',
        'Schema',
        'Upgrade',
        'InvalidTable',
        'MissingAPI',
        'NoSuchDatabase',
        'InvalidArgument',
        'SubTransaction',
        'Unsupported',
        'Internal',
        'DatabaseClosed',
        'PrematureCommit',
        'ForeignAwait'
    ];
    var idbDomErrorNames = [
        'Unknown',
        'Constraint',
        'Data',
        'TransactionInactive',
        'ReadOnly',
        'Version',
        'NotFound',
        'InvalidState',
        'InvalidAccess',
        'Abort',
        'Timeout',
        'QuotaExceeded',
        'Syntax',
        'DataClone'
    ];
    var errorList = dexieErrorNames.concat(idbDomErrorNames);
    var defaultTexts = {
        VersionChanged: "Database version changed by other database connection",
        DatabaseClosed: "Database has been closed",
        Abort: "Transaction aborted",
        TransactionInactive: "Transaction has already completed or failed",
        MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
    };
    function DexieError(name, msg) {
        this.name = name;
        this.message = msg;
    }
    derive(DexieError).from(Error).extend({
        toString: function () { return this.name + ": " + this.message; }
    });
    function getMultiErrorMessage(msg, failures) {
        return msg + ". Errors: " + Object.keys(failures)
            .map(function (key) { return failures[key].toString(); })
            .filter(function (v, i, s) { return s.indexOf(v) === i; })
            .join('\n');
    }
    function ModifyError(msg, failures, successCount, failedKeys) {
        this.failures = failures;
        this.failedKeys = failedKeys;
        this.successCount = successCount;
        this.message = getMultiErrorMessage(msg, failures);
    }
    derive(ModifyError).from(DexieError);
    function BulkError(msg, failures) {
        this.name = "BulkError";
        this.failures = Object.keys(failures).map(function (pos) { return failures[pos]; });
        this.failuresByPos = failures;
        this.message = getMultiErrorMessage(msg, this.failures);
    }
    derive(BulkError).from(DexieError);
    var errnames = errorList.reduce(function (obj, name) { return (obj[name] = name + "Error", obj); }, {});
    var BaseException = DexieError;
    var exceptions = errorList.reduce(function (obj, name) {
        var fullName = name + "Error";
        function DexieError(msgOrInner, inner) {
            this.name = fullName;
            if (!msgOrInner) {
                this.message = defaultTexts[name] || fullName;
                this.inner = null;
            }
            else if (typeof msgOrInner === 'string') {
                this.message = "".concat(msgOrInner).concat(!inner ? '' : '\n ' + inner);
                this.inner = inner || null;
            }
            else if (typeof msgOrInner === 'object') {
                this.message = "".concat(msgOrInner.name, " ").concat(msgOrInner.message);
                this.inner = msgOrInner;
            }
        }
        derive(DexieError).from(BaseException);
        obj[name] = DexieError;
        return obj;
    }, {});
    exceptions.Syntax = SyntaxError;
    exceptions.Type = TypeError;
    exceptions.Range = RangeError;
    var exceptionMap = idbDomErrorNames.reduce(function (obj, name) {
        obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    function mapError(domError, message) {
        if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
            return domError;
        var rv = new exceptionMap[domError.name](message || domError.message, domError);
        if ("stack" in domError) {
            setProp(rv, "stack", { get: function () {
                    return this.inner.stack;
                } });
        }
        return rv;
    }
    var fullNameExceptions = errorList.reduce(function (obj, name) {
        if (["Syntax", "Type", "Range"].indexOf(name) === -1)
            obj[name + "Error"] = exceptions[name];
        return obj;
    }, {});
    fullNameExceptions.ModifyError = ModifyError;
    fullNameExceptions.DexieError = DexieError;
    fullNameExceptions.BulkError = BulkError;

    function nop() { }
    function mirror(val) { return val; }
    function pureFunctionChain(f1, f2) {
        if (f1 == null || f1 === mirror)
            return f2;
        return function (val) {
            return f2(f1(val));
        };
    }
    function callBoth(on1, on2) {
        return function () {
            on1.apply(this, arguments);
            on2.apply(this, arguments);
        };
    }
    function hookCreatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res !== undefined)
                arguments[0] = res;
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res2 !== undefined ? res2 : res;
        };
    }
    function hookDeletingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            f1.apply(this, arguments);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = this.onerror = null;
            f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
        };
    }
    function hookUpdatingChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function (modifications) {
            var res = f1.apply(this, arguments);
            extend(modifications, res);
            var onsuccess = this.onsuccess,
            onerror = this.onerror;
            this.onsuccess = null;
            this.onerror = null;
            var res2 = f2.apply(this, arguments);
            if (onsuccess)
                this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
            if (onerror)
                this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
            return res === undefined ?
                (res2 === undefined ? undefined : res2) :
                (extend(res, res2));
        };
    }
    function reverseStoppableEventChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            if (f2.apply(this, arguments) === false)
                return false;
            return f1.apply(this, arguments);
        };
    }
    function promisableChain(f1, f2) {
        if (f1 === nop)
            return f2;
        return function () {
            var res = f1.apply(this, arguments);
            if (res && typeof res.then === 'function') {
                var thiz = this, i = arguments.length, args = new Array(i);
                while (i--)
                    args[i] = arguments[i];
                return res.then(function () {
                    return f2.apply(thiz, args);
                });
            }
            return f2.apply(this, arguments);
        };
    }

    var debug = typeof location !== 'undefined' &&
        /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
    function setDebug(value, filter) {
        debug = value;
    }

    var INTERNAL = {};
    var ZONE_ECHO_LIMIT = 100, _a$1 = typeof Promise === 'undefined' ?
        [] :
        (function () {
            var globalP = Promise.resolve();
            if (typeof crypto === 'undefined' || !crypto.subtle)
                return [globalP, getProto(globalP), globalP];
            var nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
            return [
                nativeP,
                getProto(nativeP),
                globalP
            ];
        })(), resolvedNativePromise = _a$1[0], nativePromiseProto = _a$1[1], resolvedGlobalPromise = _a$1[2], nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
    var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
    var patchGlobalPromise = !!resolvedGlobalPromise;
    function schedulePhysicalTick() {
        queueMicrotask(physicalTick);
    }
    var asap = function (callback, args) {
        microtickQueue.push([callback, args]);
        if (needsNewPhysicalTick) {
            schedulePhysicalTick();
            needsNewPhysicalTick = false;
        }
    };
    var isOutsideMicroTick = true,
    needsNewPhysicalTick = true,
    unhandledErrors = [],
    rejectingErrors = [],
    rejectionMapper = mirror;
    var globalPSD = {
        id: 'global',
        global: true,
        ref: 0,
        unhandleds: [],
        onunhandled: nop,
        pgp: false,
        env: {},
        finalize: nop
    };
    var PSD = globalPSD;
    var microtickQueue = [];
    var numScheduledCalls = 0;
    var tickFinalizers = [];
    function DexiePromise(fn) {
        if (typeof this !== 'object')
            throw new TypeError('Promises must be constructed via new');
        this._listeners = [];
        this._lib = false;
        var psd = (this._PSD = PSD);
        if (typeof fn !== 'function') {
            if (fn !== INTERNAL)
                throw new TypeError('Not a function');
            this._state = arguments[1];
            this._value = arguments[2];
            if (this._state === false)
                handleRejection(this, this._value);
            return;
        }
        this._state = null;
        this._value = null;
        ++psd.ref;
        executePromiseTask(this, fn);
    }
    var thenProp = {
        get: function () {
            var psd = PSD, microTaskId = totalEchoes;
            function then(onFulfilled, onRejected) {
                var _this = this;
                var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
                var cleanup = possibleAwait && !decrementExpectedAwaits();
                var rv = new DexiePromise(function (resolve, reject) {
                    propagateToListener(_this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));
                });
                if (this._consoleTask)
                    rv._consoleTask = this._consoleTask;
                return rv;
            }
            then.prototype = INTERNAL;
            return then;
        },
        set: function (value) {
            setProp(this, 'then', value && value.prototype === INTERNAL ?
                thenProp :
                {
                    get: function () {
                        return value;
                    },
                    set: thenProp.set
                });
        }
    };
    props(DexiePromise.prototype, {
        then: thenProp,
        _then: function (onFulfilled, onRejected) {
            propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
        },
        catch: function (onRejected) {
            if (arguments.length === 1)
                return this.then(null, onRejected);
            var type = arguments[0], handler = arguments[1];
            return typeof type === 'function' ? this.then(null, function (err) {
                return err instanceof type ? handler(err) : PromiseReject(err);
            })
                : this.then(null, function (err) {
                    return err && err.name === type ? handler(err) : PromiseReject(err);
                });
        },
        finally: function (onFinally) {
            return this.then(function (value) {
                return DexiePromise.resolve(onFinally()).then(function () { return value; });
            }, function (err) {
                return DexiePromise.resolve(onFinally()).then(function () { return PromiseReject(err); });
            });
        },
        timeout: function (ms, msg) {
            var _this = this;
            return ms < Infinity ?
                new DexiePromise(function (resolve, reject) {
                    var handle = setTimeout(function () { return reject(new exceptions.Timeout(msg)); }, ms);
                    _this.then(resolve, reject).finally(clearTimeout.bind(null, handle));
                }) : this;
        }
    });
    if (typeof Symbol !== 'undefined' && Symbol.toStringTag)
        setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');
    globalPSD.env = snapShot();
    function Listener(onFulfilled, onRejected, resolve, reject, zone) {
        this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
        this.onRejected = typeof onRejected === 'function' ? onRejected : null;
        this.resolve = resolve;
        this.reject = reject;
        this.psd = zone;
    }
    props(DexiePromise, {
        all: function () {
            var values = getArrayOf.apply(null, arguments)
                .map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                if (values.length === 0)
                    resolve([]);
                var remaining = values.length;
                values.forEach(function (a, i) { return DexiePromise.resolve(a).then(function (x) {
                    values[i] = x;
                    if (!--remaining)
                        resolve(values);
                }, reject); });
            });
        },
        resolve: function (value) {
            if (value instanceof DexiePromise)
                return value;
            if (value && typeof value.then === 'function')
                return new DexiePromise(function (resolve, reject) {
                    value.then(resolve, reject);
                });
            var rv = new DexiePromise(INTERNAL, true, value);
            return rv;
        },
        reject: PromiseReject,
        race: function () {
            var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
            return new DexiePromise(function (resolve, reject) {
                values.map(function (value) { return DexiePromise.resolve(value).then(resolve, reject); });
            });
        },
        PSD: {
            get: function () { return PSD; },
            set: function (value) { return PSD = value; }
        },
        totalEchoes: { get: function () { return totalEchoes; } },
        newPSD: newScope,
        usePSD: usePSD,
        scheduler: {
            get: function () { return asap; },
            set: function (value) { asap = value; }
        },
        rejectionMapper: {
            get: function () { return rejectionMapper; },
            set: function (value) { rejectionMapper = value; }
        },
        follow: function (fn, zoneProps) {
            return new DexiePromise(function (resolve, reject) {
                return newScope(function (resolve, reject) {
                    var psd = PSD;
                    psd.unhandleds = [];
                    psd.onunhandled = reject;
                    psd.finalize = callBoth(function () {
                        var _this = this;
                        run_at_end_of_this_or_next_physical_tick(function () {
                            _this.unhandleds.length === 0 ? resolve() : reject(_this.unhandleds[0]);
                        });
                    }, psd.finalize);
                    fn();
                }, zoneProps, resolve, reject);
            });
        }
    });
    if (NativePromise) {
        if (NativePromise.allSettled)
            setProp(DexiePromise, "allSettled", function () {
                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(function (resolve) {
                    if (possiblePromises.length === 0)
                        resolve([]);
                    var remaining = possiblePromises.length;
                    var results = new Array(remaining);
                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return results[i] = { status: "fulfilled", value: value }; }, function (reason) { return results[i] = { status: "rejected", reason: reason }; })
                        .then(function () { return --remaining || resolve(results); }); });
                });
            });
        if (NativePromise.any && typeof AggregateError !== 'undefined')
            setProp(DexiePromise, "any", function () {
                var possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
                return new DexiePromise(function (resolve, reject) {
                    if (possiblePromises.length === 0)
                        reject(new AggregateError([]));
                    var remaining = possiblePromises.length;
                    var failures = new Array(remaining);
                    possiblePromises.forEach(function (p, i) { return DexiePromise.resolve(p).then(function (value) { return resolve(value); }, function (failure) {
                        failures[i] = failure;
                        if (!--remaining)
                            reject(new AggregateError(failures));
                    }); });
                });
            });
        if (NativePromise.withResolvers)
            DexiePromise.withResolvers = NativePromise.withResolvers;
    }
    function executePromiseTask(promise, fn) {
        try {
            fn(function (value) {
                if (promise._state !== null)
                    return;
                if (value === promise)
                    throw new TypeError('A promise cannot be resolved with itself.');
                var shouldExecuteTick = promise._lib && beginMicroTickScope();
                if (value && typeof value.then === 'function') {
                    executePromiseTask(promise, function (resolve, reject) {
                        value instanceof DexiePromise ?
                            value._then(resolve, reject) :
                            value.then(resolve, reject);
                    });
                }
                else {
                    promise._state = true;
                    promise._value = value;
                    propagateAllListeners(promise);
                }
                if (shouldExecuteTick)
                    endMicroTickScope();
            }, handleRejection.bind(null, promise));
        }
        catch (ex) {
            handleRejection(promise, ex);
        }
    }
    function handleRejection(promise, reason) {
        rejectingErrors.push(reason);
        if (promise._state !== null)
            return;
        var shouldExecuteTick = promise._lib && beginMicroTickScope();
        reason = rejectionMapper(reason);
        promise._state = false;
        promise._value = reason;
        addPossiblyUnhandledError(promise);
        propagateAllListeners(promise);
        if (shouldExecuteTick)
            endMicroTickScope();
    }
    function propagateAllListeners(promise) {
        var listeners = promise._listeners;
        promise._listeners = [];
        for (var i = 0, len = listeners.length; i < len; ++i) {
            propagateToListener(promise, listeners[i]);
        }
        var psd = promise._PSD;
        --psd.ref || psd.finalize();
        if (numScheduledCalls === 0) {
            ++numScheduledCalls;
            asap(function () {
                if (--numScheduledCalls === 0)
                    finalizePhysicalTick();
            }, []);
        }
    }
    function propagateToListener(promise, listener) {
        if (promise._state === null) {
            promise._listeners.push(listener);
            return;
        }
        var cb = promise._state ? listener.onFulfilled : listener.onRejected;
        if (cb === null) {
            return (promise._state ? listener.resolve : listener.reject)(promise._value);
        }
        ++listener.psd.ref;
        ++numScheduledCalls;
        asap(callListener, [cb, promise, listener]);
    }
    function callListener(cb, promise, listener) {
        try {
            var ret, value = promise._value;
            if (!promise._state && rejectingErrors.length)
                rejectingErrors = [];
            ret = debug && promise._consoleTask ? promise._consoleTask.run(function () { return cb(value); }) : cb(value);
            if (!promise._state && rejectingErrors.indexOf(value) === -1) {
                markErrorAsHandled(promise);
            }
            listener.resolve(ret);
        }
        catch (e) {
            listener.reject(e);
        }
        finally {
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
            --listener.psd.ref || listener.psd.finalize();
        }
    }
    function physicalTick() {
        usePSD(globalPSD, function () {
            beginMicroTickScope() && endMicroTickScope();
        });
    }
    function beginMicroTickScope() {
        var wasRootExec = isOutsideMicroTick;
        isOutsideMicroTick = false;
        needsNewPhysicalTick = false;
        return wasRootExec;
    }
    function endMicroTickScope() {
        var callbacks, i, l;
        do {
            while (microtickQueue.length > 0) {
                callbacks = microtickQueue;
                microtickQueue = [];
                l = callbacks.length;
                for (i = 0; i < l; ++i) {
                    var item = callbacks[i];
                    item[0].apply(null, item[1]);
                }
            }
        } while (microtickQueue.length > 0);
        isOutsideMicroTick = true;
        needsNewPhysicalTick = true;
    }
    function finalizePhysicalTick() {
        var unhandledErrs = unhandledErrors;
        unhandledErrors = [];
        unhandledErrs.forEach(function (p) {
            p._PSD.onunhandled.call(null, p._value, p);
        });
        var finalizers = tickFinalizers.slice(0);
        var i = finalizers.length;
        while (i)
            finalizers[--i]();
    }
    function run_at_end_of_this_or_next_physical_tick(fn) {
        function finalizer() {
            fn();
            tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
        }
        tickFinalizers.push(finalizer);
        ++numScheduledCalls;
        asap(function () {
            if (--numScheduledCalls === 0)
                finalizePhysicalTick();
        }, []);
    }
    function addPossiblyUnhandledError(promise) {
        if (!unhandledErrors.some(function (p) { return p._value === promise._value; }))
            unhandledErrors.push(promise);
    }
    function markErrorAsHandled(promise) {
        var i = unhandledErrors.length;
        while (i)
            if (unhandledErrors[--i]._value === promise._value) {
                unhandledErrors.splice(i, 1);
                return;
            }
    }
    function PromiseReject(reason) {
        return new DexiePromise(INTERNAL, false, reason);
    }
    function wrap(fn, errorCatcher) {
        var psd = PSD;
        return function () {
            var wasRootExec = beginMicroTickScope(), outerScope = PSD;
            try {
                switchToZone(psd, true);
                return fn.apply(this, arguments);
            }
            catch (e) {
                errorCatcher && errorCatcher(e);
            }
            finally {
                switchToZone(outerScope, false);
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
    }
    var task = { awaits: 0, echoes: 0, id: 0 };
    var taskCounter = 0;
    var zoneStack = [];
    var zoneEchoes = 0;
    var totalEchoes = 0;
    var zone_id_counter = 0;
    function newScope(fn, props, a1, a2) {
        var parent = PSD, psd = Object.create(parent);
        psd.parent = parent;
        psd.ref = 0;
        psd.global = false;
        psd.id = ++zone_id_counter;
        globalPSD.env;
        psd.env = patchGlobalPromise ? {
            Promise: DexiePromise,
            PromiseProp: { value: DexiePromise, configurable: true, writable: true },
            all: DexiePromise.all,
            race: DexiePromise.race,
            allSettled: DexiePromise.allSettled,
            any: DexiePromise.any,
            resolve: DexiePromise.resolve,
            reject: DexiePromise.reject,
        } : {};
        if (props)
            extend(psd, props);
        ++parent.ref;
        psd.finalize = function () {
            --this.parent.ref || this.parent.finalize();
        };
        var rv = usePSD(psd, fn, a1, a2);
        if (psd.ref === 0)
            psd.finalize();
        return rv;
    }
    function incrementExpectedAwaits() {
        if (!task.id)
            task.id = ++taskCounter;
        ++task.awaits;
        task.echoes += ZONE_ECHO_LIMIT;
        return task.id;
    }
    function decrementExpectedAwaits() {
        if (!task.awaits)
            return false;
        if (--task.awaits === 0)
            task.id = 0;
        task.echoes = task.awaits * ZONE_ECHO_LIMIT;
        return true;
    }
    if (('' + nativePromiseThen).indexOf('[native code]') === -1) {
        incrementExpectedAwaits = decrementExpectedAwaits = nop;
    }
    function onPossibleParallellAsync(possiblePromise) {
        if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
            incrementExpectedAwaits();
            return possiblePromise.then(function (x) {
                decrementExpectedAwaits();
                return x;
            }, function (e) {
                decrementExpectedAwaits();
                return rejection(e);
            });
        }
        return possiblePromise;
    }
    function zoneEnterEcho(targetZone) {
        ++totalEchoes;
        if (!task.echoes || --task.echoes === 0) {
            task.echoes = task.awaits = task.id = 0;
        }
        zoneStack.push(PSD);
        switchToZone(targetZone, true);
    }
    function zoneLeaveEcho() {
        var zone = zoneStack[zoneStack.length - 1];
        zoneStack.pop();
        switchToZone(zone, false);
    }
    function switchToZone(targetZone, bEnteringZone) {
        var currentZone = PSD;
        if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
            queueMicrotask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
        }
        if (targetZone === PSD)
            return;
        PSD = targetZone;
        if (currentZone === globalPSD)
            globalPSD.env = snapShot();
        if (patchGlobalPromise) {
            var GlobalPromise = globalPSD.env.Promise;
            var targetEnv = targetZone.env;
            if (currentZone.global || targetZone.global) {
                Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);
                GlobalPromise.all = targetEnv.all;
                GlobalPromise.race = targetEnv.race;
                GlobalPromise.resolve = targetEnv.resolve;
                GlobalPromise.reject = targetEnv.reject;
                if (targetEnv.allSettled)
                    GlobalPromise.allSettled = targetEnv.allSettled;
                if (targetEnv.any)
                    GlobalPromise.any = targetEnv.any;
            }
        }
    }
    function snapShot() {
        var GlobalPromise = _global.Promise;
        return patchGlobalPromise ? {
            Promise: GlobalPromise,
            PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
            all: GlobalPromise.all,
            race: GlobalPromise.race,
            allSettled: GlobalPromise.allSettled,
            any: GlobalPromise.any,
            resolve: GlobalPromise.resolve,
            reject: GlobalPromise.reject,
        } : {};
    }
    function usePSD(psd, fn, a1, a2, a3) {
        var outerScope = PSD;
        try {
            switchToZone(psd, true);
            return fn(a1, a2, a3);
        }
        finally {
            switchToZone(outerScope, false);
        }
    }
    function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
        return typeof fn !== 'function' ? fn : function () {
            var outerZone = PSD;
            if (possibleAwait)
                incrementExpectedAwaits();
            switchToZone(zone, true);
            try {
                return fn.apply(this, arguments);
            }
            finally {
                switchToZone(outerZone, false);
                if (cleanup)
                    queueMicrotask(decrementExpectedAwaits);
            }
        };
    }
    function execInGlobalContext(cb) {
        if (Promise === NativePromise && task.echoes === 0) {
            if (zoneEchoes === 0) {
                cb();
            }
            else {
                enqueueNativeMicroTask(cb);
            }
        }
        else {
            setTimeout(cb, 0);
        }
    }
    var rejection = DexiePromise.reject;

    function tempTransaction(db, mode, storeNames, fn) {
        if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {
            if (db._state.openComplete) {
                return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
            }
            if (!db._state.isBeingOpened) {
                if (!db._state.autoOpen)
                    return rejection(new exceptions.DatabaseClosed());
                db.open().catch(nop);
            }
            return db._state.dbReadyPromise.then(function () { return tempTransaction(db, mode, storeNames, fn); });
        }
        else {
            var trans = db._createTransaction(mode, storeNames, db._dbSchema);
            try {
                trans.create();
                db._state.PR1398_maxLoop = 3;
            }
            catch (ex) {
                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                    console.warn('Dexie: Need to reopen db');
                    db.close({ disableAutoOpen: false });
                    return db.open().then(function () { return tempTransaction(db, mode, storeNames, fn); });
                }
                return rejection(ex);
            }
            return trans._promise(mode, function (resolve, reject) {
                return newScope(function () {
                    PSD.trans = trans;
                    return fn(resolve, reject, trans);
                });
            }).then(function (result) {
                if (mode === 'readwrite')
                    try {
                        trans.idbtrans.commit();
                    }
                    catch (_a) { }
                return mode === 'readonly' ? result : trans._completion.then(function () { return result; });
            });
        }
    }

    var DEXIE_VERSION = '4.2.0';
    var maxString = String.fromCharCode(65535);
    var minKey = -Infinity;
    var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
    var STRING_EXPECTED = "String expected.";
    var connections = [];
    var DBNAMES_DB = '__dbnames';
    var READONLY = 'readonly';
    var READWRITE = 'readwrite';

    function combine(filter1, filter2) {
        return filter1 ?
            filter2 ?
                function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :
                filter1 :
            filter2;
    }

    var AnyRange = {
        type: 3 ,
        lower: -Infinity,
        lowerOpen: false,
        upper: [[]],
        upperOpen: false
    };

    function workaroundForUndefinedPrimKey(keyPath) {
        return typeof keyPath === "string" && !/\./.test(keyPath)
            ? function (obj) {
                if (obj[keyPath] === undefined && (keyPath in obj)) {
                    obj = deepClone(obj);
                    delete obj[keyPath];
                }
                return obj;
            }
            : function (obj) { return obj; };
    }

    function Entity() {
        throw exceptions.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
    }

    function cmp(a, b) {
        try {
            var ta = type(a);
            var tb = type(b);
            if (ta !== tb) {
                if (ta === 'Array')
                    return 1;
                if (tb === 'Array')
                    return -1;
                if (ta === 'binary')
                    return 1;
                if (tb === 'binary')
                    return -1;
                if (ta === 'string')
                    return 1;
                if (tb === 'string')
                    return -1;
                if (ta === 'Date')
                    return 1;
                if (tb !== 'Date')
                    return NaN;
                return -1;
            }
            switch (ta) {
                case 'number':
                case 'Date':
                case 'string':
                    return a > b ? 1 : a < b ? -1 : 0;
                case 'binary': {
                    return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
                }
                case 'Array':
                    return compareArrays(a, b);
            }
        }
        catch (_a) { }
        return NaN;
    }
    function compareArrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
            var res = cmp(a[i], b[i]);
            if (res !== 0)
                return res;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function compareUint8Arrays(a, b) {
        var al = a.length;
        var bl = b.length;
        var l = al < bl ? al : bl;
        for (var i = 0; i < l; ++i) {
            if (a[i] !== b[i])
                return a[i] < b[i] ? -1 : 1;
        }
        return al === bl ? 0 : al < bl ? -1 : 1;
    }
    function type(x) {
        var t = typeof x;
        if (t !== 'object')
            return t;
        if (ArrayBuffer.isView(x))
            return 'binary';
        var tsTag = toStringTag(x);
        return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;
    }
    function getUint8Array(a) {
        if (a instanceof Uint8Array)
            return a;
        if (ArrayBuffer.isView(a))
            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
        return new Uint8Array(a);
    }

    function builtInDeletionTrigger(table, keys, res) {
        var yProps = table.schema.yProps;
        if (!yProps)
            return res;
        if (keys && res.numFailures > 0)
            keys = keys.filter(function (_, i) { return !res.failures[i]; });
        return Promise.all(yProps.map(function (_a) {
            var updatesTable = _a.updatesTable;
            return keys
                ? table.db.table(updatesTable).where('k').anyOf(keys).delete()
                : table.db.table(updatesTable).clear();
        })).then(function () { return res; });
    }

    var Table =  (function () {
        function Table() {
        }
        Table.prototype._trans = function (mode, fn, writeLocked) {
            var trans = this._tx || PSD.trans;
            var tableName = this.name;
            var task = debug && typeof console !== 'undefined' && console.createTask && console.createTask("Dexie: ".concat(mode === 'readonly' ? 'read' : 'write', " ").concat(this.name));
            function checkTableInTransaction(resolve, reject, trans) {
                if (!trans.schema[tableName])
                    throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
                return fn(trans.idbtrans, trans);
            }
            var wasRootExec = beginMicroTickScope();
            try {
                var p = trans && trans.db._novip === this.db._novip ?
                    trans === PSD.trans ?
                        trans._promise(mode, checkTableInTransaction, writeLocked) :
                        newScope(function () { return trans._promise(mode, checkTableInTransaction, writeLocked); }, { trans: trans, transless: PSD.transless || PSD }) :
                    tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
                if (task) {
                    p._consoleTask = task;
                    p = p.catch(function (err) {
                        console.trace(err);
                        return rejection(err);
                    });
                }
                return p;
            }
            finally {
                if (wasRootExec)
                    endMicroTickScope();
            }
        };
        Table.prototype.get = function (keyOrCrit, cb) {
            var _this = this;
            if (keyOrCrit && keyOrCrit.constructor === Object)
                return this.where(keyOrCrit).first(cb);
            if (keyOrCrit == null)
                return rejection(new exceptions.Type("Invalid argument to Table.get()"));
            return this._trans('readonly', function (trans) {
                return _this.core.get({ trans: trans, key: keyOrCrit })
                    .then(function (res) { return _this.hook.reading.fire(res); });
            }).then(cb);
        };
        Table.prototype.where = function (indexOrCrit) {
            if (typeof indexOrCrit === 'string')
                return new this.db.WhereClause(this, indexOrCrit);
            if (isArray(indexOrCrit))
                return new this.db.WhereClause(this, "[".concat(indexOrCrit.join('+'), "]"));
            var keyPaths = keys(indexOrCrit);
            if (keyPaths.length === 1)
                return this
                    .where(keyPaths[0])
                    .equals(indexOrCrit[keyPaths[0]]);
            var compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(function (ix) {
                if (ix.compound &&
                    keyPaths.every(function (keyPath) { return ix.keyPath.indexOf(keyPath) >= 0; })) {
                    for (var i = 0; i < keyPaths.length; ++i) {
                        if (keyPaths.indexOf(ix.keyPath[i]) === -1)
                            return false;
                    }
                    return true;
                }
                return false;
            }).sort(function (a, b) { return a.keyPath.length - b.keyPath.length; })[0];
            if (compoundIndex && this.db._maxKey !== maxString) {
                var keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
                return this
                    .where(keyPathsInValidOrder)
                    .equals(keyPathsInValidOrder.map(function (kp) { return indexOrCrit[kp]; }));
            }
            if (!compoundIndex && debug)
                console.warn("The query ".concat(JSON.stringify(indexOrCrit), " on ").concat(this.name, " would benefit from a ") +
                    "compound index [".concat(keyPaths.join('+'), "]"));
            var idxByName = this.schema.idxByName;
            function equals(a, b) {
                return cmp(a, b) === 0;
            }
            var _a = keyPaths.reduce(function (_a, keyPath) {
                var prevIndex = _a[0], prevFilterFn = _a[1];
                var index = idxByName[keyPath];
                var value = indexOrCrit[keyPath];
                return [
                    prevIndex || index,
                    prevIndex || !index ?
                        combine(prevFilterFn, index && index.multi ?
                            function (x) {
                                var prop = getByKeyPath(x, keyPath);
                                return isArray(prop) && prop.some(function (item) { return equals(value, item); });
                            } : function (x) { return equals(value, getByKeyPath(x, keyPath)); })
                        : prevFilterFn
                ];
            }, [null, null]), idx = _a[0], filterFunction = _a[1];
            return idx ?
                this.where(idx.name).equals(indexOrCrit[idx.keyPath])
                    .filter(filterFunction) :
                compoundIndex ?
                    this.filter(filterFunction) :
                    this.where(keyPaths).equals('');
        };
        Table.prototype.filter = function (filterFunction) {
            return this.toCollection().and(filterFunction);
        };
        Table.prototype.count = function (thenShortcut) {
            return this.toCollection().count(thenShortcut);
        };
        Table.prototype.offset = function (offset) {
            return this.toCollection().offset(offset);
        };
        Table.prototype.limit = function (numRows) {
            return this.toCollection().limit(numRows);
        };
        Table.prototype.each = function (callback) {
            return this.toCollection().each(callback);
        };
        Table.prototype.toArray = function (thenShortcut) {
            return this.toCollection().toArray(thenShortcut);
        };
        Table.prototype.toCollection = function () {
            return new this.db.Collection(new this.db.WhereClause(this));
        };
        Table.prototype.orderBy = function (index) {
            return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?
                "[".concat(index.join('+'), "]") :
                index));
        };
        Table.prototype.reverse = function () {
            return this.toCollection().reverse();
        };
        Table.prototype.mapToClass = function (constructor) {
            var _a = this, db = _a.db, tableName = _a.name;
            this.schema.mappedClass = constructor;
            if (constructor.prototype instanceof Entity) {
                constructor =  (function (_super) {
                    __extends(class_1, _super);
                    function class_1() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    Object.defineProperty(class_1.prototype, "db", {
                        get: function () { return db; },
                        enumerable: false,
                        configurable: true
                    });
                    class_1.prototype.table = function () { return tableName; };
                    return class_1;
                }(constructor));
            }
            var inheritedProps = new Set();
            for (var proto = constructor.prototype; proto; proto = getProto(proto)) {
                Object.getOwnPropertyNames(proto).forEach(function (propName) { return inheritedProps.add(propName); });
            }
            var readHook = function (obj) {
                if (!obj)
                    return obj;
                var res = Object.create(constructor.prototype);
                for (var m in obj)
                    if (!inheritedProps.has(m))
                        try {
                            res[m] = obj[m];
                        }
                        catch (_) { }
                return res;
            };
            if (this.schema.readHook) {
                this.hook.reading.unsubscribe(this.schema.readHook);
            }
            this.schema.readHook = readHook;
            this.hook("reading", readHook);
            return constructor;
        };
        Table.prototype.defineClass = function () {
            function Class(content) {
                extend(this, content);
            }
            return this.mapToClass(Class);
        };
        Table.prototype.add = function (obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function (trans) {
                return _this.core.mutate({ trans: trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });
            }).then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                .then(function (lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                }
                return lastResult;
            });
        };
        Table.prototype.update = function (keyOrObject, modifications) {
            if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {
                var key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
                if (key === undefined)
                    return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
                return this.where(":id").equals(key).modify(modifications);
            }
            else {
                return this.where(":id").equals(keyOrObject).modify(modifications);
            }
        };
        Table.prototype.put = function (obj, key) {
            var _this = this;
            var _a = this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
            var objToAdd = obj;
            if (keyPath && auto) {
                objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
            }
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult; })
                .then(function (lastResult) {
                if (keyPath) {
                    try {
                        setByKeyPath(obj, keyPath, lastResult);
                    }
                    catch (_) { }
                }
                return lastResult;
            });
        };
        Table.prototype.delete = function (key) {
            var _this = this;
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'delete', keys: [key] })
                .then(function (res) { return builtInDeletionTrigger(_this, [key], res); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; }); });
        };
        Table.prototype.clear = function () {
            var _this = this;
            return this._trans('readwrite', function (trans) { return _this.core.mutate({ trans: trans, type: 'deleteRange', range: AnyRange })
                .then(function (res) { return builtInDeletionTrigger(_this, null, res); }); })
                .then(function (res) { return res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined; });
        };
        Table.prototype.bulkGet = function (keys) {
            var _this = this;
            return this._trans('readonly', function (trans) {
                return _this.core.getMany({
                    keys: keys,
                    trans: trans
                }).then(function (result) { return result.map(function (res) { return _this.hook.reading.fire(res); }); });
            });
        };
        Table.prototype.bulkAdd = function (objects, keysOrOptions, options) {
            var _this = this;
            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function (trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys)
                    throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToAdd = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return _this.core.mutate({ trans: trans, type: 'add', keys: keys, values: objectsToAdd, wantResults: wantResults })
                    .then(function (_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError("".concat(_this.name, ".bulkAdd(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
                });
            });
        };
        Table.prototype.bulkPut = function (objects, keysOrOptions, options) {
            var _this = this;
            var keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;
            options = options || (keys ? undefined : keysOrOptions);
            var wantResults = options ? options.allKeys : undefined;
            return this._trans('readwrite', function (trans) {
                var _a = _this.schema.primKey, auto = _a.auto, keyPath = _a.keyPath;
                if (keyPath && keys)
                    throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
                if (keys && keys.length !== objects.length)
                    throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
                var numObjects = objects.length;
                var objectsToPut = keyPath && auto ?
                    objects.map(workaroundForUndefinedPrimKey(keyPath)) :
                    objects;
                return _this.core.mutate({ trans: trans, type: 'put', keys: keys, values: objectsToPut, wantResults: wantResults })
                    .then(function (_a) {
                    var numFailures = _a.numFailures, results = _a.results, lastResult = _a.lastResult, failures = _a.failures;
                    var result = wantResults ? results : lastResult;
                    if (numFailures === 0)
                        return result;
                    throw new BulkError("".concat(_this.name, ".bulkPut(): ").concat(numFailures, " of ").concat(numObjects, " operations failed"), failures);
                });
            });
        };
        Table.prototype.bulkUpdate = function (keysAndChanges) {
            var _this = this;
            var coreTable = this.core;
            var keys = keysAndChanges.map(function (entry) { return entry.key; });
            var changeSpecs = keysAndChanges.map(function (entry) { return entry.changes; });
            var offsetMap = [];
            return this._trans('readwrite', function (trans) {
                return coreTable.getMany({ trans: trans, keys: keys, cache: 'clone' }).then(function (objs) {
                    var resultKeys = [];
                    var resultObjs = [];
                    keysAndChanges.forEach(function (_a, idx) {
                        var key = _a.key, changes = _a.changes;
                        var obj = objs[idx];
                        if (obj) {
                            for (var _i = 0, _b = Object.keys(changes); _i < _b.length; _i++) {
                                var keyPath = _b[_i];
                                var value = changes[keyPath];
                                if (keyPath === _this.schema.primKey.keyPath) {
                                    if (cmp(value, key) !== 0) {
                                        throw new exceptions.Constraint("Cannot update primary key in bulkUpdate()");
                                    }
                                }
                                else {
                                    setByKeyPath(obj, keyPath, value);
                                }
                            }
                            offsetMap.push(idx);
                            resultKeys.push(key);
                            resultObjs.push(obj);
                        }
                    });
                    var numEntries = resultKeys.length;
                    return coreTable
                        .mutate({
                        trans: trans,
                        type: 'put',
                        keys: resultKeys,
                        values: resultObjs,
                        updates: {
                            keys: keys,
                            changeSpecs: changeSpecs
                        }
                    })
                        .then(function (_a) {
                        var numFailures = _a.numFailures, failures = _a.failures;
                        if (numFailures === 0)
                            return numEntries;
                        for (var _i = 0, _b = Object.keys(failures); _i < _b.length; _i++) {
                            var offset = _b[_i];
                            var mappedOffset = offsetMap[Number(offset)];
                            if (mappedOffset != null) {
                                var failure = failures[offset];
                                delete failures[offset];
                                failures[mappedOffset] = failure;
                            }
                        }
                        throw new BulkError("".concat(_this.name, ".bulkUpdate(): ").concat(numFailures, " of ").concat(numEntries, " operations failed"), failures);
                    });
                });
            });
        };
        Table.prototype.bulkDelete = function (keys) {
            var _this = this;
            var numKeys = keys.length;
            return this._trans('readwrite', function (trans) {
                return _this.core.mutate({ trans: trans, type: 'delete', keys: keys })
                    .then(function (res) { return builtInDeletionTrigger(_this, keys, res); });
            }).then(function (_a) {
                var numFailures = _a.numFailures, lastResult = _a.lastResult, failures = _a.failures;
                if (numFailures === 0)
                    return lastResult;
                throw new BulkError("".concat(_this.name, ".bulkDelete(): ").concat(numFailures, " of ").concat(numKeys, " operations failed"), failures);
            });
        };
        return Table;
    }());

    function Events(ctx) {
        var evs = {};
        var rv = function (eventName, subscriber) {
            if (subscriber) {
                var i = arguments.length, args = new Array(i - 1);
                while (--i)
                    args[i - 1] = arguments[i];
                evs[eventName].subscribe.apply(null, args);
                return ctx;
            }
            else if (typeof (eventName) === 'string') {
                return evs[eventName];
            }
        };
        rv.addEventType = add;
        for (var i = 1, l = arguments.length; i < l; ++i) {
            add(arguments[i]);
        }
        return rv;
        function add(eventName, chainFunction, defaultFunction) {
            if (typeof eventName === 'object')
                return addConfiguredEvents(eventName);
            if (!chainFunction)
                chainFunction = reverseStoppableEventChain;
            if (!defaultFunction)
                defaultFunction = nop;
            var context = {
                subscribers: [],
                fire: defaultFunction,
                subscribe: function (cb) {
                    if (context.subscribers.indexOf(cb) === -1) {
                        context.subscribers.push(cb);
                        context.fire = chainFunction(context.fire, cb);
                    }
                },
                unsubscribe: function (cb) {
                    context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });
                    context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
                }
            };
            evs[eventName] = rv[eventName] = context;
            return context;
        }
        function addConfiguredEvents(cfg) {
            keys(cfg).forEach(function (eventName) {
                var args = cfg[eventName];
                if (isArray(args)) {
                    add(eventName, cfg[eventName][0], cfg[eventName][1]);
                }
                else if (args === 'asap') {
                    var context = add(eventName, mirror, function fire() {
                        var i = arguments.length, args = new Array(i);
                        while (i--)
                            args[i] = arguments[i];
                        context.subscribers.forEach(function (fn) {
                            asap$1(function fireEvent() {
                                fn.apply(null, args);
                            });
                        });
                    });
                }
                else
                    throw new exceptions.InvalidArgument("Invalid event config");
            });
        }
    }

    function makeClassConstructor(prototype, constructor) {
        derive(constructor).from({ prototype: prototype });
        return constructor;
    }

    function createTableConstructor(db) {
        return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {
            this.db = db;
            this._tx = trans;
            this.name = name;
            this.schema = tableSchema;
            this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
                "creating": [hookCreatingChain, nop],
                "reading": [pureFunctionChain, mirror],
                "updating": [hookUpdatingChain, nop],
                "deleting": [hookDeletingChain, nop]
            });
        });
    }

    function isPlainKeyRange(ctx, ignoreLimitFilter) {
        return !(ctx.filter || ctx.algorithm || ctx.or) &&
            (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
    }
    function addFilter(ctx, fn) {
        ctx.filter = combine(ctx.filter, fn);
    }
    function addReplayFilter(ctx, factory, isLimitFilter) {
        var curr = ctx.replayFilter;
        ctx.replayFilter = curr ? function () { return combine(curr(), factory()); } : factory;
        ctx.justLimit = isLimitFilter && !curr;
    }
    function addMatchFilter(ctx, fn) {
        ctx.isMatch = combine(ctx.isMatch, fn);
    }
    function getIndexOrStore(ctx, coreSchema) {
        if (ctx.isPrimKey)
            return coreSchema.primaryKey;
        var index = coreSchema.getIndexByKeyPath(ctx.index);
        if (!index)
            throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
        return index;
    }
    function openCursor(ctx, coreTable, trans) {
        var index = getIndexOrStore(ctx, coreTable.schema);
        return coreTable.openCursor({
            trans: trans,
            values: !ctx.keysOnly,
            reverse: ctx.dir === 'prev',
            unique: !!ctx.unique,
            query: {
                index: index,
                range: ctx.range
            }
        });
    }
    function iter(ctx, fn, coreTrans, coreTable) {
        var filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
        if (!ctx.or) {
            return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
        }
        else {
            var set_1 = {};
            var union = function (item, cursor, advance) {
                if (!filter || filter(cursor, advance, function (result) { return cursor.stop(result); }, function (err) { return cursor.fail(err); })) {
                    var primaryKey = cursor.primaryKey;
                    var key = '' + primaryKey;
                    if (key === '[object ArrayBuffer]')
                        key = '' + new Uint8Array(primaryKey);
                    if (!hasOwn(set_1, key)) {
                        set_1[key] = true;
                        fn(item, cursor, advance);
                    }
                }
            };
            return Promise.all([
                ctx.or._iterate(union, coreTrans),
                iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
            ]);
        }
    }
    function iterate(cursorPromise, filter, fn, valueMapper) {
        var mappedFn = valueMapper ? function (x, c, a) { return fn(valueMapper(x), c, a); } : fn;
        var wrappedFn = wrap(mappedFn);
        return cursorPromise.then(function (cursor) {
            if (cursor) {
                return cursor.start(function () {
                    var c = function () { return cursor.continue(); };
                    if (!filter || filter(cursor, function (advancer) { return c = advancer; }, function (val) { cursor.stop(val); c = nop; }, function (e) { cursor.fail(e); c = nop; }))
                        wrappedFn(cursor.value, cursor, function (advancer) { return c = advancer; });
                    c();
                });
            }
        });
    }

    var PropModification =  (function () {
        function PropModification(spec) {
            this["@@propmod"] = spec;
        }
        PropModification.prototype.execute = function (value) {
            var _a;
            var spec = this["@@propmod"];
            if (spec.add !== undefined) {
                var term = spec.add;
                if (isArray(term)) {
                    return __spreadArray(__spreadArray([], (isArray(value) ? value : []), true), term, true).sort();
                }
                if (typeof term === 'number')
                    return (Number(value) || 0) + term;
                if (typeof term === 'bigint') {
                    try {
                        return BigInt(value) + term;
                    }
                    catch (_b) {
                        return BigInt(0) + term;
                    }
                }
                throw new TypeError("Invalid term ".concat(term));
            }
            if (spec.remove !== undefined) {
                var subtrahend_1 = spec.remove;
                if (isArray(subtrahend_1)) {
                    return isArray(value) ? value.filter(function (item) { return !subtrahend_1.includes(item); }).sort() : [];
                }
                if (typeof subtrahend_1 === 'number')
                    return Number(value) - subtrahend_1;
                if (typeof subtrahend_1 === 'bigint') {
                    try {
                        return BigInt(value) - subtrahend_1;
                    }
                    catch (_c) {
                        return BigInt(0) - subtrahend_1;
                    }
                }
                throw new TypeError("Invalid subtrahend ".concat(subtrahend_1));
            }
            var prefixToReplace = (_a = spec.replacePrefix) === null || _a === void 0 ? void 0 : _a[0];
            if (prefixToReplace && typeof value === 'string' && value.startsWith(prefixToReplace)) {
                return spec.replacePrefix[1] + value.substring(prefixToReplace.length);
            }
            return value;
        };
        return PropModification;
    }());

    var Collection =  (function () {
        function Collection() {
        }
        Collection.prototype._read = function (fn, cb) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readonly', fn).then(cb);
        };
        Collection.prototype._write = function (fn) {
            var ctx = this._ctx;
            return ctx.error ?
                ctx.table._trans(null, rejection.bind(null, ctx.error)) :
                ctx.table._trans('readwrite', fn, "locked");
        };
        Collection.prototype._addAlgorithm = function (fn) {
            var ctx = this._ctx;
            ctx.algorithm = combine(ctx.algorithm, fn);
        };
        Collection.prototype._iterate = function (fn, coreTrans) {
            return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
        };
        Collection.prototype.clone = function (props) {
            var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
            if (props)
                extend(ctx, props);
            rv._ctx = ctx;
            return rv;
        };
        Collection.prototype.raw = function () {
            this._ctx.valueMapper = null;
            return this;
        };
        Collection.prototype.each = function (fn) {
            var ctx = this._ctx;
            return this._read(function (trans) { return iter(ctx, fn, trans, ctx.table.core); });
        };
        Collection.prototype.count = function (cb) {
            var _this = this;
            return this._read(function (trans) {
                var ctx = _this._ctx;
                var coreTable = ctx.table.core;
                if (isPlainKeyRange(ctx, true)) {
                    return coreTable.count({
                        trans: trans,
                        query: {
                            index: getIndexOrStore(ctx, coreTable.schema),
                            range: ctx.range
                        }
                    }).then(function (count) { return Math.min(count, ctx.limit); });
                }
                else {
                    var count = 0;
                    return iter(ctx, function () { ++count; return false; }, trans, coreTable)
                        .then(function () { return count; });
                }
            }).then(cb);
        };
        Collection.prototype.sortBy = function (keyPath, cb) {
            var parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
            function getval(obj, i) {
                if (i)
                    return getval(obj[parts[i]], i - 1);
                return obj[lastPart];
            }
            var order = this._ctx.dir === "next" ? 1 : -1;
            function sorter(a, b) {
                var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
                return cmp(aVal, bVal) * order;
            }
            return this.toArray(function (a) {
                return a.sort(sorter);
            }).then(cb);
        };
        Collection.prototype.toArray = function (cb) {
            var _this = this;
            return this._read(function (trans) {
                var ctx = _this._ctx;
                if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                    var valueMapper_1 = ctx.valueMapper;
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        limit: ctx.limit,
                        values: true,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    }).then(function (_a) {
                        var result = _a.result;
                        return valueMapper_1 ? result.map(valueMapper_1) : result;
                    });
                }
                else {
                    var a_1 = [];
                    return iter(ctx, function (item) { return a_1.push(item); }, trans, ctx.table.core).then(function () { return a_1; });
                }
            }, cb);
        };
        Collection.prototype.offset = function (offset) {
            var ctx = this._ctx;
            if (offset <= 0)
                return this;
            ctx.offset += offset;
            if (isPlainKeyRange(ctx)) {
                addReplayFilter(ctx, function () {
                    var offsetLeft = offset;
                    return function (cursor, advance) {
                        if (offsetLeft === 0)
                            return true;
                        if (offsetLeft === 1) {
                            --offsetLeft;
                            return false;
                        }
                        advance(function () {
                            cursor.advance(offsetLeft);
                            offsetLeft = 0;
                        });
                        return false;
                    };
                });
            }
            else {
                addReplayFilter(ctx, function () {
                    var offsetLeft = offset;
                    return function () { return (--offsetLeft < 0); };
                });
            }
            return this;
        };
        Collection.prototype.limit = function (numRows) {
            this._ctx.limit = Math.min(this._ctx.limit, numRows);
            addReplayFilter(this._ctx, function () {
                var rowsLeft = numRows;
                return function (cursor, advance, resolve) {
                    if (--rowsLeft <= 0)
                        advance(resolve);
                    return rowsLeft >= 0;
                };
            }, true);
            return this;
        };
        Collection.prototype.until = function (filterFunction, bIncludeStopEntry) {
            addFilter(this._ctx, function (cursor, advance, resolve) {
                if (filterFunction(cursor.value)) {
                    advance(resolve);
                    return bIncludeStopEntry;
                }
                else {
                    return true;
                }
            });
            return this;
        };
        Collection.prototype.first = function (cb) {
            return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);
        };
        Collection.prototype.last = function (cb) {
            return this.reverse().first(cb);
        };
        Collection.prototype.filter = function (filterFunction) {
            addFilter(this._ctx, function (cursor) {
                return filterFunction(cursor.value);
            });
            addMatchFilter(this._ctx, filterFunction);
            return this;
        };
        Collection.prototype.and = function (filter) {
            return this.filter(filter);
        };
        Collection.prototype.or = function (indexName) {
            return new this.db.WhereClause(this._ctx.table, indexName, this);
        };
        Collection.prototype.reverse = function () {
            this._ctx.dir = (this._ctx.dir === "prev" ? "next" : "prev");
            if (this._ondirectionchange)
                this._ondirectionchange(this._ctx.dir);
            return this;
        };
        Collection.prototype.desc = function () {
            return this.reverse();
        };
        Collection.prototype.eachKey = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.key, cursor); });
        };
        Collection.prototype.eachUniqueKey = function (cb) {
            this._ctx.unique = "unique";
            return this.eachKey(cb);
        };
        Collection.prototype.eachPrimaryKey = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });
        };
        Collection.prototype.keys = function (cb) {
            var ctx = this._ctx;
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.key);
            }).then(function () {
                return a;
            }).then(cb);
        };
        Collection.prototype.primaryKeys = function (cb) {
            var ctx = this._ctx;
            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
                return this._read(function (trans) {
                    var index = getIndexOrStore(ctx, ctx.table.core.schema);
                    return ctx.table.core.query({
                        trans: trans,
                        values: false,
                        limit: ctx.limit,
                        query: {
                            index: index,
                            range: ctx.range
                        }
                    });
                }).then(function (_a) {
                    var result = _a.result;
                    return result;
                }).then(cb);
            }
            ctx.keysOnly = !ctx.isMatch;
            var a = [];
            return this.each(function (item, cursor) {
                a.push(cursor.primaryKey);
            }).then(function () {
                return a;
            }).then(cb);
        };
        Collection.prototype.uniqueKeys = function (cb) {
            this._ctx.unique = "unique";
            return this.keys(cb);
        };
        Collection.prototype.firstKey = function (cb) {
            return this.limit(1).keys(function (a) { return a[0]; }).then(cb);
        };
        Collection.prototype.lastKey = function (cb) {
            return this.reverse().firstKey(cb);
        };
        Collection.prototype.distinct = function () {
            var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
            if (!idx || !idx.multi)
                return this;
            var set = {};
            addFilter(this._ctx, function (cursor) {
                var strKey = cursor.primaryKey.toString();
                var found = hasOwn(set, strKey);
                set[strKey] = true;
                return !found;
            });
            return this;
        };
        Collection.prototype.modify = function (changes) {
            var _this = this;
            var ctx = this._ctx;
            return this._write(function (trans) {
                var modifyer;
                if (typeof changes === 'function') {
                    modifyer = changes;
                }
                else {
                    var keyPaths = keys(changes);
                    var numKeys = keyPaths.length;
                    modifyer = function (item) {
                        var anythingModified = false;
                        for (var i = 0; i < numKeys; ++i) {
                            var keyPath = keyPaths[i];
                            var val = changes[keyPath];
                            var origVal = getByKeyPath(item, keyPath);
                            if (val instanceof PropModification) {
                                setByKeyPath(item, keyPath, val.execute(origVal));
                                anythingModified = true;
                            }
                            else if (origVal !== val) {
                                setByKeyPath(item, keyPath, val);
                                anythingModified = true;
                            }
                        }
                        return anythingModified;
                    };
                }
                var coreTable = ctx.table.core;
                var _a = coreTable.schema.primaryKey, outbound = _a.outbound, extractKey = _a.extractKey;
                var limit = 200;
                var modifyChunkSize = _this.db._options.modifyChunkSize;
                if (modifyChunkSize) {
                    if (typeof modifyChunkSize == 'object') {
                        limit = modifyChunkSize[coreTable.name] || modifyChunkSize['*'] || 200;
                    }
                    else {
                        limit = modifyChunkSize;
                    }
                }
                var totalFailures = [];
                var successCount = 0;
                var failedKeys = [];
                var applyMutateResult = function (expectedCount, res) {
                    var failures = res.failures, numFailures = res.numFailures;
                    successCount += expectedCount - numFailures;
                    for (var _i = 0, _a = keys(failures); _i < _a.length; _i++) {
                        var pos = _a[_i];
                        totalFailures.push(failures[pos]);
                    }
                };
                var isUnconditionalDelete = changes === deleteCallback;
                return _this.clone().primaryKeys().then(function (keys) {
                    var criteria = isPlainKeyRange(ctx) &&
                        ctx.limit === Infinity &&
                        (typeof changes !== 'function' || isUnconditionalDelete) && {
                        index: ctx.index,
                        range: ctx.range
                    };
                    var nextChunk = function (offset) {
                        var count = Math.min(limit, keys.length - offset);
                        var keysInChunk = keys.slice(offset, offset + count);
                        return (isUnconditionalDelete ? Promise.resolve([]) : coreTable.getMany({
                            trans: trans,
                            keys: keysInChunk,
                            cache: "immutable"
                        })).then(function (values) {
                            var addValues = [];
                            var putValues = [];
                            var putKeys = outbound ? [] : null;
                            var deleteKeys = isUnconditionalDelete ? keysInChunk : [];
                            if (!isUnconditionalDelete)
                                for (var i = 0; i < count; ++i) {
                                    var origValue = values[i];
                                    var ctx_1 = {
                                        value: deepClone(origValue),
                                        primKey: keys[offset + i]
                                    };
                                    if (modifyer.call(ctx_1, ctx_1.value, ctx_1) !== false) {
                                        if (ctx_1.value == null) {
                                            deleteKeys.push(keys[offset + i]);
                                        }
                                        else if (!outbound && cmp(extractKey(origValue), extractKey(ctx_1.value)) !== 0) {
                                            deleteKeys.push(keys[offset + i]);
                                            addValues.push(ctx_1.value);
                                        }
                                        else {
                                            putValues.push(ctx_1.value);
                                            if (outbound)
                                                putKeys.push(keys[offset + i]);
                                        }
                                    }
                                }
                            return Promise.resolve(addValues.length > 0 &&
                                coreTable.mutate({ trans: trans, type: 'add', values: addValues })
                                    .then(function (res) {
                                    for (var pos in res.failures) {
                                        deleteKeys.splice(parseInt(pos), 1);
                                    }
                                    applyMutateResult(addValues.length, res);
                                })).then(function () { return (putValues.length > 0 || (criteria && typeof changes === 'object')) &&
                                coreTable.mutate({
                                    trans: trans,
                                    type: 'put',
                                    keys: putKeys,
                                    values: putValues,
                                    criteria: criteria,
                                    changeSpec: typeof changes !== 'function'
                                        && changes,
                                    isAdditionalChunk: offset > 0
                                }).then(function (res) { return applyMutateResult(putValues.length, res); }); }).then(function () { return (deleteKeys.length > 0 || (criteria && isUnconditionalDelete)) &&
                                coreTable.mutate({
                                    trans: trans,
                                    type: 'delete',
                                    keys: deleteKeys,
                                    criteria: criteria,
                                    isAdditionalChunk: offset > 0
                                }).then(function (res) { return builtInDeletionTrigger(ctx.table, deleteKeys, res); })
                                    .then(function (res) { return applyMutateResult(deleteKeys.length, res); }); }).then(function () {
                                return keys.length > offset + count && nextChunk(offset + limit);
                            });
                        });
                    };
                    return nextChunk(0).then(function () {
                        if (totalFailures.length > 0)
                            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
                        return keys.length;
                    });
                });
            });
        };
        Collection.prototype.delete = function () {
            var ctx = this._ctx, range = ctx.range;
            if (isPlainKeyRange(ctx) &&
                !ctx.table.schema.yProps &&
                (ctx.isPrimKey || range.type === 3 ))
             {
                return this._write(function (trans) {
                    var primaryKey = ctx.table.core.schema.primaryKey;
                    var coreRange = range;
                    return ctx.table.core.count({ trans: trans, query: { index: primaryKey, range: coreRange } }).then(function (count) {
                        return ctx.table.core.mutate({ trans: trans, type: 'deleteRange', range: coreRange })
                            .then(function (_a) {
                            var failures = _a.failures, numFailures = _a.numFailures;
                            if (numFailures)
                                throw new ModifyError("Could not delete some values", Object.keys(failures).map(function (pos) { return failures[pos]; }), count - numFailures);
                            return count - numFailures;
                        });
                    });
                });
            }
            return this.modify(deleteCallback);
        };
        return Collection;
    }());
    var deleteCallback = function (value, ctx) { return ctx.value = null; };

    function createCollectionConstructor(db) {
        return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {
            this.db = db;
            var keyRange = AnyRange, error = null;
            if (keyRangeGenerator)
                try {
                    keyRange = keyRangeGenerator();
                }
                catch (ex) {
                    error = ex;
                }
            var whereCtx = whereClause._ctx;
            var table = whereCtx.table;
            var readingHook = table.hook.reading.fire;
            this._ctx = {
                table: table,
                index: whereCtx.index,
                isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),
                range: keyRange,
                keysOnly: false,
                dir: "next",
                unique: "",
                algorithm: null,
                filter: null,
                replayFilter: null,
                justLimit: true,
                isMatch: null,
                offset: 0,
                limit: Infinity,
                error: error,
                or: whereCtx.or,
                valueMapper: readingHook !== mirror ? readingHook : null
            };
        });
    }

    function simpleCompare(a, b) {
        return a < b ? -1 : a === b ? 0 : 1;
    }
    function simpleCompareReverse(a, b) {
        return a > b ? -1 : a === b ? 0 : 1;
    }

    function fail(collectionOrWhereClause, err, T) {
        var collection = collectionOrWhereClause instanceof WhereClause ?
            new collectionOrWhereClause.Collection(collectionOrWhereClause) :
            collectionOrWhereClause;
        collection._ctx.error = T ? new T(err) : new TypeError(err);
        return collection;
    }
    function emptyCollection(whereClause) {
        return new whereClause.Collection(whereClause, function () { return rangeEqual(""); }).limit(0);
    }
    function upperFactory(dir) {
        return dir === "next" ?
            function (s) { return s.toUpperCase(); } :
            function (s) { return s.toLowerCase(); };
    }
    function lowerFactory(dir) {
        return dir === "next" ?
            function (s) { return s.toLowerCase(); } :
            function (s) { return s.toUpperCase(); };
    }
    function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {
        var length = Math.min(key.length, lowerNeedle.length);
        var llp = -1;
        for (var i = 0; i < length; ++i) {
            var lwrKeyChar = lowerKey[i];
            if (lwrKeyChar !== lowerNeedle[i]) {
                if (cmp(key[i], upperNeedle[i]) < 0)
                    return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
                if (cmp(key[i], lowerNeedle[i]) < 0)
                    return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
                if (llp >= 0)
                    return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
                return null;
            }
            if (cmp(key[i], lwrKeyChar) < 0)
                llp = i;
        }
        if (length < lowerNeedle.length && dir === "next")
            return key + upperNeedle.substr(key.length);
        if (length < key.length && dir === "prev")
            return key.substr(0, upperNeedle.length);
        return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));
    }
    function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
        var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
        if (!needles.every(function (s) { return typeof s === 'string'; })) {
            return fail(whereClause, STRING_EXPECTED);
        }
        function initDirection(dir) {
            upper = upperFactory(dir);
            lower = lowerFactory(dir);
            compare = (dir === "next" ? simpleCompare : simpleCompareReverse);
            var needleBounds = needles.map(function (needle) {
                return { lower: lower(needle), upper: upper(needle) };
            }).sort(function (a, b) {
                return compare(a.lower, b.lower);
            });
            upperNeedles = needleBounds.map(function (nb) { return nb.upper; });
            lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });
            direction = dir;
            nextKeySuffix = (dir === "next" ? "" : suffix);
        }
        initDirection("next");
        var c = new whereClause.Collection(whereClause, function () { return createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix); });
        c._ondirectionchange = function (direction) {
            initDirection(direction);
        };
        var firstPossibleNeedle = 0;
        c._addAlgorithm(function (cursor, advance, resolve) {
            var key = cursor.key;
            if (typeof key !== 'string')
                return false;
            var lowerKey = lower(key);
            if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
                return true;
            }
            else {
                var lowestPossibleCasing = null;
                for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
                    var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
                    if (casing === null && lowestPossibleCasing === null)
                        firstPossibleNeedle = i + 1;
                    else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
                        lowestPossibleCasing = casing;
                    }
                }
                if (lowestPossibleCasing !== null) {
                    advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });
                }
                else {
                    advance(resolve);
                }
                return false;
            }
        });
        return c;
    }
    function createRange(lower, upper, lowerOpen, upperOpen) {
        return {
            type: 2 ,
            lower: lower,
            upper: upper,
            lowerOpen: lowerOpen,
            upperOpen: upperOpen
        };
    }
    function rangeEqual(value) {
        return {
            type: 1 ,
            lower: value,
            upper: value
        };
    }

    var WhereClause =  (function () {
        function WhereClause() {
        }
        Object.defineProperty(WhereClause.prototype, "Collection", {
            get: function () {
                return this._ctx.table.db.Collection;
            },
            enumerable: false,
            configurable: true
        });
        WhereClause.prototype.between = function (lower, upper, includeLower, includeUpper) {
            includeLower = includeLower !== false;
            includeUpper = includeUpper === true;
            try {
                if ((this._cmp(lower, upper) > 0) ||
                    (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))
                    return emptyCollection(this);
                return new this.Collection(this, function () { return createRange(lower, upper, !includeLower, !includeUpper); });
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
        };
        WhereClause.prototype.equals = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return rangeEqual(value); });
        };
        WhereClause.prototype.above = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(value, undefined, true); });
        };
        WhereClause.prototype.aboveOrEqual = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(value, undefined, false); });
        };
        WhereClause.prototype.below = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(undefined, value, false, true); });
        };
        WhereClause.prototype.belowOrEqual = function (value) {
            if (value == null)
                return fail(this, INVALID_KEY_ARGUMENT);
            return new this.Collection(this, function () { return createRange(undefined, value); });
        };
        WhereClause.prototype.startsWith = function (str) {
            if (typeof str !== 'string')
                return fail(this, STRING_EXPECTED);
            return this.between(str, str + maxString, true, true);
        };
        WhereClause.prototype.startsWithIgnoreCase = function (str) {
            if (str === "")
                return this.startsWith(str);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return x.indexOf(a[0]) === 0; }, [str], maxString);
        };
        WhereClause.prototype.equalsIgnoreCase = function (str) {
            return addIgnoreCaseAlgorithm(this, function (x, a) { return x === a[0]; }, [str], "");
        };
        WhereClause.prototype.anyOfIgnoreCase = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.indexOf(x) !== -1; }, set, "");
        };
        WhereClause.prototype.startsWithAnyOfIgnoreCase = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return emptyCollection(this);
            return addIgnoreCaseAlgorithm(this, function (x, a) { return a.some(function (n) { return x.indexOf(n) === 0; }); }, set, maxString);
        };
        WhereClause.prototype.anyOf = function () {
            var _this = this;
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            var compare = this._cmp;
            try {
                set.sort(compare);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            if (set.length === 0)
                return emptyCollection(this);
            var c = new this.Collection(this, function () { return createRange(set[0], set[set.length - 1]); });
            c._ondirectionchange = function (direction) {
                compare = (direction === "next" ?
                    _this._ascending :
                    _this._descending);
                set.sort(compare);
            };
            var i = 0;
            c._addAlgorithm(function (cursor, advance, resolve) {
                var key = cursor.key;
                while (compare(key, set[i]) > 0) {
                    ++i;
                    if (i === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (compare(key, set[i]) === 0) {
                    return true;
                }
                else {
                    advance(function () { cursor.continue(set[i]); });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.notEqual = function (value) {
            return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
        };
        WhereClause.prototype.noneOf = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (set.length === 0)
                return new this.Collection(this);
            try {
                set.sort(this._ascending);
            }
            catch (e) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var ranges = set.reduce(function (res, val) { return res ?
                res.concat([[res[res.length - 1][1], val]]) :
                [[minKey, val]]; }, null);
            ranges.push([set[set.length - 1], this.db._maxKey]);
            return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
        };
        WhereClause.prototype.inAnyRange = function (ranges, options) {
            var _this = this;
            var cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;
            if (ranges.length === 0)
                return emptyCollection(this);
            if (!ranges.every(function (range) {
                return range[0] !== undefined &&
                    range[1] !== undefined &&
                    ascending(range[0], range[1]) <= 0;
            })) {
                return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
            }
            var includeLowers = !options || options.includeLowers !== false;
            var includeUppers = options && options.includeUppers === true;
            function addRange(ranges, newRange) {
                var i = 0, l = ranges.length;
                for (; i < l; ++i) {
                    var range = ranges[i];
                    if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {
                        range[0] = min(range[0], newRange[0]);
                        range[1] = max(range[1], newRange[1]);
                        break;
                    }
                }
                if (i === l)
                    ranges.push(newRange);
                return ranges;
            }
            var sortDirection = ascending;
            function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }
            var set;
            try {
                set = ranges.reduce(addRange, []);
                set.sort(rangeSorter);
            }
            catch (ex) {
                return fail(this, INVALID_KEY_ARGUMENT);
            }
            var rangePos = 0;
            var keyIsBeyondCurrentEntry = includeUppers ?
                function (key) { return ascending(key, set[rangePos][1]) > 0; } :
                function (key) { return ascending(key, set[rangePos][1]) >= 0; };
            var keyIsBeforeCurrentEntry = includeLowers ?
                function (key) { return descending(key, set[rangePos][0]) > 0; } :
                function (key) { return descending(key, set[rangePos][0]) >= 0; };
            function keyWithinCurrentRange(key) {
                return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
            }
            var checkKey = keyIsBeyondCurrentEntry;
            var c = new this.Collection(this, function () { return createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers); });
            c._ondirectionchange = function (direction) {
                if (direction === "next") {
                    checkKey = keyIsBeyondCurrentEntry;
                    sortDirection = ascending;
                }
                else {
                    checkKey = keyIsBeforeCurrentEntry;
                    sortDirection = descending;
                }
                set.sort(rangeSorter);
            };
            c._addAlgorithm(function (cursor, advance, resolve) {
                var key = cursor.key;
                while (checkKey(key)) {
                    ++rangePos;
                    if (rangePos === set.length) {
                        advance(resolve);
                        return false;
                    }
                }
                if (keyWithinCurrentRange(key)) {
                    return true;
                }
                else if (_this._cmp(key, set[rangePos][1]) === 0 || _this._cmp(key, set[rangePos][0]) === 0) {
                    return false;
                }
                else {
                    advance(function () {
                        if (sortDirection === ascending)
                            cursor.continue(set[rangePos][0]);
                        else
                            cursor.continue(set[rangePos][1]);
                    });
                    return false;
                }
            });
            return c;
        };
        WhereClause.prototype.startsWithAnyOf = function () {
            var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
            if (!set.every(function (s) { return typeof s === 'string'; })) {
                return fail(this, "startsWithAnyOf() only works with strings");
            }
            if (set.length === 0)
                return emptyCollection(this);
            return this.inAnyRange(set.map(function (str) { return [str, str + maxString]; }));
        };
        return WhereClause;
    }());

    function createWhereClauseConstructor(db) {
        return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {
            this.db = db;
            this._ctx = {
                table: table,
                index: index === ":id" ? null : index,
                or: orCollection
            };
            this._cmp = this._ascending = cmp;
            this._descending = function (a, b) { return cmp(b, a); };
            this._max = function (a, b) { return cmp(a, b) > 0 ? a : b; };
            this._min = function (a, b) { return cmp(a, b) < 0 ? a : b; };
            this._IDBKeyRange = db._deps.IDBKeyRange;
            if (!this._IDBKeyRange)
                throw new exceptions.MissingAPI();
        });
    }

    function eventRejectHandler(reject) {
        return wrap(function (event) {
            preventDefault(event);
            reject(event.target.error);
            return false;
        });
    }
    function preventDefault(event) {
        if (event.stopPropagation)
            event.stopPropagation();
        if (event.preventDefault)
            event.preventDefault();
    }

    var DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';
    var STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';
    var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);

    var Transaction =  (function () {
        function Transaction() {
        }
        Transaction.prototype._lock = function () {
            assert(!PSD.global);
            ++this._reculock;
            if (this._reculock === 1 && !PSD.global)
                PSD.lockOwnerFor = this;
            return this;
        };
        Transaction.prototype._unlock = function () {
            assert(!PSD.global);
            if (--this._reculock === 0) {
                if (!PSD.global)
                    PSD.lockOwnerFor = null;
                while (this._blockedFuncs.length > 0 && !this._locked()) {
                    var fnAndPSD = this._blockedFuncs.shift();
                    try {
                        usePSD(fnAndPSD[1], fnAndPSD[0]);
                    }
                    catch (e) { }
                }
            }
            return this;
        };
        Transaction.prototype._locked = function () {
            return this._reculock && PSD.lockOwnerFor !== this;
        };
        Transaction.prototype.create = function (idbtrans) {
            var _this = this;
            if (!this.mode)
                return this;
            var idbdb = this.db.idbdb;
            var dbOpenError = this.db._state.dbOpenError;
            assert(!this.idbtrans);
            if (!idbtrans && !idbdb) {
                switch (dbOpenError && dbOpenError.name) {
                    case "DatabaseClosedError":
                        throw new exceptions.DatabaseClosed(dbOpenError);
                    case "MissingAPIError":
                        throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
                    default:
                        throw new exceptions.OpenFailed(dbOpenError);
                }
            }
            if (!this.active)
                throw new exceptions.TransactionInactive();
            assert(this._completion._state === null);
            idbtrans = this.idbtrans = idbtrans ||
                (this.db.core
                    ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })
                    : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
            idbtrans.onerror = wrap(function (ev) {
                preventDefault(ev);
                _this._reject(idbtrans.error);
            });
            idbtrans.onabort = wrap(function (ev) {
                preventDefault(ev);
                _this.active && _this._reject(new exceptions.Abort(idbtrans.error));
                _this.active = false;
                _this.on("abort").fire(ev);
            });
            idbtrans.oncomplete = wrap(function () {
                _this.active = false;
                _this._resolve();
                if ('mutatedParts' in idbtrans) {
                    globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
                }
            });
            return this;
        };
        Transaction.prototype._promise = function (mode, fn, bWriteLock) {
            var _this = this;
            if (mode === 'readwrite' && this.mode !== 'readwrite')
                return rejection(new exceptions.ReadOnly("Transaction is readonly"));
            if (!this.active)
                return rejection(new exceptions.TransactionInactive());
            if (this._locked()) {
                return new DexiePromise(function (resolve, reject) {
                    _this._blockedFuncs.push([function () {
                            _this._promise(mode, fn, bWriteLock).then(resolve, reject);
                        }, PSD]);
                });
            }
            else if (bWriteLock) {
                return newScope(function () {
                    var p = new DexiePromise(function (resolve, reject) {
                        _this._lock();
                        var rv = fn(resolve, reject, _this);
                        if (rv && rv.then)
                            rv.then(resolve, reject);
                    });
                    p.finally(function () { return _this._unlock(); });
                    p._lib = true;
                    return p;
                });
            }
            else {
                var p = new DexiePromise(function (resolve, reject) {
                    var rv = fn(resolve, reject, _this);
                    if (rv && rv.then)
                        rv.then(resolve, reject);
                });
                p._lib = true;
                return p;
            }
        };
        Transaction.prototype._root = function () {
            return this.parent ? this.parent._root() : this;
        };
        Transaction.prototype.waitFor = function (promiseLike) {
            var root = this._root();
            var promise = DexiePromise.resolve(promiseLike);
            if (root._waitingFor) {
                root._waitingFor = root._waitingFor.then(function () { return promise; });
            }
            else {
                root._waitingFor = promise;
                root._waitingQueue = [];
                var store = root.idbtrans.objectStore(root.storeNames[0]);
                (function spin() {
                    ++root._spinCount;
                    while (root._waitingQueue.length)
                        (root._waitingQueue.shift())();
                    if (root._waitingFor)
                        store.get(-Infinity).onsuccess = spin;
                }());
            }
            var currentWaitPromise = root._waitingFor;
            return new DexiePromise(function (resolve, reject) {
                promise.then(function (res) { return root._waitingQueue.push(wrap(resolve.bind(null, res))); }, function (err) { return root._waitingQueue.push(wrap(reject.bind(null, err))); }).finally(function () {
                    if (root._waitingFor === currentWaitPromise) {
                        root._waitingFor = null;
                    }
                });
            });
        };
        Transaction.prototype.abort = function () {
            if (this.active) {
                this.active = false;
                if (this.idbtrans)
                    this.idbtrans.abort();
                this._reject(new exceptions.Abort());
            }
        };
        Transaction.prototype.table = function (tableName) {
            var memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));
            if (hasOwn(memoizedTables, tableName))
                return memoizedTables[tableName];
            var tableSchema = this.schema[tableName];
            if (!tableSchema) {
                throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
            }
            var transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
            transactionBoundTable.core = this.db.core.table(tableName);
            memoizedTables[tableName] = transactionBoundTable;
            return transactionBoundTable;
        };
        return Transaction;
    }());

    function createTransactionConstructor(db) {
        return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
            var _this = this;
            if (mode !== 'readonly')
                storeNames.forEach(function (storeName) {
                    var _a;
                    var yProps = (_a = dbschema[storeName]) === null || _a === void 0 ? void 0 : _a.yProps;
                    if (yProps)
                        storeNames = storeNames.concat(yProps.map(function (p) { return p.updatesTable; }));
                });
            this.db = db;
            this.mode = mode;
            this.storeNames = storeNames;
            this.schema = dbschema;
            this.chromeTransactionDurability = chromeTransactionDurability;
            this.idbtrans = null;
            this.on = Events(this, "complete", "error", "abort");
            this.parent = parent || null;
            this.active = true;
            this._reculock = 0;
            this._blockedFuncs = [];
            this._resolve = null;
            this._reject = null;
            this._waitingFor = null;
            this._waitingQueue = null;
            this._spinCount = 0;
            this._completion = new DexiePromise(function (resolve, reject) {
                _this._resolve = resolve;
                _this._reject = reject;
            });
            this._completion.then(function () {
                _this.active = false;
                _this.on.complete.fire();
            }, function (e) {
                var wasActive = _this.active;
                _this.active = false;
                _this.on.error.fire(e);
                _this.parent ?
                    _this.parent._reject(e) :
                    wasActive && _this.idbtrans && _this.idbtrans.abort();
                return rejection(e);
            });
        });
    }

    function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey, type) {
        return {
            name: name,
            keyPath: keyPath,
            unique: unique,
            multi: multi,
            auto: auto,
            compound: compound,
            src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? "++" : "") + nameFromKeyPath(keyPath),
            type: type
        };
    }
    function nameFromKeyPath(keyPath) {
        return typeof keyPath === 'string' ?
            keyPath :
            keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : "";
    }

    function createTableSchema(name, primKey, indexes) {
        return {
            name: name,
            primKey: primKey,
            indexes: indexes,
            mappedClass: null,
            idxByName: arrayToObject(indexes, function (index) { return [index.name, index]; }),
        };
    }

    function safariMultiStoreFix(storeNames) {
        return storeNames.length === 1 ? storeNames[0] : storeNames;
    }
    var getMaxKey = function (IdbKeyRange) {
        try {
            IdbKeyRange.only([[]]);
            getMaxKey = function () { return [[]]; };
            return [[]];
        }
        catch (e) {
            getMaxKey = function () { return maxString; };
            return maxString;
        }
    };

    function getKeyExtractor(keyPath) {
        if (keyPath == null) {
            return function () { return undefined; };
        }
        else if (typeof keyPath === 'string') {
            return getSinglePathKeyExtractor(keyPath);
        }
        else {
            return function (obj) { return getByKeyPath(obj, keyPath); };
        }
    }
    function getSinglePathKeyExtractor(keyPath) {
        var split = keyPath.split('.');
        if (split.length === 1) {
            return function (obj) { return obj[keyPath]; };
        }
        else {
            return function (obj) { return getByKeyPath(obj, keyPath); };
        }
    }

    function arrayify(arrayLike) {
        return [].slice.call(arrayLike);
    }
    var _id_counter = 0;
    function getKeyPathAlias(keyPath) {
        return keyPath == null ?
            ":id" :
            typeof keyPath === 'string' ?
                keyPath :
                "[".concat(keyPath.join('+'), "]");
    }
    function createDBCore(db, IdbKeyRange, tmpTrans) {
        function extractSchema(db, trans) {
            var tables = arrayify(db.objectStoreNames);
            return {
                schema: {
                    name: db.name,
                    tables: tables.map(function (table) { return trans.objectStore(table); }).map(function (store) {
                        var keyPath = store.keyPath, autoIncrement = store.autoIncrement;
                        var compound = isArray(keyPath);
                        var outbound = keyPath == null;
                        var indexByKeyPath = {};
                        var result = {
                            name: store.name,
                            primaryKey: {
                                name: null,
                                isPrimaryKey: true,
                                outbound: outbound,
                                compound: compound,
                                keyPath: keyPath,
                                autoIncrement: autoIncrement,
                                unique: true,
                                extractKey: getKeyExtractor(keyPath)
                            },
                            indexes: arrayify(store.indexNames).map(function (indexName) { return store.index(indexName); })
                                .map(function (index) {
                                var name = index.name, unique = index.unique, multiEntry = index.multiEntry, keyPath = index.keyPath;
                                var compound = isArray(keyPath);
                                var result = {
                                    name: name,
                                    compound: compound,
                                    keyPath: keyPath,
                                    unique: unique,
                                    multiEntry: multiEntry,
                                    extractKey: getKeyExtractor(keyPath)
                                };
                                indexByKeyPath[getKeyPathAlias(keyPath)] = result;
                                return result;
                            }),
                            getIndexByKeyPath: function (keyPath) { return indexByKeyPath[getKeyPathAlias(keyPath)]; }
                        };
                        indexByKeyPath[":id"] = result.primaryKey;
                        if (keyPath != null) {
                            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
                        }
                        return result;
                    })
                },
                hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&
                    !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
                        !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
                        [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
            };
        }
        function makeIDBKeyRange(range) {
            if (range.type === 3 )
                return null;
            if (range.type === 4 )
                throw new Error("Cannot convert never type to IDBKeyRange");
            var lower = range.lower, upper = range.upper, lowerOpen = range.lowerOpen, upperOpen = range.upperOpen;
            var idbRange = lower === undefined ?
                upper === undefined ?
                    null :
                    IdbKeyRange.upperBound(upper, !!upperOpen) :
                upper === undefined ?
                    IdbKeyRange.lowerBound(lower, !!lowerOpen) :
                    IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
            return idbRange;
        }
        function createDbCoreTable(tableSchema) {
            var tableName = tableSchema.name;
            function mutate(_a) {
                var trans = _a.trans, type = _a.type, keys = _a.keys, values = _a.values, range = _a.range;
                return new Promise(function (resolve, reject) {
                    resolve = wrap(resolve);
                    var store = trans.objectStore(tableName);
                    var outbound = store.keyPath == null;
                    var isAddOrPut = type === "put" || type === "add";
                    if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')
                        throw new Error("Invalid operation type: " + type);
                    var length = (keys || values || { length: 1 }).length;
                    if (keys && values && keys.length !== values.length) {
                        throw new Error("Given keys array must have same length as given values array.");
                    }
                    if (length === 0)
                        return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });
                    var req;
                    var reqs = [];
                    var failures = [];
                    var numFailures = 0;
                    var errorHandler = function (event) {
                        ++numFailures;
                        preventDefault(event);
                    };
                    if (type === 'deleteRange') {
                        if (range.type === 4 )
                            return resolve({ numFailures: numFailures, failures: failures, results: [], lastResult: undefined });
                        if (range.type === 3 )
                            reqs.push(req = store.clear());
                        else
                            reqs.push(req = store.delete(makeIDBKeyRange(range)));
                    }
                    else {
                        var _a = isAddOrPut ?
                            outbound ?
                                [values, keys] :
                                [values, null] :
                            [keys, null], args1 = _a[0], args2 = _a[1];
                        if (isAddOrPut) {
                            for (var i = 0; i < length; ++i) {
                                reqs.push(req = (args2 && args2[i] !== undefined ?
                                    store[type](args1[i], args2[i]) :
                                    store[type](args1[i])));
                                req.onerror = errorHandler;
                            }
                        }
                        else {
                            for (var i = 0; i < length; ++i) {
                                reqs.push(req = store[type](args1[i]));
                                req.onerror = errorHandler;
                            }
                        }
                    }
                    var done = function (event) {
                        var lastResult = event.target.result;
                        reqs.forEach(function (req, i) { return req.error != null && (failures[i] = req.error); });
                        resolve({
                            numFailures: numFailures,
                            failures: failures,
                            results: type === "delete" ? keys : reqs.map(function (req) { return req.result; }),
                            lastResult: lastResult
                        });
                    };
                    req.onerror = function (event) {
                        errorHandler(event);
                        done(event);
                    };
                    req.onsuccess = done;
                });
            }
            function openCursor(_a) {
                var trans = _a.trans, values = _a.values, query = _a.query, reverse = _a.reverse, unique = _a.unique;
                return new Promise(function (resolve, reject) {
                    resolve = wrap(resolve);
                    var index = query.index, range = query.range;
                    var store = trans.objectStore(tableName);
                    var source = index.isPrimaryKey ?
                        store :
                        store.index(index.name);
                    var direction = reverse ?
                        unique ?
                            "prevunique" :
                            "prev" :
                        unique ?
                            "nextunique" :
                            "next";
                    var req = values || !('openKeyCursor' in source) ?
                        source.openCursor(makeIDBKeyRange(range), direction) :
                        source.openKeyCursor(makeIDBKeyRange(range), direction);
                    req.onerror = eventRejectHandler(reject);
                    req.onsuccess = wrap(function (ev) {
                        var cursor = req.result;
                        if (!cursor) {
                            resolve(null);
                            return;
                        }
                        cursor.___id = ++_id_counter;
                        cursor.done = false;
                        var _cursorContinue = cursor.continue.bind(cursor);
                        var _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
                        if (_cursorContinuePrimaryKey)
                            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
                        var _cursorAdvance = cursor.advance.bind(cursor);
                        var doThrowCursorIsNotStarted = function () { throw new Error("Cursor not started"); };
                        var doThrowCursorIsStopped = function () { throw new Error("Cursor not stopped"); };
                        cursor.trans = trans;
                        cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
                        cursor.fail = wrap(reject);
                        cursor.next = function () {
                            var _this = this;
                            var gotOne = 1;
                            return this.start(function () { return gotOne-- ? _this.continue() : _this.stop(); }).then(function () { return _this; });
                        };
                        cursor.start = function (callback) {
                            var iterationPromise = new Promise(function (resolveIteration, rejectIteration) {
                                resolveIteration = wrap(resolveIteration);
                                req.onerror = eventRejectHandler(rejectIteration);
                                cursor.fail = rejectIteration;
                                cursor.stop = function (value) {
                                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                                    resolveIteration(value);
                                };
                            });
                            var guardedCallback = function () {
                                if (req.result) {
                                    try {
                                        callback();
                                    }
                                    catch (err) {
                                        cursor.fail(err);
                                    }
                                }
                                else {
                                    cursor.done = true;
                                    cursor.start = function () { throw new Error("Cursor behind last entry"); };
                                    cursor.stop();
                                }
                            };
                            req.onsuccess = wrap(function (ev) {
                                req.onsuccess = guardedCallback;
                                guardedCallback();
                            });
                            cursor.continue = _cursorContinue;
                            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
                            cursor.advance = _cursorAdvance;
                            guardedCallback();
                            return iterationPromise;
                        };
                        resolve(cursor);
                    }, reject);
                });
            }
            function query(hasGetAll) {
                return function (request) {
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var trans = request.trans, values = request.values, limit = request.limit, query = request.query;
                        var nonInfinitLimit = limit === Infinity ? undefined : limit;
                        var index = query.index, range = query.range;
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        if (limit === 0)
                            return resolve({ result: [] });
                        if (hasGetAll) {
                            var req = values ?
                                source.getAll(idbKeyRange, nonInfinitLimit) :
                                source.getAllKeys(idbKeyRange, nonInfinitLimit);
                            req.onsuccess = function (event) { return resolve({ result: event.target.result }); };
                            req.onerror = eventRejectHandler(reject);
                        }
                        else {
                            var count_1 = 0;
                            var req_1 = values || !('openKeyCursor' in source) ?
                                source.openCursor(idbKeyRange) :
                                source.openKeyCursor(idbKeyRange);
                            var result_1 = [];
                            req_1.onsuccess = function (event) {
                                var cursor = req_1.result;
                                if (!cursor)
                                    return resolve({ result: result_1 });
                                result_1.push(values ? cursor.value : cursor.primaryKey);
                                if (++count_1 === limit)
                                    return resolve({ result: result_1 });
                                cursor.continue();
                            };
                            req_1.onerror = eventRejectHandler(reject);
                        }
                    });
                };
            }
            return {
                name: tableName,
                schema: tableSchema,
                mutate: mutate,
                getMany: function (_a) {
                    var trans = _a.trans, keys = _a.keys;
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var length = keys.length;
                        var result = new Array(length);
                        var keyCount = 0;
                        var callbackCount = 0;
                        var req;
                        var successHandler = function (event) {
                            var req = event.target;
                            if ((result[req._pos] = req.result) != null)
                                ;
                            if (++callbackCount === keyCount)
                                resolve(result);
                        };
                        var errorHandler = eventRejectHandler(reject);
                        for (var i = 0; i < length; ++i) {
                            var key = keys[i];
                            if (key != null) {
                                req = store.get(keys[i]);
                                req._pos = i;
                                req.onsuccess = successHandler;
                                req.onerror = errorHandler;
                                ++keyCount;
                            }
                        }
                        if (keyCount === 0)
                            resolve(result);
                    });
                },
                get: function (_a) {
                    var trans = _a.trans, key = _a.key;
                    return new Promise(function (resolve, reject) {
                        resolve = wrap(resolve);
                        var store = trans.objectStore(tableName);
                        var req = store.get(key);
                        req.onsuccess = function (event) { return resolve(event.target.result); };
                        req.onerror = eventRejectHandler(reject);
                    });
                },
                query: query(hasGetAll),
                openCursor: openCursor,
                count: function (_a) {
                    var query = _a.query, trans = _a.trans;
                    var index = query.index, range = query.range;
                    return new Promise(function (resolve, reject) {
                        var store = trans.objectStore(tableName);
                        var source = index.isPrimaryKey ? store : store.index(index.name);
                        var idbKeyRange = makeIDBKeyRange(range);
                        var req = idbKeyRange ? source.count(idbKeyRange) : source.count();
                        req.onsuccess = wrap(function (ev) { return resolve(ev.target.result); });
                        req.onerror = eventRejectHandler(reject);
                    });
                }
            };
        }
        var _a = extractSchema(db, tmpTrans), schema = _a.schema, hasGetAll = _a.hasGetAll;
        var tables = schema.tables.map(function (tableSchema) { return createDbCoreTable(tableSchema); });
        var tableMap = {};
        tables.forEach(function (table) { return tableMap[table.name] = table; });
        return {
            stack: "dbcore",
            transaction: db.transaction.bind(db),
            table: function (name) {
                var result = tableMap[name];
                if (!result)
                    throw new Error("Table '".concat(name, "' not found"));
                return tableMap[name];
            },
            MIN_KEY: -Infinity,
            MAX_KEY: getMaxKey(IdbKeyRange),
            schema: schema
        };
    }

    function createMiddlewareStack(stackImpl, middlewares) {
        return middlewares.reduce(function (down, _a) {
            var create = _a.create;
            return (__assign(__assign({}, down), create(down)));
        }, stackImpl);
    }
    function createMiddlewareStacks(middlewares, idbdb, _a, tmpTrans) {
        var IDBKeyRange = _a.IDBKeyRange; _a.indexedDB;
        var dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);
        return {
            dbcore: dbcore
        };
    }
    function generateMiddlewareStacks(db, tmpTrans) {
        var idbdb = tmpTrans.db;
        var stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
        db.core = stacks.dbcore;
        db.tables.forEach(function (table) {
            var tableName = table.name;
            if (db.core.schema.tables.some(function (tbl) { return tbl.name === tableName; })) {
                table.core = db.core.table(tableName);
                if (db[tableName] instanceof db.Table) {
                    db[tableName].core = table.core;
                }
            }
        });
    }

    function setApiOnPlace(db, objs, tableNames, dbschema) {
        tableNames.forEach(function (tableName) {
            var schema = dbschema[tableName];
            objs.forEach(function (obj) {
                var propDesc = getPropertyDescriptor(obj, tableName);
                if (!propDesc || ("value" in propDesc && propDesc.value === undefined)) {
                    if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
                        setProp(obj, tableName, {
                            get: function () { return this.table(tableName); },
                            set: function (value) {
                                defineProperty(this, tableName, { value: value, writable: true, configurable: true, enumerable: true });
                            }
                        });
                    }
                    else {
                        obj[tableName] = new db.Table(tableName, schema);
                    }
                }
            });
        });
    }
    function removeTablesApi(db, objs) {
        objs.forEach(function (obj) {
            for (var key in obj) {
                if (obj[key] instanceof db.Table)
                    delete obj[key];
            }
        });
    }
    function lowerVersionFirst(a, b) {
        return a._cfg.version - b._cfg.version;
    }
    function runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {
        var globalSchema = db._dbSchema;
        if (idbUpgradeTrans.objectStoreNames.contains('$meta') && !globalSchema.$meta) {
            globalSchema.$meta = createTableSchema("$meta", parseIndexSyntax("")[0], []);
            db._storeNames.push('$meta');
        }
        var trans = db._createTransaction('readwrite', db._storeNames, globalSchema);
        trans.create(idbUpgradeTrans);
        trans._completion.catch(reject);
        var rejectTransaction = trans._reject.bind(trans);
        var transless = PSD.transless || PSD;
        newScope(function () {
            PSD.trans = trans;
            PSD.transless = transless;
            if (oldVersion === 0) {
                keys(globalSchema).forEach(function (tableName) {
                    createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
                });
                generateMiddlewareStacks(db, idbUpgradeTrans);
                DexiePromise.follow(function () { return db.on.populate.fire(trans); }).catch(rejectTransaction);
            }
            else {
                generateMiddlewareStacks(db, idbUpgradeTrans);
                return getExistingVersion(db, trans, oldVersion)
                    .then(function (oldVersion) { return updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans); })
                    .catch(rejectTransaction);
            }
        });
    }
    function patchCurrentVersion(db, idbUpgradeTrans) {
        createMissingTables(db._dbSchema, idbUpgradeTrans);
        if (idbUpgradeTrans.db.version % 10 === 0 && !idbUpgradeTrans.objectStoreNames.contains('$meta')) {
            idbUpgradeTrans.db.createObjectStore('$meta').add(Math.ceil((idbUpgradeTrans.db.version / 10) - 1), 'version');
        }
        var globalSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        adjustToExistingIndexNames(db, db._dbSchema, idbUpgradeTrans);
        var diff = getSchemaDiff(globalSchema, db._dbSchema);
        var _loop_1 = function (tableChange) {
            if (tableChange.change.length || tableChange.recreate) {
                console.warn("Unable to patch indexes of table ".concat(tableChange.name, " because it has changes on the type of index or primary key."));
                return { value: void 0 };
            }
            var store = idbUpgradeTrans.objectStore(tableChange.name);
            tableChange.add.forEach(function (idx) {
                if (debug)
                    console.debug("Dexie upgrade patch: Creating missing index ".concat(tableChange.name, ".").concat(idx.src));
                addIndex(store, idx);
            });
        };
        for (var _i = 0, _a = diff.change; _i < _a.length; _i++) {
            var tableChange = _a[_i];
            var state_1 = _loop_1(tableChange);
            if (typeof state_1 === "object")
                return state_1.value;
        }
    }
    function getExistingVersion(db, trans, oldVersion) {
        if (trans.storeNames.includes('$meta')) {
            return trans.table('$meta').get('version').then(function (metaVersion) {
                return metaVersion != null ? metaVersion : oldVersion;
            });
        }
        else {
            return DexiePromise.resolve(oldVersion);
        }
    }
    function updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans) {
        var queue = [];
        var versions = db._versions;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
        var versToRun = versions.filter(function (v) { return v._cfg.version >= oldVersion; });
        if (versToRun.length === 0) {
            return DexiePromise.resolve();
        }
        versToRun.forEach(function (version) {
            queue.push(function () {
                var oldSchema = globalSchema;
                var newSchema = version._cfg.dbschema;
                adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
                adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
                globalSchema = db._dbSchema = newSchema;
                var diff = getSchemaDiff(oldSchema, newSchema);
                diff.add.forEach(function (tuple) {
                    createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
                });
                diff.change.forEach(function (change) {
                    if (change.recreate) {
                        throw new exceptions.Upgrade("Not yet support for changing primary key");
                    }
                    else {
                        var store_1 = idbUpgradeTrans.objectStore(change.name);
                        change.add.forEach(function (idx) { return addIndex(store_1, idx); });
                        change.change.forEach(function (idx) {
                            store_1.deleteIndex(idx.name);
                            addIndex(store_1, idx);
                        });
                        change.del.forEach(function (idxName) { return store_1.deleteIndex(idxName); });
                    }
                });
                var contentUpgrade = version._cfg.contentUpgrade;
                if (contentUpgrade && version._cfg.version > oldVersion) {
                    generateMiddlewareStacks(db, idbUpgradeTrans);
                    trans._memoizedTables = {};
                    var upgradeSchema_1 = shallowClone(newSchema);
                    diff.del.forEach(function (table) {
                        upgradeSchema_1[table] = oldSchema[table];
                    });
                    removeTablesApi(db, [db.Transaction.prototype]);
                    setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema_1), upgradeSchema_1);
                    trans.schema = upgradeSchema_1;
                    var contentUpgradeIsAsync_1 = isAsyncFunction(contentUpgrade);
                    if (contentUpgradeIsAsync_1) {
                        incrementExpectedAwaits();
                    }
                    var returnValue_1;
                    var promiseFollowed = DexiePromise.follow(function () {
                        returnValue_1 = contentUpgrade(trans);
                        if (returnValue_1) {
                            if (contentUpgradeIsAsync_1) {
                                var decrementor = decrementExpectedAwaits.bind(null, null);
                                returnValue_1.then(decrementor, decrementor);
                            }
                        }
                    });
                    return (returnValue_1 && typeof returnValue_1.then === 'function' ?
                        DexiePromise.resolve(returnValue_1) : promiseFollowed.then(function () { return returnValue_1; }));
                }
            });
            queue.push(function (idbtrans) {
                var newSchema = version._cfg.dbschema;
                deleteRemovedTables(newSchema, idbtrans);
                removeTablesApi(db, [db.Transaction.prototype]);
                setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
                trans.schema = db._dbSchema;
            });
            queue.push(function (idbtrans) {
                if (db.idbdb.objectStoreNames.contains('$meta')) {
                    if (Math.ceil(db.idbdb.version / 10) === version._cfg.version) {
                        db.idbdb.deleteObjectStore('$meta');
                        delete db._dbSchema.$meta;
                        db._storeNames = db._storeNames.filter(function (name) { return name !== '$meta'; });
                    }
                    else {
                        idbtrans.objectStore('$meta').put(version._cfg.version, 'version');
                    }
                }
            });
        });
        function runQueue() {
            return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :
                DexiePromise.resolve();
        }
        return runQueue().then(function () {
            createMissingTables(globalSchema, idbUpgradeTrans);
        });
    }
    function getSchemaDiff(oldSchema, newSchema) {
        var diff = {
            del: [],
            add: [],
            change: []
        };
        var table;
        for (table in oldSchema) {
            if (!newSchema[table])
                diff.del.push(table);
        }
        for (table in newSchema) {
            var oldDef = oldSchema[table], newDef = newSchema[table];
            if (!oldDef) {
                diff.add.push([table, newDef]);
            }
            else {
                var change = {
                    name: table,
                    def: newDef,
                    recreate: false,
                    del: [],
                    add: [],
                    change: []
                };
                if ((
                '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||
                    (oldDef.primKey.auto !== newDef.primKey.auto)) {
                    change.recreate = true;
                    diff.change.push(change);
                }
                else {
                    var oldIndexes = oldDef.idxByName;
                    var newIndexes = newDef.idxByName;
                    var idxName = void 0;
                    for (idxName in oldIndexes) {
                        if (!newIndexes[idxName])
                            change.del.push(idxName);
                    }
                    for (idxName in newIndexes) {
                        var oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
                        if (!oldIdx)
                            change.add.push(newIdx);
                        else if (oldIdx.src !== newIdx.src)
                            change.change.push(newIdx);
                    }
                    if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
                        diff.change.push(change);
                    }
                }
            }
        }
        return diff;
    }
    function createTable(idbtrans, tableName, primKey, indexes) {
        var store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?
            { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :
            { autoIncrement: primKey.auto });
        indexes.forEach(function (idx) { return addIndex(store, idx); });
        return store;
    }
    function createMissingTables(newSchema, idbtrans) {
        keys(newSchema).forEach(function (tableName) {
            if (!idbtrans.db.objectStoreNames.contains(tableName)) {
                if (debug)
                    console.debug('Dexie: Creating missing table', tableName);
                createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
            }
        });
    }
    function deleteRemovedTables(newSchema, idbtrans) {
        [].slice.call(idbtrans.db.objectStoreNames).forEach(function (storeName) {
            return newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName);
        });
    }
    function addIndex(store, idx) {
        store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
    }
    function buildGlobalSchema(db, idbdb, tmpTrans) {
        var globalSchema = {};
        var dbStoreNames = slice(idbdb.objectStoreNames, 0);
        dbStoreNames.forEach(function (storeName) {
            var store = tmpTrans.objectStore(storeName);
            var keyPath = store.keyPath;
            var primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", true, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
            var indexes = [];
            for (var j = 0; j < store.indexNames.length; ++j) {
                var idbindex = store.index(store.indexNames[j]);
                keyPath = idbindex.keyPath;
                var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
                indexes.push(index);
            }
            globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
        });
        return globalSchema;
    }
    function readGlobalSchema(db, idbdb, tmpTrans) {
        db.verno = idbdb.version / 10;
        var globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
        db._storeNames = slice(idbdb.objectStoreNames, 0);
        setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);
    }
    function verifyInstalledSchema(db, tmpTrans) {
        var installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
        var diff = getSchemaDiff(installedSchema, db._dbSchema);
        return !(diff.add.length || diff.change.some(function (ch) { return ch.add.length || ch.change.length; }));
    }
    function adjustToExistingIndexNames(db, schema, idbtrans) {
        var storeNames = idbtrans.db.objectStoreNames;
        for (var i = 0; i < storeNames.length; ++i) {
            var storeName = storeNames[i];
            var store = idbtrans.objectStore(storeName);
            db._hasGetAll = 'getAll' in store;
            for (var j = 0; j < store.indexNames.length; ++j) {
                var indexName = store.indexNames[j];
                var keyPath = store.index(indexName).keyPath;
                var dexieName = typeof keyPath === 'string' ? keyPath : "[" + slice(keyPath).join('+') + "]";
                if (schema[storeName]) {
                    var indexSpec = schema[storeName].idxByName[dexieName];
                    if (indexSpec) {
                        indexSpec.name = indexName;
                        delete schema[storeName].idxByName[dexieName];
                        schema[storeName].idxByName[indexName] = indexSpec;
                    }
                }
            }
        }
        if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&
            !/(Chrome\/|Edge\/)/.test(navigator.userAgent) &&
            _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&
            [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
            db._hasGetAll = false;
        }
    }
    function parseIndexSyntax(primKeyAndIndexes) {
        return primKeyAndIndexes.split(',').map(function (index, indexNum) {
            var _a;
            var typeSplit = index.split(':');
            var type = (_a = typeSplit[1]) === null || _a === void 0 ? void 0 : _a.trim();
            index = typeSplit[0].trim();
            var name = index.replace(/([&*]|\+\+)/g, "");
            var keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split('+') : name;
            return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray(keyPath), indexNum === 0, type);
        });
    }

    var Version =  (function () {
        function Version() {
        }
        Version.prototype._createTableSchema = function (name, primKey, indexes) {
            return createTableSchema(name, primKey, indexes);
        };
        Version.prototype._parseIndexSyntax = function (primKeyAndIndexes) {
            return parseIndexSyntax(primKeyAndIndexes);
        };
        Version.prototype._parseStoresSpec = function (stores, outSchema) {
            var _this = this;
            keys(stores).forEach(function (tableName) {
                if (stores[tableName] !== null) {
                    var indexes = _this._parseIndexSyntax(stores[tableName]);
                    var primKey = indexes.shift();
                    if (!primKey) {
                        throw new exceptions.Schema('Invalid schema for table ' + tableName + ': ' + stores[tableName]);
                    }
                    primKey.unique = true;
                    if (primKey.multi)
                        throw new exceptions.Schema('Primary key cannot be multiEntry*');
                    indexes.forEach(function (idx) {
                        if (idx.auto)
                            throw new exceptions.Schema('Only primary key can be marked as autoIncrement (++)');
                        if (!idx.keyPath)
                            throw new exceptions.Schema('Index must have a name and cannot be an empty string');
                    });
                    var tblSchema = _this._createTableSchema(tableName, primKey, indexes);
                    outSchema[tableName] = tblSchema;
                }
            });
        };
        Version.prototype.stores = function (stores) {
            var db = this.db;
            this._cfg.storesSource = this._cfg.storesSource
                ? extend(this._cfg.storesSource, stores)
                : stores;
            var versions = db._versions;
            var storesSpec = {};
            var dbschema = {};
            versions.forEach(function (version) {
                extend(storesSpec, version._cfg.storesSource);
                dbschema = version._cfg.dbschema = {};
                version._parseStoresSpec(storesSpec, dbschema);
            });
            db._dbSchema = dbschema;
            removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
            setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);
            db._storeNames = keys(dbschema);
            return this;
        };
        Version.prototype.upgrade = function (upgradeFunction) {
            this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);
            return this;
        };
        return Version;
    }());

    function createVersionConstructor(db) {
        return makeClassConstructor(Version.prototype, function Version(versionNumber) {
            this.db = db;
            this._cfg = {
                version: versionNumber,
                storesSource: null,
                dbschema: {},
                tables: {},
                contentUpgrade: null
            };
        });
    }

    function getDbNamesTable(indexedDB, IDBKeyRange) {
        var dbNamesDB = indexedDB["_dbNamesDB"];
        if (!dbNamesDB) {
            dbNamesDB = indexedDB["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
                addons: [],
                indexedDB: indexedDB,
                IDBKeyRange: IDBKeyRange,
            });
            dbNamesDB.version(1).stores({ dbnames: "name" });
        }
        return dbNamesDB.table("dbnames");
    }
    function hasDatabasesNative(indexedDB) {
        return indexedDB && typeof indexedDB.databases === "function";
    }
    function getDatabaseNames(_a) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        return hasDatabasesNative(indexedDB)
            ? Promise.resolve(indexedDB.databases()).then(function (infos) {
                return infos
                    .map(function (info) { return info.name; })
                    .filter(function (name) { return name !== DBNAMES_DB; });
            })
            : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();
    }
    function _onDatabaseCreated(_a, name) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        !hasDatabasesNative(indexedDB) &&
            name !== DBNAMES_DB &&
            getDbNamesTable(indexedDB, IDBKeyRange).put({ name: name }).catch(nop);
    }
    function _onDatabaseDeleted(_a, name) {
        var indexedDB = _a.indexedDB, IDBKeyRange = _a.IDBKeyRange;
        !hasDatabasesNative(indexedDB) &&
            name !== DBNAMES_DB &&
            getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);
    }

    function vip(fn) {
        return newScope(function () {
            PSD.letThrough = true;
            return fn();
        });
    }

    function idbReady() {
        var isSafari = !navigator.userAgentData &&
            /Safari\//.test(navigator.userAgent) &&
            !/Chrom(e|ium)\//.test(navigator.userAgent);
        if (!isSafari || !indexedDB.databases)
            return Promise.resolve();
        var intervalId;
        return new Promise(function (resolve) {
            var tryIdb = function () { return indexedDB.databases().finally(resolve); };
            intervalId = setInterval(tryIdb, 100);
            tryIdb();
        }).finally(function () { return clearInterval(intervalId); });
    }

    var _a;
    function isEmptyRange(node) {
        return !("from" in node);
    }
    var RangeSet = function (fromOrTree, to) {
        if (this) {
            extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
        }
        else {
            var rv = new RangeSet();
            if (fromOrTree && ("d" in fromOrTree)) {
                extend(rv, fromOrTree);
            }
            return rv;
        }
    };
    props(RangeSet.prototype, (_a = {
            add: function (rangeSet) {
                mergeRanges(this, rangeSet);
                return this;
            },
            addKey: function (key) {
                addRange(this, key, key);
                return this;
            },
            addKeys: function (keys) {
                var _this = this;
                keys.forEach(function (key) { return addRange(_this, key, key); });
                return this;
            },
            hasKey: function (key) {
                var node = getRangeSetIterator(this).next(key).value;
                return node && cmp(node.from, key) <= 0 && cmp(node.to, key) >= 0;
            }
        },
        _a[iteratorSymbol] = function () {
            return getRangeSetIterator(this);
        },
        _a));
    function addRange(target, from, to) {
        var diff = cmp(from, to);
        if (isNaN(diff))
            return;
        if (diff > 0)
            throw RangeError();
        if (isEmptyRange(target))
            return extend(target, { from: from, to: to, d: 1 });
        var left = target.l;
        var right = target.r;
        if (cmp(to, target.from) < 0) {
            left
                ? addRange(left, from, to)
                : (target.l = { from: from, to: to, d: 1, l: null, r: null });
            return rebalance(target);
        }
        if (cmp(from, target.to) > 0) {
            right
                ? addRange(right, from, to)
                : (target.r = { from: from, to: to, d: 1, l: null, r: null });
            return rebalance(target);
        }
        if (cmp(from, target.from) < 0) {
            target.from = from;
            target.l = null;
            target.d = right ? right.d + 1 : 1;
        }
        if (cmp(to, target.to) > 0) {
            target.to = to;
            target.r = null;
            target.d = target.l ? target.l.d + 1 : 1;
        }
        var rightWasCutOff = !target.r;
        if (left && !target.l) {
            mergeRanges(target, left);
        }
        if (right && rightWasCutOff) {
            mergeRanges(target, right);
        }
    }
    function mergeRanges(target, newSet) {
        function _addRangeSet(target, _a) {
            var from = _a.from, to = _a.to, l = _a.l, r = _a.r;
            addRange(target, from, to);
            if (l)
                _addRangeSet(target, l);
            if (r)
                _addRangeSet(target, r);
        }
        if (!isEmptyRange(newSet))
            _addRangeSet(target, newSet);
    }
    function rangesOverlap(rangeSet1, rangeSet2) {
        var i1 = getRangeSetIterator(rangeSet2);
        var nextResult1 = i1.next();
        if (nextResult1.done)
            return false;
        var a = nextResult1.value;
        var i2 = getRangeSetIterator(rangeSet1);
        var nextResult2 = i2.next(a.from);
        var b = nextResult2.value;
        while (!nextResult1.done && !nextResult2.done) {
            if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
                return true;
            cmp(a.from, b.from) < 0
                ? (a = (nextResult1 = i1.next(b.from)).value)
                : (b = (nextResult2 = i2.next(a.from)).value);
        }
        return false;
    }
    function getRangeSetIterator(node) {
        var state = isEmptyRange(node) ? null : { s: 0, n: node };
        return {
            next: function (key) {
                var keyProvided = arguments.length > 0;
                while (state) {
                    switch (state.s) {
                        case 0:
                            state.s = 1;
                            if (keyProvided) {
                                while (state.n.l && cmp(key, state.n.from) < 0)
                                    state = { up: state, n: state.n.l, s: 1 };
                            }
                            else {
                                while (state.n.l)
                                    state = { up: state, n: state.n.l, s: 1 };
                            }
                        case 1:
                            state.s = 2;
                            if (!keyProvided || cmp(key, state.n.to) <= 0)
                                return { value: state.n, done: false };
                        case 2:
                            if (state.n.r) {
                                state.s = 3;
                                state = { up: state, n: state.n.r, s: 0 };
                                continue;
                            }
                        case 3:
                            state = state.up;
                    }
                }
                return { done: true };
            },
        };
    }
    function rebalance(target) {
        var _a, _b;
        var diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
        var r = diff > 1 ? "r" : diff < -1 ? "l" : "";
        if (r) {
            var l = r === "r" ? "l" : "r";
            var rootClone = __assign({}, target);
            var oldRootRight = target[r];
            target.from = oldRootRight.from;
            target.to = oldRootRight.to;
            target[r] = oldRootRight[r];
            rootClone[r] = oldRootRight[l];
            target[l] = rootClone;
            rootClone.d = computeDepth(rootClone);
        }
        target.d = computeDepth(target);
    }
    function computeDepth(_a) {
        var r = _a.r, l = _a.l;
        return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;
    }

    function extendObservabilitySet(target, newSet) {
        keys(newSet).forEach(function (part) {
            if (target[part])
                mergeRanges(target[part], newSet[part]);
            else
                target[part] = cloneSimpleObjectTree(newSet[part]);
        });
        return target;
    }

    function obsSetsOverlap(os1, os2) {
        return os1.all || os2.all || Object.keys(os1).some(function (key) { return os2[key] && rangesOverlap(os2[key], os1[key]); });
    }

    var cache = {};

    var unsignaledParts = {};
    var isTaskEnqueued = false;
    function signalSubscribersLazily(part, optimistic) {
        extendObservabilitySet(unsignaledParts, part);
        if (!isTaskEnqueued) {
            isTaskEnqueued = true;
            setTimeout(function () {
                isTaskEnqueued = false;
                var parts = unsignaledParts;
                unsignaledParts = {};
                signalSubscribersNow(parts, false);
            }, 0);
        }
    }
    function signalSubscribersNow(updatedParts, deleteAffectedCacheEntries) {
        if (deleteAffectedCacheEntries === void 0) { deleteAffectedCacheEntries = false; }
        var queriesToSignal = new Set();
        if (updatedParts.all) {
            for (var _i = 0, _a = Object.values(cache); _i < _a.length; _i++) {
                var tblCache = _a[_i];
                collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
            }
        }
        else {
            for (var key in updatedParts) {
                var parts = /^idb\:\/\/(.*)\/(.*)\//.exec(key);
                if (parts) {
                    var dbName = parts[1], tableName = parts[2];
                    var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                    if (tblCache)
                        collectTableSubscribers(tblCache, updatedParts, queriesToSignal, deleteAffectedCacheEntries);
                }
            }
        }
        queriesToSignal.forEach(function (requery) { return requery(); });
    }
    function collectTableSubscribers(tblCache, updatedParts, outQueriesToSignal, deleteAffectedCacheEntries) {
        var updatedEntryLists = [];
        for (var _i = 0, _a = Object.entries(tblCache.queries.query); _i < _a.length; _i++) {
            var _b = _a[_i], indexName = _b[0], entries = _b[1];
            var filteredEntries = [];
            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
                var entry = entries_1[_c];
                if (obsSetsOverlap(updatedParts, entry.obsSet)) {
                    entry.subscribers.forEach(function (requery) { return outQueriesToSignal.add(requery); });
                }
                else if (deleteAffectedCacheEntries) {
                    filteredEntries.push(entry);
                }
            }
            if (deleteAffectedCacheEntries)
                updatedEntryLists.push([indexName, filteredEntries]);
        }
        if (deleteAffectedCacheEntries) {
            for (var _d = 0, updatedEntryLists_1 = updatedEntryLists; _d < updatedEntryLists_1.length; _d++) {
                var _e = updatedEntryLists_1[_d], indexName = _e[0], filteredEntries = _e[1];
                tblCache.queries.query[indexName] = filteredEntries;
            }
        }
    }

    function dexieOpen(db) {
        var state = db._state;
        var indexedDB = db._deps.indexedDB;
        if (state.isBeingOpened || db.idbdb)
            return state.dbReadyPromise.then(function () { return state.dbOpenError ?
                rejection(state.dbOpenError) :
                db; });
        state.isBeingOpened = true;
        state.dbOpenError = null;
        state.openComplete = false;
        var openCanceller = state.openCanceller;
        var nativeVerToOpen = Math.round(db.verno * 10);
        var schemaPatchMode = false;
        function throwIfCancelled() {
            if (state.openCanceller !== openCanceller)
                throw new exceptions.DatabaseClosed('db.open() was cancelled');
        }
        var resolveDbReady = state.dbReadyResolve,
        upgradeTransaction = null, wasCreated = false;
        var tryOpenDB = function () { return new DexiePromise(function (resolve, reject) {
            throwIfCancelled();
            if (!indexedDB)
                throw new exceptions.MissingAPI();
            var dbName = db.name;
            var req = state.autoSchema || !nativeVerToOpen ?
                indexedDB.open(dbName) :
                indexedDB.open(dbName, nativeVerToOpen);
            if (!req)
                throw new exceptions.MissingAPI();
            req.onerror = eventRejectHandler(reject);
            req.onblocked = wrap(db._fireOnBlocked);
            req.onupgradeneeded = wrap(function (e) {
                upgradeTransaction = req.transaction;
                if (state.autoSchema && !db._options.allowEmptyDB) {
                    req.onerror = preventDefault;
                    upgradeTransaction.abort();
                    req.result.close();
                    var delreq = indexedDB.deleteDatabase(dbName);
                    delreq.onsuccess = delreq.onerror = wrap(function () {
                        reject(new exceptions.NoSuchDatabase("Database ".concat(dbName, " doesnt exist")));
                    });
                }
                else {
                    upgradeTransaction.onerror = eventRejectHandler(reject);
                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
                    wasCreated = oldVer < 1;
                    db.idbdb = req.result;
                    if (schemaPatchMode) {
                        patchCurrentVersion(db, upgradeTransaction);
                    }
                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);
                }
            }, reject);
            req.onsuccess = wrap(function () {
                upgradeTransaction = null;
                var idbdb = db.idbdb = req.result;
                var objectStoreNames = slice(idbdb.objectStoreNames);
                if (objectStoreNames.length > 0)
                    try {
                        var tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');
                        if (state.autoSchema)
                            readGlobalSchema(db, idbdb, tmpTrans);
                        else {
                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
                            if (!verifyInstalledSchema(db, tmpTrans) && !schemaPatchMode) {
                                console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this.");
                                idbdb.close();
                                nativeVerToOpen = idbdb.version + 1;
                                schemaPatchMode = true;
                                return resolve(tryOpenDB());
                            }
                        }
                        generateMiddlewareStacks(db, tmpTrans);
                    }
                    catch (e) {
                    }
                connections.push(db);
                idbdb.onversionchange = wrap(function (ev) {
                    state.vcFired = true;
                    db.on("versionchange").fire(ev);
                });
                idbdb.onclose = wrap(function (ev) {
                    db.on("close").fire(ev);
                });
                if (wasCreated)
                    _onDatabaseCreated(db._deps, dbName);
                resolve();
            }, reject);
        }).catch(function (err) {
            switch (err === null || err === void 0 ? void 0 : err.name) {
                case "UnknownError":
                    if (state.PR1398_maxLoop > 0) {
                        state.PR1398_maxLoop--;
                        console.warn('Dexie: Workaround for Chrome UnknownError on open()');
                        return tryOpenDB();
                    }
                    break;
                case "VersionError":
                    if (nativeVerToOpen > 0) {
                        nativeVerToOpen = 0;
                        return tryOpenDB();
                    }
                    break;
            }
            return DexiePromise.reject(err);
        }); };
        return DexiePromise.race([
            openCanceller,
            (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
        ]).then(function () {
            throwIfCancelled();
            state.onReadyBeingFired = [];
            return DexiePromise.resolve(vip(function () { return db.on.ready.fire(db.vip); })).then(function fireRemainders() {
                if (state.onReadyBeingFired.length > 0) {
                    var remainders_1 = state.onReadyBeingFired.reduce(promisableChain, nop);
                    state.onReadyBeingFired = [];
                    return DexiePromise.resolve(vip(function () { return remainders_1(db.vip); })).then(fireRemainders);
                }
            });
        }).finally(function () {
            if (state.openCanceller === openCanceller) {
                state.onReadyBeingFired = null;
                state.isBeingOpened = false;
            }
        }).catch(function (err) {
            state.dbOpenError = err;
            try {
                upgradeTransaction && upgradeTransaction.abort();
            }
            catch (_a) { }
            if (openCanceller === state.openCanceller) {
                db._close();
            }
            return rejection(err);
        }).finally(function () {
            state.openComplete = true;
            resolveDbReady();
        }).then(function () {
            if (wasCreated) {
                var everything_1 = {};
                db.tables.forEach(function (table) {
                    table.schema.indexes.forEach(function (idx) {
                        if (idx.name)
                            everything_1["idb://".concat(db.name, "/").concat(table.name, "/").concat(idx.name)] = new RangeSet(-Infinity, [[[]]]);
                    });
                    everything_1["idb://".concat(db.name, "/").concat(table.name, "/")] = everything_1["idb://".concat(db.name, "/").concat(table.name, "/:dels")] = new RangeSet(-Infinity, [[[]]]);
                });
                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME).fire(everything_1);
                signalSubscribersNow(everything_1, true);
            }
            return db;
        });
    }

    function awaitIterator(iterator) {
        var callNext = function (result) { return iterator.next(result); }, doThrow = function (error) { return iterator.throw(error); }, onSuccess = step(callNext), onError = step(doThrow);
        function step(getNext) {
            return function (val) {
                var next = getNext(val), value = next.value;
                return next.done ? value :
                    (!value || typeof value.then !== 'function' ?
                        isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :
                        value.then(onSuccess, onError));
            };
        }
        return step(callNext)();
    }

    function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
        var i = arguments.length;
        if (i < 2)
            throw new exceptions.InvalidArgument("Too few arguments");
        var args = new Array(i - 1);
        while (--i)
            args[i - 1] = arguments[i];
        scopeFunc = args.pop();
        var tables = flatten(args);
        return [mode, tables, scopeFunc];
    }
    function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
        return DexiePromise.resolve().then(function () {
            var transless = PSD.transless || PSD;
            var trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
            trans.explicit = true;
            var zoneProps = {
                trans: trans,
                transless: transless
            };
            if (parentTransaction) {
                trans.idbtrans = parentTransaction.idbtrans;
            }
            else {
                try {
                    trans.create();
                    trans.idbtrans._explicit = true;
                    db._state.PR1398_maxLoop = 3;
                }
                catch (ex) {
                    if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
                        console.warn('Dexie: Need to reopen db');
                        db.close({ disableAutoOpen: false });
                        return db.open().then(function () { return enterTransactionScope(db, mode, storeNames, null, scopeFunc); });
                    }
                    return rejection(ex);
                }
            }
            var scopeFuncIsAsync = isAsyncFunction(scopeFunc);
            if (scopeFuncIsAsync) {
                incrementExpectedAwaits();
            }
            var returnValue;
            var promiseFollowed = DexiePromise.follow(function () {
                returnValue = scopeFunc.call(trans, trans);
                if (returnValue) {
                    if (scopeFuncIsAsync) {
                        var decrementor = decrementExpectedAwaits.bind(null, null);
                        returnValue.then(decrementor, decrementor);
                    }
                    else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {
                        returnValue = awaitIterator(returnValue);
                    }
                }
            }, zoneProps);
            return (returnValue && typeof returnValue.then === 'function' ?
                DexiePromise.resolve(returnValue).then(function (x) { return trans.active ?
                    x
                    : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn")); })
                : promiseFollowed.then(function () { return returnValue; })).then(function (x) {
                if (parentTransaction)
                    trans._resolve();
                return trans._completion.then(function () { return x; });
            }).catch(function (e) {
                trans._reject(e);
                return rejection(e);
            });
        });
    }

    function pad(a, value, count) {
        var result = isArray(a) ? a.slice() : [a];
        for (var i = 0; i < count; ++i)
            result.push(value);
        return result;
    }
    function createVirtualIndexMiddleware(down) {
        return __assign(__assign({}, down), { table: function (tableName) {
                var table = down.table(tableName);
                var schema = table.schema;
                var indexLookup = {};
                var allVirtualIndexes = [];
                function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
                    var keyPathAlias = getKeyPathAlias(keyPath);
                    var indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);
                    var keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;
                    var isVirtual = keyTail > 0;
                    var virtualIndex = __assign(__assign({}, lowLevelIndex), { name: isVirtual
                            ? "".concat(keyPathAlias, "(virtual-from:").concat(lowLevelIndex.name, ")")
                            : lowLevelIndex.name, lowLevelIndex: lowLevelIndex, isVirtual: isVirtual, keyTail: keyTail, keyLength: keyLength, extractKey: getKeyExtractor(keyPath), unique: !isVirtual && lowLevelIndex.unique });
                    indexList.push(virtualIndex);
                    if (!virtualIndex.isPrimaryKey) {
                        allVirtualIndexes.push(virtualIndex);
                    }
                    if (keyLength > 1) {
                        var virtualKeyPath = keyLength === 2 ?
                            keyPath[0] :
                            keyPath.slice(0, keyLength - 1);
                        addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
                    }
                    indexList.sort(function (a, b) { return a.keyTail - b.keyTail; });
                    return virtualIndex;
                }
                var primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
                indexLookup[":id"] = [primaryKey];
                for (var _i = 0, _a = schema.indexes; _i < _a.length; _i++) {
                    var index = _a[_i];
                    addVirtualIndexes(index.keyPath, 0, index);
                }
                function findBestIndex(keyPath) {
                    var result = indexLookup[getKeyPathAlias(keyPath)];
                    return result && result[0];
                }
                function translateRange(range, keyTail) {
                    return {
                        type: range.type === 1  ?
                            2  :
                            range.type,
                        lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
                        lowerOpen: true,
                        upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
                        upperOpen: true
                    };
                }
                function translateRequest(req) {
                    var index = req.query.index;
                    return index.isVirtual ? __assign(__assign({}, req), { query: {
                            index: index.lowLevelIndex,
                            range: translateRange(req.query.range, index.keyTail)
                        } }) : req;
                }
                var result = __assign(__assign({}, table), { schema: __assign(__assign({}, schema), { primaryKey: primaryKey, indexes: allVirtualIndexes, getIndexByKeyPath: findBestIndex }), count: function (req) {
                        return table.count(translateRequest(req));
                    }, query: function (req) {
                        return table.query(translateRequest(req));
                    }, openCursor: function (req) {
                        var _a = req.query.index, keyTail = _a.keyTail, isVirtual = _a.isVirtual, keyLength = _a.keyLength;
                        if (!isVirtual)
                            return table.openCursor(req);
                        function createVirtualCursor(cursor) {
                            function _continue(key) {
                                key != null ?
                                    cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :
                                    req.unique ?
                                        cursor.continue(cursor.key.slice(0, keyLength)
                                            .concat(req.reverse
                                            ? down.MIN_KEY
                                            : down.MAX_KEY, keyTail)) :
                                        cursor.continue();
                            }
                            var virtualCursor = Object.create(cursor, {
                                continue: { value: _continue },
                                continuePrimaryKey: {
                                    value: function (key, primaryKey) {
                                        cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);
                                    }
                                },
                                primaryKey: {
                                    get: function () {
                                        return cursor.primaryKey;
                                    }
                                },
                                key: {
                                    get: function () {
                                        var key = cursor.key;
                                        return keyLength === 1 ?
                                            key[0] :
                                            key.slice(0, keyLength);
                                    }
                                },
                                value: {
                                    get: function () {
                                        return cursor.value;
                                    }
                                }
                            });
                            return virtualCursor;
                        }
                        return table.openCursor(translateRequest(req))
                            .then(function (cursor) { return cursor && createVirtualCursor(cursor); });
                    } });
                return result;
            } });
    }
    var virtualIndexMiddleware = {
        stack: "dbcore",
        name: "VirtualIndexMiddleware",
        level: 1,
        create: createVirtualIndexMiddleware
    };

    function getObjectDiff(a, b, rv, prfx) {
        rv = rv || {};
        prfx = prfx || '';
        keys(a).forEach(function (prop) {
            if (!hasOwn(b, prop)) {
                rv[prfx + prop] = undefined;
            }
            else {
                var ap = a[prop], bp = b[prop];
                if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {
                    var apTypeName = toStringTag(ap);
                    var bpTypeName = toStringTag(bp);
                    if (apTypeName !== bpTypeName) {
                        rv[prfx + prop] = b[prop];
                    }
                    else if (apTypeName === 'Object') {
                        getObjectDiff(ap, bp, rv, prfx + prop + '.');
                    }
                    else if (ap !== bp) {
                        rv[prfx + prop] = b[prop];
                    }
                }
                else if (ap !== bp)
                    rv[prfx + prop] = b[prop];
            }
        });
        keys(b).forEach(function (prop) {
            if (!hasOwn(a, prop)) {
                rv[prfx + prop] = b[prop];
            }
        });
        return rv;
    }

    function getEffectiveKeys(primaryKey, req) {
        if (req.type === 'delete')
            return req.keys;
        return req.keys || req.values.map(primaryKey.extractKey);
    }

    var hooksMiddleware = {
        stack: "dbcore",
        name: "HooksMiddleware",
        level: 2,
        create: function (downCore) { return (__assign(__assign({}, downCore), { table: function (tableName) {
                var downTable = downCore.table(tableName);
                var primaryKey = downTable.schema.primaryKey;
                var tableMiddleware = __assign(__assign({}, downTable), { mutate: function (req) {
                        var dxTrans = PSD.trans;
                        var _a = dxTrans.table(tableName).hook, deleting = _a.deleting, creating = _a.creating, updating = _a.updating;
                        switch (req.type) {
                            case 'add':
                                if (creating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'put':
                                if (creating.fire === nop && updating.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'delete':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return addPutOrDelete(req); }, true);
                            case 'deleteRange':
                                if (deleting.fire === nop)
                                    break;
                                return dxTrans._promise('readwrite', function () { return deleteRange(req); }, true);
                        }
                        return downTable.mutate(req);
                        function addPutOrDelete(req) {
                            var dxTrans = PSD.trans;
                            var keys = req.keys || getEffectiveKeys(primaryKey, req);
                            if (!keys)
                                throw new Error("Keys missing");
                            req = req.type === 'add' || req.type === 'put' ? __assign(__assign({}, req), { keys: keys }) : __assign({}, req);
                            if (req.type !== 'delete')
                                req.values = __spreadArray([], req.values, true);
                            if (req.keys)
                                req.keys = __spreadArray([], req.keys, true);
                            return getExistingValues(downTable, req, keys).then(function (existingValues) {
                                var contexts = keys.map(function (key, i) {
                                    var existingValue = existingValues[i];
                                    var ctx = { onerror: null, onsuccess: null };
                                    if (req.type === 'delete') {
                                        deleting.fire.call(ctx, key, existingValue, dxTrans);
                                    }
                                    else if (req.type === 'add' || existingValue === undefined) {
                                        var generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);
                                        if (key == null && generatedPrimaryKey != null) {
                                            key = generatedPrimaryKey;
                                            req.keys[i] = key;
                                            if (!primaryKey.outbound) {
                                                setByKeyPath(req.values[i], primaryKey.keyPath, key);
                                            }
                                        }
                                    }
                                    else {
                                        var objectDiff = getObjectDiff(existingValue, req.values[i]);
                                        var additionalChanges_1 = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);
                                        if (additionalChanges_1) {
                                            var requestedValue_1 = req.values[i];
                                            Object.keys(additionalChanges_1).forEach(function (keyPath) {
                                                if (hasOwn(requestedValue_1, keyPath)) {
                                                    requestedValue_1[keyPath] = additionalChanges_1[keyPath];
                                                }
                                                else {
                                                    setByKeyPath(requestedValue_1, keyPath, additionalChanges_1[keyPath]);
                                                }
                                            });
                                        }
                                    }
                                    return ctx;
                                });
                                return downTable.mutate(req).then(function (_a) {
                                    var failures = _a.failures, results = _a.results, numFailures = _a.numFailures, lastResult = _a.lastResult;
                                    for (var i = 0; i < keys.length; ++i) {
                                        var primKey = results ? results[i] : keys[i];
                                        var ctx = contexts[i];
                                        if (primKey == null) {
                                            ctx.onerror && ctx.onerror(failures[i]);
                                        }
                                        else {
                                            ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?
                                                req.values[i] :
                                                primKey
                                            );
                                        }
                                    }
                                    return { failures: failures, results: results, numFailures: numFailures, lastResult: lastResult };
                                }).catch(function (error) {
                                    contexts.forEach(function (ctx) { return ctx.onerror && ctx.onerror(error); });
                                    return Promise.reject(error);
                                });
                            });
                        }
                        function deleteRange(req) {
                            return deleteNextChunk(req.trans, req.range, 10000);
                        }
                        function deleteNextChunk(trans, range, limit) {
                            return downTable.query({ trans: trans, values: false, query: { index: primaryKey, range: range }, limit: limit })
                                .then(function (_a) {
                                var result = _a.result;
                                return addPutOrDelete({ type: 'delete', keys: result, trans: trans }).then(function (res) {
                                    if (res.numFailures > 0)
                                        return Promise.reject(res.failures[0]);
                                    if (result.length < limit) {
                                        return { failures: [], numFailures: 0, lastResult: undefined };
                                    }
                                    else {
                                        return deleteNextChunk(trans, __assign(__assign({}, range), { lower: result[result.length - 1], lowerOpen: true }), limit);
                                    }
                                });
                            });
                        }
                    } });
                return tableMiddleware;
            } })); }
    };
    function getExistingValues(table, req, effectiveKeys) {
        return req.type === "add"
            ? Promise.resolve([])
            : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
    }

    function getFromTransactionCache(keys, cache, clone) {
        try {
            if (!cache)
                return null;
            if (cache.keys.length < keys.length)
                return null;
            var result = [];
            for (var i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {
                if (cmp(cache.keys[i], keys[j]) !== 0)
                    continue;
                result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
                ++j;
            }
            return result.length === keys.length ? result : null;
        }
        catch (_a) {
            return null;
        }
    }
    var cacheExistingValuesMiddleware = {
        stack: "dbcore",
        level: -1,
        create: function (core) {
            return {
                table: function (tableName) {
                    var table = core.table(tableName);
                    return __assign(__assign({}, table), { getMany: function (req) {
                            if (!req.cache) {
                                return table.getMany(req);
                            }
                            var cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
                            if (cachedResult) {
                                return DexiePromise.resolve(cachedResult);
                            }
                            return table.getMany(req).then(function (res) {
                                req.trans["_cache"] = {
                                    keys: req.keys,
                                    values: req.cache === "clone" ? deepClone(res) : res,
                                };
                                return res;
                            });
                        }, mutate: function (req) {
                            if (req.type !== "add")
                                req.trans["_cache"] = null;
                            return table.mutate(req);
                        } });
                },
            };
        },
    };

    function isCachableContext(ctx, table) {
        return (ctx.trans.mode === 'readonly' &&
            !!ctx.subscr &&
            !ctx.trans.explicit &&
            ctx.trans.db._options.cache !== 'disabled' &&
            !table.schema.primaryKey.outbound);
    }

    function isCachableRequest(type, req) {
        switch (type) {
            case 'query':
                return req.values && !req.unique;
            case 'get':
                return false;
            case 'getMany':
                return false;
            case 'count':
                return false;
            case 'openCursor':
                return false;
        }
    }

    var observabilityMiddleware = {
        stack: "dbcore",
        level: 0,
        name: "Observability",
        create: function (core) {
            var dbName = core.schema.name;
            var FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);
            return __assign(__assign({}, core), { transaction: function (stores, mode, options) {
                    if (PSD.subscr && mode !== 'readonly') {
                        throw new exceptions.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(PSD.querier));
                    }
                    return core.transaction(stores, mode, options);
                }, table: function (tableName) {
                    var table = core.table(tableName);
                    var schema = table.schema;
                    var primaryKey = schema.primaryKey, indexes = schema.indexes;
                    var extractKey = primaryKey.extractKey, outbound = primaryKey.outbound;
                    var indexesWithAutoIncPK = primaryKey.autoIncrement && indexes.filter(function (index) { return index.compound && index.keyPath.includes(primaryKey.keyPath); });
                    var tableClone = __assign(__assign({}, table), { mutate: function (req) {
                            var _a, _b;
                            var trans = req.trans;
                            var mutatedParts = req.mutatedParts || (req.mutatedParts = {});
                            var getRangeSet = function (indexName) {
                                var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                                return (mutatedParts[part] ||
                                    (mutatedParts[part] = new RangeSet()));
                            };
                            var pkRangeSet = getRangeSet("");
                            var delsRangeSet = getRangeSet(":dels");
                            var type = req.type;
                            var _c = req.type === "deleteRange"
                                ? [req.range]
                                : req.type === "delete"
                                    ? [req.keys]
                                    : req.values.length < 50
                                        ? [getEffectiveKeys(primaryKey, req).filter(function (id) { return id; }), req.values]
                                        : [], keys = _c[0], newObjs = _c[1];
                            var oldCache = req.trans["_cache"];
                            if (isArray(keys)) {
                                pkRangeSet.addKeys(keys);
                                var oldObjs = type === 'delete' || keys.length === newObjs.length ? getFromTransactionCache(keys, oldCache) : null;
                                if (!oldObjs) {
                                    delsRangeSet.addKeys(keys);
                                }
                                if (oldObjs || newObjs) {
                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                                }
                            }
                            else if (keys) {
                                var range = {
                                    from: (_a = keys.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY,
                                    to: (_b = keys.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY
                                };
                                delsRangeSet.add(range);
                                pkRangeSet.add(range);
                            }
                            else {
                                pkRangeSet.add(FULL_RANGE);
                                delsRangeSet.add(FULL_RANGE);
                                schema.indexes.forEach(function (idx) { return getRangeSet(idx.name).add(FULL_RANGE); });
                            }
                            return table.mutate(req).then(function (res) {
                                if (keys && (req.type === 'add' || req.type === 'put')) {
                                    pkRangeSet.addKeys(res.results);
                                    if (indexesWithAutoIncPK) {
                                        indexesWithAutoIncPK.forEach(function (idx) {
                                            var idxVals = req.values.map(function (v) { return idx.extractKey(v); });
                                            var pkPos = idx.keyPath.findIndex(function (prop) { return prop === primaryKey.keyPath; });
                                            for (var i = 0, len = res.results.length; i < len; ++i) {
                                                idxVals[i][pkPos] = res.results[i];
                                            }
                                            getRangeSet(idx.name).addKeys(idxVals);
                                        });
                                    }
                                }
                                trans.mutatedParts = extendObservabilitySet(trans.mutatedParts || {}, mutatedParts);
                                return res;
                            });
                        } });
                    var getRange = function (_a) {
                        var _b, _c;
                        var _d = _a.query, index = _d.index, range = _d.range;
                        return [
                            index,
                            new RangeSet((_b = range.lower) !== null && _b !== void 0 ? _b : core.MIN_KEY, (_c = range.upper) !== null && _c !== void 0 ? _c : core.MAX_KEY),
                        ];
                    };
                    var readSubscribers = {
                        get: function (req) { return [primaryKey, new RangeSet(req.key)]; },
                        getMany: function (req) { return [primaryKey, new RangeSet().addKeys(req.keys)]; },
                        count: getRange,
                        query: getRange,
                        openCursor: getRange,
                    };
                    keys(readSubscribers).forEach(function (method) {
                        tableClone[method] = function (req) {
                            var subscr = PSD.subscr;
                            var isLiveQuery = !!subscr;
                            var cachable = isCachableContext(PSD, table) && isCachableRequest(method, req);
                            var obsSet = cachable
                                ? req.obsSet = {}
                                : subscr;
                            if (isLiveQuery) {
                                var getRangeSet = function (indexName) {
                                    var part = "idb://".concat(dbName, "/").concat(tableName, "/").concat(indexName);
                                    return (obsSet[part] ||
                                        (obsSet[part] = new RangeSet()));
                                };
                                var pkRangeSet_1 = getRangeSet("");
                                var delsRangeSet_1 = getRangeSet(":dels");
                                var _a = readSubscribers[method](req), queriedIndex = _a[0], queriedRanges = _a[1];
                                if (method === 'query' && queriedIndex.isPrimaryKey && !req.values) {
                                    delsRangeSet_1.add(queriedRanges);
                                }
                                else {
                                    getRangeSet(queriedIndex.name || "").add(queriedRanges);
                                }
                                if (!queriedIndex.isPrimaryKey) {
                                    if (method === "count") {
                                        delsRangeSet_1.add(FULL_RANGE);
                                    }
                                    else {
                                        var keysPromise_1 = method === "query" &&
                                            outbound &&
                                            req.values &&
                                            table.query(__assign(__assign({}, req), { values: false }));
                                        return table[method].apply(this, arguments).then(function (res) {
                                            if (method === "query") {
                                                if (outbound && req.values) {
                                                    return keysPromise_1.then(function (_a) {
                                                        var resultingKeys = _a.result;
                                                        pkRangeSet_1.addKeys(resultingKeys);
                                                        return res;
                                                    });
                                                }
                                                var pKeys = req.values
                                                    ? res.result.map(extractKey)
                                                    : res.result;
                                                if (req.values) {
                                                    pkRangeSet_1.addKeys(pKeys);
                                                }
                                                else {
                                                    delsRangeSet_1.addKeys(pKeys);
                                                }
                                            }
                                            else if (method === "openCursor") {
                                                var cursor_1 = res;
                                                var wantValues_1 = req.values;
                                                return (cursor_1 &&
                                                    Object.create(cursor_1, {
                                                        key: {
                                                            get: function () {
                                                                delsRangeSet_1.addKey(cursor_1.primaryKey);
                                                                return cursor_1.key;
                                                            },
                                                        },
                                                        primaryKey: {
                                                            get: function () {
                                                                var pkey = cursor_1.primaryKey;
                                                                delsRangeSet_1.addKey(pkey);
                                                                return pkey;
                                                            },
                                                        },
                                                        value: {
                                                            get: function () {
                                                                wantValues_1 && pkRangeSet_1.addKey(cursor_1.primaryKey);
                                                                return cursor_1.value;
                                                            },
                                                        },
                                                    }));
                                            }
                                            return res;
                                        });
                                    }
                                }
                            }
                            return table[method].apply(this, arguments);
                        };
                    });
                    return tableClone;
                } });
        },
    };
    function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
        function addAffectedIndex(ix) {
            var rangeSet = getRangeSet(ix.name || "");
            function extractKey(obj) {
                return obj != null ? ix.extractKey(obj) : null;
            }
            var addKeyOrKeys = function (key) { return ix.multiEntry && isArray(key)
                ? key.forEach(function (key) { return rangeSet.addKey(key); })
                : rangeSet.addKey(key); };
            (oldObjs || newObjs).forEach(function (_, i) {
                var oldKey = oldObjs && extractKey(oldObjs[i]);
                var newKey = newObjs && extractKey(newObjs[i]);
                if (cmp(oldKey, newKey) !== 0) {
                    if (oldKey != null)
                        addKeyOrKeys(oldKey);
                    if (newKey != null)
                        addKeyOrKeys(newKey);
                }
            });
        }
        schema.indexes.forEach(addAffectedIndex);
    }

    function adjustOptimisticFromFailures(tblCache, req, res) {
        if (res.numFailures === 0)
            return req;
        if (req.type === 'deleteRange') {
            return null;
        }
        var numBulkOps = req.keys
            ? req.keys.length
            : 'values' in req && req.values
                ? req.values.length
                : 1;
        if (res.numFailures === numBulkOps) {
            return null;
        }
        var clone = __assign({}, req);
        if (isArray(clone.keys)) {
            clone.keys = clone.keys.filter(function (_, i) { return !(i in res.failures); });
        }
        if ('values' in clone && isArray(clone.values)) {
            clone.values = clone.values.filter(function (_, i) { return !(i in res.failures); });
        }
        return clone;
    }

    function isAboveLower(key, range) {
        return range.lower === undefined
            ? true
            : range.lowerOpen
                ? cmp(key, range.lower) > 0
                : cmp(key, range.lower) >= 0;
    }
    function isBelowUpper(key, range) {
        return range.upper === undefined
            ? true
            : range.upperOpen
                ? cmp(key, range.upper) < 0
                : cmp(key, range.upper) <= 0;
    }
    function isWithinRange(key, range) {
        return isAboveLower(key, range) && isBelowUpper(key, range);
    }

    function applyOptimisticOps(result, req, ops, table, cacheEntry, immutable) {
        if (!ops || ops.length === 0)
            return result;
        var index = req.query.index;
        var multiEntry = index.multiEntry;
        var queryRange = req.query.range;
        var primaryKey = table.schema.primaryKey;
        var extractPrimKey = primaryKey.extractKey;
        var extractIndex = index.extractKey;
        var extractLowLevelIndex = (index.lowLevelIndex || index).extractKey;
        var finalResult = ops.reduce(function (result, op) {
            var modifedResult = result;
            var includedValues = [];
            if (op.type === 'add' || op.type === 'put') {
                var includedPKs = new RangeSet();
                for (var i = op.values.length - 1; i >= 0; --i) {
                    var value = op.values[i];
                    var pk = extractPrimKey(value);
                    if (includedPKs.hasKey(pk))
                        continue;
                    var key = extractIndex(value);
                    if (multiEntry && isArray(key)
                        ? key.some(function (k) { return isWithinRange(k, queryRange); })
                        : isWithinRange(key, queryRange)) {
                        includedPKs.addKey(pk);
                        includedValues.push(value);
                    }
                }
            }
            switch (op.type) {
                case 'add': {
                    var existingKeys_1 = new RangeSet().addKeys(req.values ? result.map(function (v) { return extractPrimKey(v); }) : result);
                    modifedResult = result.concat(req.values
                        ? includedValues.filter(function (v) {
                            var key = extractPrimKey(v);
                            if (existingKeys_1.hasKey(key))
                                return false;
                            existingKeys_1.addKey(key);
                            return true;
                        })
                        : includedValues
                            .map(function (v) { return extractPrimKey(v); })
                            .filter(function (k) {
                            if (existingKeys_1.hasKey(k))
                                return false;
                            existingKeys_1.addKey(k);
                            return true;
                        }));
                    break;
                }
                case 'put': {
                    var keySet_1 = new RangeSet().addKeys(op.values.map(function (v) { return extractPrimKey(v); }));
                    modifedResult = result
                        .filter(
                    function (item) { return !keySet_1.hasKey(req.values ? extractPrimKey(item) : item); })
                        .concat(
                    req.values
                        ? includedValues
                        : includedValues.map(function (v) { return extractPrimKey(v); }));
                    break;
                }
                case 'delete':
                    var keysToDelete_1 = new RangeSet().addKeys(op.keys);
                    modifedResult = result.filter(function (item) {
                        return !keysToDelete_1.hasKey(req.values ? extractPrimKey(item) : item);
                    });
                    break;
                case 'deleteRange':
                    var range_1 = op.range;
                    modifedResult = result.filter(function (item) { return !isWithinRange(extractPrimKey(item), range_1); });
                    break;
            }
            return modifedResult;
        }, result);
        if (finalResult === result)
            return result;
        finalResult.sort(function (a, b) {
            return cmp(extractLowLevelIndex(a), extractLowLevelIndex(b)) ||
                cmp(extractPrimKey(a), extractPrimKey(b));
        });
        if (req.limit && req.limit < Infinity) {
            if (finalResult.length > req.limit) {
                finalResult.length = req.limit;
            }
            else if (result.length === req.limit && finalResult.length < req.limit) {
                cacheEntry.dirty = true;
            }
        }
        return immutable ? Object.freeze(finalResult) : finalResult;
    }

    function areRangesEqual(r1, r2) {
        return (cmp(r1.lower, r2.lower) === 0 &&
            cmp(r1.upper, r2.upper) === 0 &&
            !!r1.lowerOpen === !!r2.lowerOpen &&
            !!r1.upperOpen === !!r2.upperOpen);
    }

    function compareLowers(lower1, lower2, lowerOpen1, lowerOpen2) {
        if (lower1 === undefined)
            return lower2 !== undefined ? -1 : 0;
        if (lower2 === undefined)
            return 1;
        var c = cmp(lower1, lower2);
        if (c === 0) {
            if (lowerOpen1 && lowerOpen2)
                return 0;
            if (lowerOpen1)
                return 1;
            if (lowerOpen2)
                return -1;
        }
        return c;
    }
    function compareUppers(upper1, upper2, upperOpen1, upperOpen2) {
        if (upper1 === undefined)
            return upper2 !== undefined ? 1 : 0;
        if (upper2 === undefined)
            return -1;
        var c = cmp(upper1, upper2);
        if (c === 0) {
            if (upperOpen1 && upperOpen2)
                return 0;
            if (upperOpen1)
                return -1;
            if (upperOpen2)
                return 1;
        }
        return c;
    }
    function isSuperRange(r1, r2) {
        return (compareLowers(r1.lower, r2.lower, r1.lowerOpen, r2.lowerOpen) <= 0 &&
            compareUppers(r1.upper, r2.upper, r1.upperOpen, r2.upperOpen) >= 0);
    }

    function findCompatibleQuery(dbName, tableName, type, req) {
        var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
        if (!tblCache)
            return [];
        var queries = tblCache.queries[type];
        if (!queries)
            return [null, false, tblCache, null];
        var indexName = req.query ? req.query.index.name : null;
        var entries = queries[indexName || ''];
        if (!entries)
            return [null, false, tblCache, null];
        switch (type) {
            case 'query':
                var equalEntry = entries.find(function (entry) {
                    return entry.req.limit === req.limit &&
                        entry.req.values === req.values &&
                        areRangesEqual(entry.req.query.range, req.query.range);
                });
                if (equalEntry)
                    return [
                        equalEntry,
                        true,
                        tblCache,
                        entries,
                    ];
                var superEntry = entries.find(function (entry) {
                    var limit = 'limit' in entry.req ? entry.req.limit : Infinity;
                    return (limit >= req.limit &&
                        (req.values ? entry.req.values : true) &&
                        isSuperRange(entry.req.query.range, req.query.range));
                });
                return [superEntry, false, tblCache, entries];
            case 'count':
                var countQuery = entries.find(function (entry) {
                    return areRangesEqual(entry.req.query.range, req.query.range);
                });
                return [countQuery, !!countQuery, tblCache, entries];
        }
    }

    function subscribeToCacheEntry(cacheEntry, container, requery, signal) {
        cacheEntry.subscribers.add(requery);
        signal.addEventListener("abort", function () {
            cacheEntry.subscribers.delete(requery);
            if (cacheEntry.subscribers.size === 0) {
                enqueForDeletion(cacheEntry, container);
            }
        });
    }
    function enqueForDeletion(cacheEntry, container) {
        setTimeout(function () {
            if (cacheEntry.subscribers.size === 0) {
                delArrayItem(container, cacheEntry);
            }
        }, 3000);
    }

    var cacheMiddleware = {
        stack: 'dbcore',
        level: 0,
        name: 'Cache',
        create: function (core) {
            var dbName = core.schema.name;
            var coreMW = __assign(__assign({}, core), { transaction: function (stores, mode, options) {
                    var idbtrans = core.transaction(stores, mode, options);
                    if (mode === 'readwrite') {
                        var ac_1 = new AbortController();
                        var signal = ac_1.signal;
                        var endTransaction = function (wasCommitted) { return function () {
                            ac_1.abort();
                            if (mode === 'readwrite') {
                                var affectedSubscribers_1 = new Set();
                                for (var _i = 0, stores_1 = stores; _i < stores_1.length; _i++) {
                                    var storeName = stores_1[_i];
                                    var tblCache = cache["idb://".concat(dbName, "/").concat(storeName)];
                                    if (tblCache) {
                                        var table = core.table(storeName);
                                        var ops = tblCache.optimisticOps.filter(function (op) { return op.trans === idbtrans; });
                                        if (idbtrans._explicit && wasCommitted && idbtrans.mutatedParts) {
                                            for (var _a = 0, _b = Object.values(tblCache.queries.query); _a < _b.length; _a++) {
                                                var entries = _b[_a];
                                                for (var _c = 0, _d = entries.slice(); _c < _d.length; _c++) {
                                                    var entry = _d[_c];
                                                    if (obsSetsOverlap(entry.obsSet, idbtrans.mutatedParts)) {
                                                        delArrayItem(entries, entry);
                                                        entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                    }
                                                }
                                            }
                                        }
                                        else if (ops.length > 0) {
                                            tblCache.optimisticOps = tblCache.optimisticOps.filter(function (op) { return op.trans !== idbtrans; });
                                            for (var _e = 0, _f = Object.values(tblCache.queries.query); _e < _f.length; _e++) {
                                                var entries = _f[_e];
                                                for (var _g = 0, _h = entries.slice(); _g < _h.length; _g++) {
                                                    var entry = _h[_g];
                                                    if (entry.res != null &&
                                                        idbtrans.mutatedParts
    ) {
                                                        if (wasCommitted && !entry.dirty) {
                                                            var freezeResults = Object.isFrozen(entry.res);
                                                            var modRes = applyOptimisticOps(entry.res, entry.req, ops, table, entry, freezeResults);
                                                            if (entry.dirty) {
                                                                delArrayItem(entries, entry);
                                                                entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                            }
                                                            else if (modRes !== entry.res) {
                                                                entry.res = modRes;
                                                                entry.promise = DexiePromise.resolve({ result: modRes });
                                                            }
                                                        }
                                                        else {
                                                            if (entry.dirty) {
                                                                delArrayItem(entries, entry);
                                                            }
                                                            entry.subscribers.forEach(function (requery) { return affectedSubscribers_1.add(requery); });
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                affectedSubscribers_1.forEach(function (requery) { return requery(); });
                            }
                        }; };
                        idbtrans.addEventListener('abort', endTransaction(false), {
                            signal: signal,
                        });
                        idbtrans.addEventListener('error', endTransaction(false), {
                            signal: signal,
                        });
                        idbtrans.addEventListener('complete', endTransaction(true), {
                            signal: signal,
                        });
                    }
                    return idbtrans;
                }, table: function (tableName) {
                    var downTable = core.table(tableName);
                    var primKey = downTable.schema.primaryKey;
                    var tableMW = __assign(__assign({}, downTable), { mutate: function (req) {
                            var trans = PSD.trans;
                            if (primKey.outbound ||
                                trans.db._options.cache === 'disabled' ||
                                trans.explicit ||
                                trans.idbtrans.mode !== 'readwrite'
                            ) {
                                return downTable.mutate(req);
                            }
                            var tblCache = cache["idb://".concat(dbName, "/").concat(tableName)];
                            if (!tblCache)
                                return downTable.mutate(req);
                            var promise = downTable.mutate(req);
                            if ((req.type === 'add' || req.type === 'put') && (req.values.length >= 50 || getEffectiveKeys(primKey, req).some(function (key) { return key == null; }))) {
                                promise.then(function (res) {
                                    var reqWithResolvedKeys = __assign(__assign({}, req), { values: req.values.map(function (value, i) {
                                            var _a;
                                            if (res.failures[i])
                                                return value;
                                            var valueWithKey = ((_a = primKey.keyPath) === null || _a === void 0 ? void 0 : _a.includes('.'))
                                                ? deepClone(value)
                                                : __assign({}, value);
                                            setByKeyPath(valueWithKey, primKey.keyPath, res.results[i]);
                                            return valueWithKey;
                                        }) });
                                    var adjustedReq = adjustOptimisticFromFailures(tblCache, reqWithResolvedKeys, res);
                                    tblCache.optimisticOps.push(adjustedReq);
                                    queueMicrotask(function () { return req.mutatedParts && signalSubscribersLazily(req.mutatedParts); });
                                });
                            }
                            else {
                                tblCache.optimisticOps.push(req);
                                req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                promise.then(function (res) {
                                    if (res.numFailures > 0) {
                                        delArrayItem(tblCache.optimisticOps, req);
                                        var adjustedReq = adjustOptimisticFromFailures(tblCache, req, res);
                                        if (adjustedReq) {
                                            tblCache.optimisticOps.push(adjustedReq);
                                        }
                                        req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                    }
                                });
                                promise.catch(function () {
                                    delArrayItem(tblCache.optimisticOps, req);
                                    req.mutatedParts && signalSubscribersLazily(req.mutatedParts);
                                });
                            }
                            return promise;
                        }, query: function (req) {
                            var _a;
                            if (!isCachableContext(PSD, downTable) || !isCachableRequest("query", req))
                                return downTable.query(req);
                            var freezeResults = ((_a = PSD.trans) === null || _a === void 0 ? void 0 : _a.db._options.cache) === 'immutable';
                            var _b = PSD, requery = _b.requery, signal = _b.signal;
                            var _c = findCompatibleQuery(dbName, tableName, 'query', req), cacheEntry = _c[0], exactMatch = _c[1], tblCache = _c[2], container = _c[3];
                            if (cacheEntry && exactMatch) {
                                cacheEntry.obsSet = req.obsSet;
                            }
                            else {
                                var promise = downTable.query(req).then(function (res) {
                                    var result = res.result;
                                    if (cacheEntry)
                                        cacheEntry.res = result;
                                    if (freezeResults) {
                                        for (var i = 0, l = result.length; i < l; ++i) {
                                            Object.freeze(result[i]);
                                        }
                                        Object.freeze(result);
                                    }
                                    else {
                                        res.result = deepClone(result);
                                    }
                                    return res;
                                }).catch(function (error) {
                                    if (container && cacheEntry)
                                        delArrayItem(container, cacheEntry);
                                    return Promise.reject(error);
                                });
                                cacheEntry = {
                                    obsSet: req.obsSet,
                                    promise: promise,
                                    subscribers: new Set(),
                                    type: 'query',
                                    req: req,
                                    dirty: false,
                                };
                                if (container) {
                                    container.push(cacheEntry);
                                }
                                else {
                                    container = [cacheEntry];
                                    if (!tblCache) {
                                        tblCache = cache["idb://".concat(dbName, "/").concat(tableName)] = {
                                            queries: {
                                                query: {},
                                                count: {},
                                            },
                                            objs: new Map(),
                                            optimisticOps: [],
                                            unsignaledParts: {}
                                        };
                                    }
                                    tblCache.queries.query[req.query.index.name || ''] = container;
                                }
                            }
                            subscribeToCacheEntry(cacheEntry, container, requery, signal);
                            return cacheEntry.promise.then(function (res) {
                                return {
                                    result: applyOptimisticOps(res.result, req, tblCache === null || tblCache === void 0 ? void 0 : tblCache.optimisticOps, downTable, cacheEntry, freezeResults),
                                };
                            });
                        } });
                    return tableMW;
                } });
            return coreMW;
        },
    };

    function vipify(target, vipDb) {
        return new Proxy(target, {
            get: function (target, prop, receiver) {
                if (prop === 'db')
                    return vipDb;
                return Reflect.get(target, prop, receiver);
            }
        });
    }

    var Dexie$1 =  (function () {
        function Dexie(name, options) {
            var _this = this;
            this._middlewares = {};
            this.verno = 0;
            var deps = Dexie.dependencies;
            this._options = options = __assign({
                addons: Dexie.addons, autoOpen: true,
                indexedDB: deps.indexedDB, IDBKeyRange: deps.IDBKeyRange, cache: 'cloned' }, options);
            this._deps = {
                indexedDB: options.indexedDB,
                IDBKeyRange: options.IDBKeyRange
            };
            var addons = options.addons;
            this._dbSchema = {};
            this._versions = [];
            this._storeNames = [];
            this._allTables = {};
            this.idbdb = null;
            this._novip = this;
            var state = {
                dbOpenError: null,
                isBeingOpened: false,
                onReadyBeingFired: null,
                openComplete: false,
                dbReadyResolve: nop,
                dbReadyPromise: null,
                cancelOpen: nop,
                openCanceller: null,
                autoSchema: true,
                PR1398_maxLoop: 3,
                autoOpen: options.autoOpen,
            };
            state.dbReadyPromise = new DexiePromise(function (resolve) {
                state.dbReadyResolve = resolve;
            });
            state.openCanceller = new DexiePromise(function (_, reject) {
                state.cancelOpen = reject;
            });
            this._state = state;
            this.name = name;
            this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop] });
            this.once = function (event, callback) {
                var fn = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    _this.on(event).unsubscribe(fn);
                    callback.apply(_this, args);
                };
                return _this.on(event, fn);
            };
            this.on.ready.subscribe = override(this.on.ready.subscribe, function (subscribe) {
                return function (subscriber, bSticky) {
                    Dexie.vip(function () {
                        var state = _this._state;
                        if (state.openComplete) {
                            if (!state.dbOpenError)
                                DexiePromise.resolve().then(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else if (state.onReadyBeingFired) {
                            state.onReadyBeingFired.push(subscriber);
                            if (bSticky)
                                subscribe(subscriber);
                        }
                        else {
                            subscribe(subscriber);
                            var db_1 = _this;
                            if (!bSticky)
                                subscribe(function unsubscribe() {
                                    db_1.on.ready.unsubscribe(subscriber);
                                    db_1.on.ready.unsubscribe(unsubscribe);
                                });
                        }
                    });
                };
            });
            this.Collection = createCollectionConstructor(this);
            this.Table = createTableConstructor(this);
            this.Transaction = createTransactionConstructor(this);
            this.Version = createVersionConstructor(this);
            this.WhereClause = createWhereClauseConstructor(this);
            this.on("versionchange", function (ev) {
                if (ev.newVersion > 0)
                    console.warn("Another connection wants to upgrade database '".concat(_this.name, "'. Closing db now to resume the upgrade."));
                else
                    console.warn("Another connection wants to delete database '".concat(_this.name, "'. Closing db now to resume the delete request."));
                _this.close({ disableAutoOpen: false });
            });
            this.on("blocked", function (ev) {
                if (!ev.newVersion || ev.newVersion < ev.oldVersion)
                    console.warn("Dexie.delete('".concat(_this.name, "') was blocked"));
                else
                    console.warn("Upgrade '".concat(_this.name, "' blocked by other connection holding version ").concat(ev.oldVersion / 10));
            });
            this._maxKey = getMaxKey(options.IDBKeyRange);
            this._createTransaction = function (mode, storeNames, dbschema, parentTransaction) { return new _this.Transaction(mode, storeNames, dbschema, _this._options.chromeTransactionDurability, parentTransaction); };
            this._fireOnBlocked = function (ev) {
                _this.on("blocked").fire(ev);
                connections
                    .filter(function (c) { return c.name === _this.name && c !== _this && !c._state.vcFired; })
                    .map(function (c) { return c.on("versionchange").fire(ev); });
            };
            this.use(cacheExistingValuesMiddleware);
            this.use(cacheMiddleware);
            this.use(observabilityMiddleware);
            this.use(virtualIndexMiddleware);
            this.use(hooksMiddleware);
            var vipDB = new Proxy(this, {
                get: function (_, prop, receiver) {
                    if (prop === '_vip')
                        return true;
                    if (prop === 'table')
                        return function (tableName) { return vipify(_this.table(tableName), vipDB); };
                    var rv = Reflect.get(_, prop, receiver);
                    if (rv instanceof Table)
                        return vipify(rv, vipDB);
                    if (prop === 'tables')
                        return rv.map(function (t) { return vipify(t, vipDB); });
                    if (prop === '_createTransaction')
                        return function () {
                            var tx = rv.apply(this, arguments);
                            return vipify(tx, vipDB);
                        };
                    return rv;
                }
            });
            this.vip = vipDB;
            addons.forEach(function (addon) { return addon(_this); });
        }
        Dexie.prototype.version = function (versionNumber) {
            if (isNaN(versionNumber) || versionNumber < 0.1)
                throw new exceptions.Type("Given version is not a positive number");
            versionNumber = Math.round(versionNumber * 10) / 10;
            if (this.idbdb || this._state.isBeingOpened)
                throw new exceptions.Schema("Cannot add version when database is open");
            this.verno = Math.max(this.verno, versionNumber);
            var versions = this._versions;
            var versionInstance = versions.filter(function (v) { return v._cfg.version === versionNumber; })[0];
            if (versionInstance)
                return versionInstance;
            versionInstance = new this.Version(versionNumber);
            versions.push(versionInstance);
            versions.sort(lowerVersionFirst);
            versionInstance.stores({});
            this._state.autoSchema = false;
            return versionInstance;
        };
        Dexie.prototype._whenReady = function (fn) {
            var _this = this;
            return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise(function (resolve, reject) {
                if (_this._state.openComplete) {
                    return reject(new exceptions.DatabaseClosed(_this._state.dbOpenError));
                }
                if (!_this._state.isBeingOpened) {
                    if (!_this._state.autoOpen) {
                        reject(new exceptions.DatabaseClosed());
                        return;
                    }
                    _this.open().catch(nop);
                }
                _this._state.dbReadyPromise.then(resolve, reject);
            }).then(fn);
        };
        Dexie.prototype.use = function (_a) {
            var stack = _a.stack, create = _a.create, level = _a.level, name = _a.name;
            if (name)
                this.unuse({ stack: stack, name: name });
            var middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
            middlewares.push({ stack: stack, create: create, level: level == null ? 10 : level, name: name });
            middlewares.sort(function (a, b) { return a.level - b.level; });
            return this;
        };
        Dexie.prototype.unuse = function (_a) {
            var stack = _a.stack, name = _a.name, create = _a.create;
            if (stack && this._middlewares[stack]) {
                this._middlewares[stack] = this._middlewares[stack].filter(function (mw) {
                    return create ? mw.create !== create :
                        name ? mw.name !== name :
                            false;
                });
            }
            return this;
        };
        Dexie.prototype.open = function () {
            var _this = this;
            return usePSD(globalPSD,
            function () { return dexieOpen(_this); });
        };
        Dexie.prototype._close = function () {
            this.on.close.fire(new CustomEvent('close'));
            var state = this._state;
            var idx = connections.indexOf(this);
            if (idx >= 0)
                connections.splice(idx, 1);
            if (this.idbdb) {
                try {
                    this.idbdb.close();
                }
                catch (e) { }
                this.idbdb = null;
            }
            if (!state.isBeingOpened) {
                state.dbReadyPromise = new DexiePromise(function (resolve) {
                    state.dbReadyResolve = resolve;
                });
                state.openCanceller = new DexiePromise(function (_, reject) {
                    state.cancelOpen = reject;
                });
            }
        };
        Dexie.prototype.close = function (_a) {
            var _b = _a === void 0 ? { disableAutoOpen: true } : _a, disableAutoOpen = _b.disableAutoOpen;
            var state = this._state;
            if (disableAutoOpen) {
                if (state.isBeingOpened) {
                    state.cancelOpen(new exceptions.DatabaseClosed());
                }
                this._close();
                state.autoOpen = false;
                state.dbOpenError = new exceptions.DatabaseClosed();
            }
            else {
                this._close();
                state.autoOpen = this._options.autoOpen ||
                    state.isBeingOpened;
                state.openComplete = false;
                state.dbOpenError = null;
            }
        };
        Dexie.prototype.delete = function (closeOptions) {
            var _this = this;
            if (closeOptions === void 0) { closeOptions = { disableAutoOpen: true }; }
            var hasInvalidArguments = arguments.length > 0 && typeof arguments[0] !== 'object';
            var state = this._state;
            return new DexiePromise(function (resolve, reject) {
                var doDelete = function () {
                    _this.close(closeOptions);
                    var req = _this._deps.indexedDB.deleteDatabase(_this.name);
                    req.onsuccess = wrap(function () {
                        _onDatabaseDeleted(_this._deps, _this.name);
                        resolve();
                    });
                    req.onerror = eventRejectHandler(reject);
                    req.onblocked = _this._fireOnBlocked;
                };
                if (hasInvalidArguments)
                    throw new exceptions.InvalidArgument("Invalid closeOptions argument to db.delete()");
                if (state.isBeingOpened) {
                    state.dbReadyPromise.then(doDelete);
                }
                else {
                    doDelete();
                }
            });
        };
        Dexie.prototype.backendDB = function () {
            return this.idbdb;
        };
        Dexie.prototype.isOpen = function () {
            return this.idbdb !== null;
        };
        Dexie.prototype.hasBeenClosed = function () {
            var dbOpenError = this._state.dbOpenError;
            return dbOpenError && (dbOpenError.name === 'DatabaseClosed');
        };
        Dexie.prototype.hasFailed = function () {
            return this._state.dbOpenError !== null;
        };
        Dexie.prototype.dynamicallyOpened = function () {
            return this._state.autoSchema;
        };
        Object.defineProperty(Dexie.prototype, "tables", {
            get: function () {
                var _this = this;
                return keys(this._allTables).map(function (name) { return _this._allTables[name]; });
            },
            enumerable: false,
            configurable: true
        });
        Dexie.prototype.transaction = function () {
            var args = extractTransactionArgs.apply(this, arguments);
            return this._transaction.apply(this, args);
        };
        Dexie.prototype._transaction = function (mode, tables, scopeFunc) {
            var _this = this;
            var parentTransaction = PSD.trans;
            if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)
                parentTransaction = null;
            var onlyIfCompatible = mode.indexOf('?') !== -1;
            mode = mode.replace('!', '').replace('?', '');
            var idbMode, storeNames;
            try {
                storeNames = tables.map(function (table) {
                    var storeName = table instanceof _this.Table ? table.name : table;
                    if (typeof storeName !== 'string')
                        throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
                    return storeName;
                });
                if (mode == "r" || mode === READONLY)
                    idbMode = READONLY;
                else if (mode == "rw" || mode == READWRITE)
                    idbMode = READWRITE;
                else
                    throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
                if (parentTransaction) {
                    if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
                        if (onlyIfCompatible) {
                            parentTransaction = null;
                        }
                        else
                            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
                    }
                    if (parentTransaction) {
                        storeNames.forEach(function (storeName) {
                            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
                                if (onlyIfCompatible) {
                                    parentTransaction = null;
                                }
                                else
                                    throw new exceptions.SubTransaction("Table " + storeName +
                                        " not included in parent transaction.");
                            }
                        });
                    }
                    if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
                        parentTransaction = null;
                    }
                }
            }
            catch (e) {
                return parentTransaction ?
                    parentTransaction._promise(null, function (_, reject) { reject(e); }) :
                    rejection(e);
            }
            var enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
            return (parentTransaction ?
                parentTransaction._promise(idbMode, enterTransaction, "lock") :
                PSD.trans ?
                    usePSD(PSD.transless, function () { return _this._whenReady(enterTransaction); }) :
                    this._whenReady(enterTransaction));
        };
        Dexie.prototype.table = function (tableName) {
            if (!hasOwn(this._allTables, tableName)) {
                throw new exceptions.InvalidTable("Table ".concat(tableName, " does not exist"));
            }
            return this._allTables[tableName];
        };
        return Dexie;
    }());

    var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol
        ? Symbol.observable
        : "@@observable";
    var Observable =  (function () {
        function Observable(subscribe) {
            this._subscribe = subscribe;
        }
        Observable.prototype.subscribe = function (x, error, complete) {
            return this._subscribe(!x || typeof x === "function" ? { next: x, error: error, complete: complete } : x);
        };
        Observable.prototype[symbolObservable] = function () {
            return this;
        };
        return Observable;
    }());

    var domDeps;
    try {
        domDeps = {
            indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
            IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
        };
    }
    catch (e) {
        domDeps = { indexedDB: null, IDBKeyRange: null };
    }

    function liveQuery(querier) {
        var hasValue = false;
        var currentValue;
        var observable = new Observable(function (observer) {
            var scopeFuncIsAsync = isAsyncFunction(querier);
            function execute(ctx) {
                var wasRootExec = beginMicroTickScope();
                try {
                    if (scopeFuncIsAsync) {
                        incrementExpectedAwaits();
                    }
                    var rv = newScope(querier, ctx);
                    if (scopeFuncIsAsync) {
                        rv = rv.finally(decrementExpectedAwaits);
                    }
                    return rv;
                }
                finally {
                    wasRootExec && endMicroTickScope();
                }
            }
            var closed = false;
            var abortController;
            var accumMuts = {};
            var currentObs = {};
            var subscription = {
                get closed() {
                    return closed;
                },
                unsubscribe: function () {
                    if (closed)
                        return;
                    closed = true;
                    if (abortController)
                        abortController.abort();
                    if (startedListening)
                        globalEvents.storagemutated.unsubscribe(mutationListener);
                },
            };
            observer.start && observer.start(subscription);
            var startedListening = false;
            var doQuery = function () { return execInGlobalContext(_doQuery); };
            function shouldNotify() {
                return obsSetsOverlap(currentObs, accumMuts);
            }
            var mutationListener = function (parts) {
                extendObservabilitySet(accumMuts, parts);
                if (shouldNotify()) {
                    doQuery();
                }
            };
            var _doQuery = function () {
                if (closed ||
                    !domDeps.indexedDB)
                 {
                    return;
                }
                accumMuts = {};
                var subscr = {};
                if (abortController)
                    abortController.abort();
                abortController = new AbortController();
                var ctx = {
                    subscr: subscr,
                    signal: abortController.signal,
                    requery: doQuery,
                    querier: querier,
                    trans: null
                };
                var ret = execute(ctx);
                Promise.resolve(ret).then(function (result) {
                    hasValue = true;
                    currentValue = result;
                    if (closed || ctx.signal.aborted) {
                        return;
                    }
                    accumMuts = {};
                    currentObs = subscr;
                    if (!objectIsEmpty(currentObs) && !startedListening) {
                        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
                        startedListening = true;
                    }
                    execInGlobalContext(function () { return !closed && observer.next && observer.next(result); });
                }, function (err) {
                    hasValue = false;
                    if (!['DatabaseClosedError', 'AbortError'].includes(err === null || err === void 0 ? void 0 : err.name)) {
                        if (!closed)
                            execInGlobalContext(function () {
                                if (closed)
                                    return;
                                observer.error && observer.error(err);
                            });
                    }
                });
            };
            setTimeout(doQuery, 0);
            return subscription;
        });
        observable.hasValue = function () { return hasValue; };
        observable.getValue = function () { return currentValue; };
        return observable;
    }

    var Dexie = Dexie$1;
    props(Dexie, __assign(__assign({}, fullNameExceptions), {
        delete: function (databaseName) {
            var db = new Dexie(databaseName, { addons: [] });
            return db.delete();
        },
        exists: function (name) {
            return new Dexie(name, { addons: [] }).open().then(function (db) {
                db.close();
                return true;
            }).catch('NoSuchDatabaseError', function () { return false; });
        },
        getDatabaseNames: function (cb) {
            try {
                return getDatabaseNames(Dexie.dependencies).then(cb);
            }
            catch (_a) {
                return rejection(new exceptions.MissingAPI());
            }
        },
        defineClass: function () {
            function Class(content) {
                extend(this, content);
            }
            return Class;
        }, ignoreTransaction: function (scopeFunc) {
            return PSD.trans ?
                usePSD(PSD.transless, scopeFunc) :
                scopeFunc();
        }, vip: vip, async: function (generatorFn) {
            return function () {
                try {
                    var rv = awaitIterator(generatorFn.apply(this, arguments));
                    if (!rv || typeof rv.then !== 'function')
                        return DexiePromise.resolve(rv);
                    return rv;
                }
                catch (e) {
                    return rejection(e);
                }
            };
        }, spawn: function (generatorFn, args, thiz) {
            try {
                var rv = awaitIterator(generatorFn.apply(thiz, args || []));
                if (!rv || typeof rv.then !== 'function')
                    return DexiePromise.resolve(rv);
                return rv;
            }
            catch (e) {
                return rejection(e);
            }
        },
        currentTransaction: {
            get: function () { return PSD.trans || null; }
        }, waitFor: function (promiseOrFunction, optionalTimeout) {
            var promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?
                Dexie.ignoreTransaction(promiseOrFunction) :
                promiseOrFunction)
                .timeout(optionalTimeout || 60000);
            return PSD.trans ?
                PSD.trans.waitFor(promise) :
                promise;
        },
        Promise: DexiePromise,
        debug: {
            get: function () { return debug; },
            set: function (value) {
                setDebug(value);
            }
        },
        derive: derive, extend: extend, props: props, override: override,
        Events: Events, on: globalEvents, liveQuery: liveQuery, extendObservabilitySet: extendObservabilitySet,
        getByKeyPath: getByKeyPath, setByKeyPath: setByKeyPath, delByKeyPath: delByKeyPath, shallowClone: shallowClone, deepClone: deepClone, getObjectDiff: getObjectDiff, cmp: cmp, asap: asap$1,
        minKey: minKey,
        addons: [],
        connections: connections,
        errnames: errnames,
        dependencies: domDeps, cache: cache,
        semVer: DEXIE_VERSION, version: DEXIE_VERSION.split('.')
            .map(function (n) { return parseInt(n); })
            .reduce(function (p, c, i) { return p + (c / Math.pow(10, i * 2)); }) }));
    Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);

    if (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (updatedParts) {
            if (!propagatingLocally) {
                var event_1;
                event_1 = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
                    detail: updatedParts
                });
                propagatingLocally = true;
                dispatchEvent(event_1);
                propagatingLocally = false;
            }
        });
        addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, function (_a) {
            var detail = _a.detail;
            if (!propagatingLocally) {
                propagateLocally(detail);
            }
        });
    }
    function propagateLocally(updateParts) {
        var wasMe = propagatingLocally;
        try {
            propagatingLocally = true;
            globalEvents.storagemutated.fire(updateParts);
            signalSubscribersNow(updateParts, true);
        }
        finally {
            propagatingLocally = wasMe;
        }
    }
    var propagatingLocally = false;

    var bc;
    var createBC = function () { };
    if (typeof BroadcastChannel !== 'undefined') {
        createBC = function () {
            bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
            bc.onmessage = function (ev) { return ev.data && propagateLocally(ev.data); };
        };
        createBC();
        if (typeof bc.unref === 'function') {
            bc.unref();
        }
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, function (changedParts) {
            if (!propagatingLocally) {
                bc.postMessage(changedParts);
            }
        });
    }

    if (typeof addEventListener !== 'undefined') {
        addEventListener('pagehide', function (event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
                if (debug)
                    console.debug('Dexie: handling persisted pagehide');
                bc === null || bc === void 0 ? void 0 : bc.close();
                for (var _i = 0, connections_1 = connections; _i < connections_1.length; _i++) {
                    var db = connections_1[_i];
                    db.close({ disableAutoOpen: false });
                }
            }
        });
        addEventListener('pageshow', function (event) {
            if (!Dexie$1.disableBfCache && event.persisted) {
                if (debug)
                    console.debug('Dexie: handling persisted pageshow');
                createBC();
                propagateLocally({ all: new RangeSet(-Infinity, [[]]) });
            }
        });
    }

    function add(value) {
        return new PropModification({ add: value });
    }

    function remove(value) {
        return new PropModification({ remove: value });
    }

    function replacePrefix(a, b) {
        return new PropModification({ replacePrefix: [a, b] });
    }

    DexiePromise.rejectionMapper = mapError;
    setDebug(debug);

    var namedExports = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Dexie: Dexie$1,
        liveQuery: liveQuery,
        Entity: Entity,
        cmp: cmp,
        PropModification: PropModification,
        replacePrefix: replacePrefix,
        add: add,
        remove: remove,
        'default': Dexie$1,
        RangeSet: RangeSet,
        mergeRanges: mergeRanges,
        rangesOverlap: rangesOverlap
    });

    __assign(Dexie$1, namedExports, { default: Dexie$1 });

    return Dexie$1;

}));
//# sourceMappingURL=dexie.js.map
</file>

<file path="js/materials.js">
// js/materials.js

let materialsModuleInitialized = false;

// --- DOM References ---
const materialsTableBody = document.querySelector('#materials-table tbody');
const materialSearchInput = document.getElementById('material-search-input');
const addNewMaterialBtn = document.getElementById('add-new-material-btn');

// --- Modal References ---
const materialModal = document.getElementById('material-modal');
const materialModalTitle = document.getElementById('material-modal-title');
const materialModalClose = document.querySelector('.material-modal-close');
const materialForm = document.getElementById('material-form');
const materialIdInput = document.getElementById('material-id');
const materialNameInput = document.getElementById('material-name');
const materialUnitInput = document.getElementById('material-unit');
const materialPriceInput = document.getElementById('material-price');

// --- Functions ---
const openMaterialModal = () => materialModal.style.display = 'block';
const closeMaterialModal = () => materialModal.style.display = 'none';

const displayMaterials = async () => {
    const filter = materialSearchInput.value.toLowerCase();
    const allMaterials = await db.materials.orderBy('name').toArray();

    materialsTableBody.innerHTML = '';
    const filteredMaterials = allMaterials.filter(m => m.name.toLowerCase().includes(filter));

    if (filteredMaterials.length === 0) {
        materialsTableBody.innerHTML = `<tr><td colspan="4">No materials found.</td></tr>`;
        return;
    }

    filteredMaterials.forEach(material => {
        const row = materialsTableBody.insertRow();
        row.innerHTML = `
            <td>${material.name}</td>
            <td>${material.unit}</td>
            <td>${material.unitPrice.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td>
            <td class="actions-cell">
                <button class="btn btn-warning edit-material-btn" data-id="${material.id}">Edit</button>
                <button class="btn btn-danger delete-material-btn" data-id="${material.id}">Delete</button>
            </td>
        `;
    });
};

function initializeMaterialsLibraryModule() {
    if (materialsModuleInitialized) return;

    addNewMaterialBtn.addEventListener('click', () => {
        materialModalTitle.textContent = 'Add New Material';
        materialForm.reset();
        materialIdInput.value = '';
        openMaterialModal();
    });

    materialModalClose.addEventListener('click', closeMaterialModal);

    materialSearchInput.addEventListener('input', displayMaterials);

    materialForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const id = materialIdInput.value ? parseInt(materialIdInput.value) : null;
        const data = {
            name: materialNameInput.value,
            unit: materialUnitInput.value,
            unitPrice: parseFloat(materialPriceInput.value)
        };

        try {
            if (id) {
                await db.materials.update(id, data);
            } else {
                await db.materials.add(data);
            }
            closeMaterialModal();
            await displayMaterials();
        } catch (error) {
            console.error("Failed to save material:", error);
            alert(`Error saving material: ${error.message}. The material name may already exist.`);
        }
    });

    materialsTableBody.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.classList.contains('edit-material-btn')) {
            const id = parseInt(target.dataset.id);
            const material = await db.materials.get(id);
            if (material) {
                materialModalTitle.textContent = 'Edit Material';
                materialIdInput.value = material.id;
                materialNameInput.value = material.name;
                materialUnitInput.value = material.unit;
                materialPriceInput.value = material.unitPrice;
                openMaterialModal();
            }
        }
        if (target.classList.contains('delete-material-btn')) {
            const id = parseInt(target.dataset.id);
            if (confirm('Are you sure you want to delete this material?')) {
                await db.materials.delete(id);
                await displayMaterials();
            }
        }
    });

    materialsModuleInitialized = true;
}
</file>

<file path="sample projects/default multistory.json">
{
  "project": {
    "projectName": "Three-Story Commercial (Granular Breakdown)",
    "address": "Lacson St., Mandalagan, Bacolod City",
    "clientName": "Visayan Business Corp.",
    "projectDescription": "Construction of a three-level commercial building with roof deck for mixed-use office and retail space. This project features a detailed, phased schedule with granular structural tasks.",
    "startDate": null,
    "lotArea": 600,
    "floorArea": 1200,
    "numFloors": 3,
    "contractAmount": 15000000,
    "contractDate": "2025-01-15",
    "projectStatus": "On-Going",
    "targetStartDate": "2025-02-01",
    "contractDuration": 240,
    "projectManager": "Engr. Alex Reyes",
    "clientContact": "ceo@visayanbiz.com"
  },
  "quantities": [
    { "id": 401, "scopeOfWork": "Site Clearing & Excavation", "quantity": 1, "unit": "lot", "category": "A. General Works" },
    { "id": 402, "scopeOfWork": "GF Columns & Footings - Rebar Works", "quantity": 7500, "unit": "kg", "category": "B. Structural - GF" },
    { "id": 403, "scopeOfWork": "GF Columns & Footings - Formworks", "quantity": 500, "unit": "sq.m", "category": "B. Structural - GF" },
    { "id": 404, "scopeOfWork": "GF Columns & Footings - Concrete", "quantity": 80, "unit": "cu.m", "category": "B. Structural - GF" },
    { "id": 405, "scopeOfWork": "GF Beams & Slab - Rebar Works", "quantity": 6000, "unit": "kg", "category": "B. Structural - GF" },
    { "id": 406, "scopeOfWork": "GF Beams & Slab - Formworks", "quantity": 400, "unit": "sq.m", "category": "B. Structural - GF" },
    { "id": 407, "scopeOfWork": "GF Beams & Slab - Concrete", "quantity": 60, "unit": "cu.m", "category": "B. Structural - GF" },
    { "id": 408, "scopeOfWork": "2F Columns - Rebar Works", "quantity": 3500, "unit": "kg", "category": "C. Structural - 2F" },
    { "id": 409, "scopeOfWork": "2F Columns - Formworks", "quantity": 300, "unit": "sq.m", "category": "C. Structural - 2F" },
    { "id": 410, "scopeOfWork": "2F Columns - Concrete", "quantity": 30, "unit": "cu.m", "category": "C. Structural - 2F" },
    { "id": 411, "scopeOfWork": "2F Beams & Slab - Rebar Works", "quantity": 5500, "unit": "kg", "category": "C. Structural - 2F" },
    { "id": 412, "scopeOfWork": "2F Beams & Slab - Formworks", "quantity": 400, "unit": "sq.m", "category": "C. Structural - 2F" },
    { "id": 413, "scopeOfWork": "2F Beams & Slab - Concrete", "quantity": 60, "unit": "cu.m", "category": "C. Structural - 2F" },
    { "id": 414, "scopeOfWork": "3F Columns - Rebar Works", "quantity": 3500, "unit": "kg", "category": "D. Structural - 3F" },
    { "id": 415, "scopeOfWork": "3F Columns - Formworks", "quantity": 300, "unit": "sq.m", "category": "D. Structural - 3F" },
    { "id": 416, "scopeOfWork": "3F Columns - Concrete", "quantity": 30, "unit": "cu.m", "category": "D. Structural - 3F" },
    { "id": 417, "scopeOfWork": "3F Beams & Slab - Rebar Works", "quantity": 5500, "unit": "kg", "category": "D. Structural - 3F" },
    { "id": 418, "scopeOfWork": "3F Beams & Slab - Formworks", "quantity": 400, "unit": "sq.m", "category": "D. Structural - 3F" },
    { "id": 419, "scopeOfWork": "3F Beams & Slab - Concrete", "quantity": 60, "unit": "cu.m", "category": "D. Structural - 3F" },
    { "id": 420, "scopeOfWork": "Roof Beams & Deck - Rebar Works", "quantity": 4000, "unit": "kg", "category": "E. Structural - Roof" },
    { "id": 421, "scopeOfWork": "Roof Beams & Deck - Formworks", "quantity": 400, "unit": "sq.m", "category": "E. Structural - Roof" },
    { "id": 422, "scopeOfWork": "Roof Deck - Concrete", "quantity": 50, "unit": "cu.m", "category": "E. Structural - Roof" },
    { "id": 423, "scopeOfWork": "GF Masonry & Plastering", "quantity": 450, "unit": "sq.m", "category": "F. Architectural - GF" },
    { "id": 424, "scopeOfWork": "GF Door & Window Installation", "quantity": 1, "unit": "lot", "category": "F. Architectural - GF" },
    { "id": 425, "scopeOfWork": "GF Floor & Ceiling Finishes", "quantity": 380, "unit": "sq.m", "category": "F. Architectural - GF" },
    { "id": 426, "scopeOfWork": "2F Masonry & Plastering", "quantity": 450, "unit": "sq.m", "category": "G. Architectural - 2F" },
    { "id": 427, "scopeOfWork": "3F Drywall Partitions", "quantity": 400, "unit": "sq.m", "category": "H. Architectural - 3F" },
    { "id": 428, "scopeOfWork": "2F & 3F Doors & Windows Installation", "quantity": 1, "unit": "lot", "category": "I. Architectural - Upper Floors" },
    { "id": 429, "scopeOfWork": "2F & 3F Floor & Ceiling Finishes", "quantity": 760, "unit": "sq.m", "category": "I. Architectural - Upper Floors" },
    { "id": 430, "scopeOfWork": "MEPF Rough-ins", "quantity": 1, "unit": "lot", "category": "J. MEPF Works" },
    { "id": 431, "scopeOfWork": "Exterior Walls & Painting", "quantity": 800, "unit": "sq.m", "category": "K. Final Works" },
    { "id": 432, "scopeOfWork": "Roofing & Waterproofing", "quantity": 420, "unit": "sq.m", "category": "K. Final Works" },
    { "id": 433, "scopeOfWork": "Interior Painting & Fixtures Installation", "quantity": 1, "unit": "lot", "category": "K. Final Works" }
  ],
  "dupas": [
    { "id": 401, "quantityId": 401, "duration": 15, "directCosts": [{"type":"labor","laborType":"Laborer","mandays":50,"rate":500},{"type":"equipment","name":"Excavator","hours":40,"rate":2500}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 402, "quantityId": 402, "duration": 15, "directCosts": [{"type":"labor","laborType":"Steelman","mandays":75,"rate":600},{"type":"material","name":"Rebar 16mm","quantity":5000,"unit":"kg","unitPrice":55},{"type":"material","name":"Rebar 10mm","quantity":2500,"unit":"kg","unitPrice":52},{"type":"material","name":"G.I. Tie Wire","quantity":100,"unit":"kg","unitPrice":80}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 403, "quantityId": 403, "duration": 12, "directCosts": [{"type":"labor","laborType":"Carpenter","mandays":60,"rate":550},{"type":"material","name":"Phenolic Board","quantity":160,"unit":"sheets","unitPrice":900},{"type":"material","name":"Nails & Fasteners","quantity":50,"unit":"kg","unitPrice":120}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 404, "quantityId": 404, "duration": 4, "directCosts": [{"type":"labor","laborType":"Laborer","mandays":16,"rate":500},{"type":"material","name":"Portland Cement","quantity":760,"unit":"bags","unitPrice":250},{"type":"material","name":"Washed Sand","quantity":40,"unit":"cu.m","unitPrice":1200},{"type":"material","name":"Gravel 3/4\"","quantity":80,"unit":"cu.m","unitPrice":1300},{"type":"equipment","name":"1-Bagger Mixer","hours":32,"rate":190}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 405, "quantityId": 405, "duration": 12, "directCosts": [{"type":"labor","laborType":"Steelman","mandays":60,"rate":600},{"type":"material","name":"Rebar 16mm","quantity":4000,"unit":"kg","unitPrice":55},{"type":"material","name":"Rebar 10mm","quantity":2000,"unit":"kg","unitPrice":52},{"type":"material","name":"G.I. Tie Wire","quantity":80,"unit":"kg","unitPrice":80}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 406, "quantityId": 406, "duration": 18, "directCosts": [{"type":"labor","laborType":"Carpenter","mandays":80,"rate":550},{"type":"material","name":"Phenolic Board","quantity":130,"unit":"sheets","unitPrice":900},{"type":"material","name":"Nails & Fasteners","quantity":60,"unit":"kg","unitPrice":120}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 407, "quantityId": 407, "duration": 3, "directCosts": [{"type":"labor","laborType":"Laborer","mandays":12,"rate":500},{"type":"material","name":"Portland Cement","quantity":570,"unit":"bags","unitPrice":250},{"type":"material","name":"Washed Sand","quantity":30,"unit":"cu.m","unitPrice":1200},{"type":"material","name":"Gravel 3/4\"","quantity":60,"unit":"cu.m","unitPrice":1300},{"type":"equipment","name":"1-Bagger Mixer","hours":24,"rate":190}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 408, "quantityId": 408, "duration": 10, "directCosts": [{"type":"labor","laborType":"Steelman","mandays":50,"rate":600},{"type":"material","name":"Rebar 12mm","quantity":2500,"unit":"kg","unitPrice":54},{"type":"material","name":"Rebar 10mm","quantity":1000,"unit":"kg","unitPrice":52},{"type":"material","name":"G.I. Tie Wire","quantity":50,"unit":"kg","unitPrice":80}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 409, "quantityId": 409, "duration": 10, "directCosts": [{"type":"labor","laborType":"Carpenter","mandays":50,"rate":550},{"type":"material","name":"Phenolic Board","quantity":100,"unit":"sheets","unitPrice":900}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 410, "quantityId": 410, "duration": 3, "directCosts": [{"type":"labor","laborType":"Laborer","mandays":6,"rate":500},{"type":"material","name":"Portland Cement","quantity":285,"unit":"bags","unitPrice":250},{"type":"material","name":"Washed Sand","quantity":15,"unit":"cu.m","unitPrice":1200},{"type":"material","name":"Gravel 3/4\"","quantity":30,"unit":"cu.m","unitPrice":1300},{"type":"equipment","name":"1-Bagger Mixer","hours":24,"rate":190}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 411, "quantityId": 411, "duration": 12, "directCosts": [{"type":"labor","laborType":"Steelman","mandays":60,"rate":600},{"type":"material","name":"Rebar 12mm","quantity":3500,"unit":"kg","unitPrice":54},{"type":"material","name":"Rebar 10mm","quantity":2000,"unit":"kg","unitPrice":52}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 412, "quantityId": 412, "duration": 18, "directCosts": [{"type":"labor","laborType":"Carpenter","mandays":80,"rate":550},{"type":"material","name":"Phenolic Board","quantity":130,"unit":"sheets","unitPrice":900}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 413, "quantityId": 413, "duration": 3, "directCosts": [{"type":"labor","laborType":"Laborer","mandays":12,"rate":500},{"type":"material","name":"Portland Cement","quantity":570,"unit":"bags","unitPrice":250},{"type":"material","name":"Washed Sand","quantity":30,"unit":"cu.m","unitPrice":1200},{"type":"material","name":"Gravel 3/4\"","quantity":60,"unit":"cu.m","unitPrice":1300},{"type":"equipment","name":"1-Bagger Mixer","hours":24,"rate":190}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 414, "quantityId": 414, "duration": 10, "directCosts": [{"type":"labor","laborType":"Steelman","mandays":50,"rate":600},{"type":"material","name":"Rebar 12mm","quantity":2500,"unit":"kg","unitPrice":54},{"type":"material","name":"Rebar 10mm","quantity":1000,"unit":"kg","unitPrice":52}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 415, "quantityId": 415, "duration": 10, "directCosts": [{"type":"labor","laborType":"Carpenter","mandays":50,"rate":550},{"type":"material","name":"Phenolic Board","quantity":100,"unit":"sheets","unitPrice":900}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 416, "quantityId": 416, "duration": 3, "directCosts": [{"type":"labor","laborType":"Laborer","mandays":6,"rate":500},{"type":"material","name":"Portland Cement","quantity":285,"unit":"bags","unitPrice":250},{"type":"material","name":"Washed Sand","quantity":15,"unit":"cu.m","unitPrice":1200},{"type":"material","name":"Gravel 3/4\"","quantity":30,"unit":"cu.m","unitPrice":1300},{"type":"equipment","name":"1-Bagger Mixer","hours":24,"rate":190}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 417, "quantityId": 417, "duration": 12, "directCosts": [{"type":"labor","laborType":"Steelman","mandays":60,"rate":600},{"type":"material","name":"Rebar 12mm","quantity":3500,"unit":"kg","unitPrice":54},{"type":"material","name":"Rebar 10mm","quantity":2000,"unit":"kg","unitPrice":52}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 418, "quantityId": 418, "duration": 18, "directCosts": [{"type":"labor","laborType":"Carpenter","mandays":80,"rate":550},{"type":"material","name":"Phenolic Board","quantity":130,"unit":"sheets","unitPrice":900}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 419, "quantityId": 419, "duration": 3, "directCosts": [{"type":"labor","laborType":"Laborer","mandays":12,"rate":500},{"type":"material","name":"Portland Cement","quantity":570,"unit":"bags","unitPrice":250},{"type":"material","name":"Washed Sand","quantity":30,"unit":"cu.m","unitPrice":1200},{"type":"material","name":"Gravel 3/4\"","quantity":60,"unit":"cu.m","unitPrice":1300},{"type":"equipment","name":"1-Bagger Mixer","hours":24,"rate":190}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 420, "quantityId": 420, "duration": 10, "directCosts": [{"type":"labor","laborType":"Steelman","mandays":50,"rate":600},{"type":"material","name":"Rebar 10mm","quantity":4000,"unit":"kg","unitPrice":52}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 421, "quantityId": 421, "duration": 15, "directCosts": [{"type":"labor","laborType":"Carpenter","mandays":70,"rate":550},{"type":"material","name":"Phenolic Board","quantity":130,"unit":"sheets","unitPrice":900}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 422, "quantityId": 422, "duration": 3, "directCosts": [{"type":"labor","laborType":"Laborer","mandays":10,"rate":500},{"type":"material","name":"Portland Cement","quantity":475,"unit":"bags","unitPrice":250},{"type":"material","name":"Washed Sand","quantity":25,"unit":"cu.m","unitPrice":1200},{"type":"material","name":"Gravel 3/4\"","quantity":50,"unit":"cu.m","unitPrice":1300},{"type":"equipment","name":"1-Bagger Mixer","hours":24,"rate":190}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 423, "quantityId": 423, "duration": 25, "directCosts": [{"type":"labor","laborType":"Mason","mandays":100,"rate":550},{"type":"material","name":"CHB #6","quantity":5625,"unit":"pcs","unitPrice":18}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 424, "quantityId": 424, "duration": 12, "directCosts": [{"type":"labor","laborType":"Installer","mandays":40,"rate":600}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 425, "quantityId": 425, "duration": 20, "directCosts": [{"type":"labor","laborType":"Tile Setter","mandays":50,"rate":600},{"type":"material","name":"Granite Tiles","quantity":380,"unit":"sq.m","unitPrice":650}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 426, "quantityId": 426, "duration": 25, "directCosts": [{"type":"labor","laborType":"Mason","mandays":100,"rate":550},{"type":"material","name":"CHB #6","quantity":5625,"unit":"pcs","unitPrice":18}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 427, "quantityId": 427, "duration": 20, "directCosts": [{"type":"labor","laborType":"Installer","mandays":50,"rate":550},{"type":"material","name":"Drywall Panels","quantity":400,"unit":"sq.m","unitPrice":850}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 428, "quantityId": 428, "duration": 18, "directCosts": [{"type":"labor","laborType":"Installer","mandays":60,"rate":600},{"type":"material","name":"Aluminum Windows","quantity":30,"unit":"sets","unitPrice":12000}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 429, "quantityId": 429, "duration": 30, "directCosts": [{"type":"labor","laborType":"Installer","mandays":80,"rate":600},{"type":"material","name":"Acoustic Ceilings","quantity":760,"unit":"sq.m","unitPrice":450}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 430, "quantityId": 430, "duration": 30, "directCosts": [{"type":"labor","laborType":"Electrician","mandays":50,"rate":650},{"type":"labor","laborType":"Plumber","mandays":50,"rate":650}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 431, "quantityId": 431, "duration": 25, "directCosts": [{"type":"labor","laborType":"Painter","mandays":100,"rate":550},{"type":"material","name":"Elastomeric Paint","quantity":100,"unit":"gal","unitPrice":1200}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 432, "quantityId": 432, "duration": 15, "directCosts": [{"type":"labor","laborType":"Roofer","mandays":40,"rate":600},{"type":"material","name":"Waterproofing","quantity":420,"unit":"sq.m","unitPrice":350}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}},
    { "id": 433, "quantityId": 433, "duration": 20, "directCosts": [{"type":"labor","laborType":"Painter","mandays":80,"rate":550},{"type":"labor","laborType":"Master Electrician","mandays":30,"rate":750}], "indirectCosts": {"ocm":12,"profit":15,"taxes":5}}
  ],
  "tasks": [
    { "predecessorId": "PROJECT_START", "successorId": 401 },
    { "predecessorId": 401, "successorId": 402 },
    { "predecessorId": 402, "successorId": 403 },
    { "predecessorId": 403, "successorId": 404 },
    { "predecessorId": 404, "successorId": 405 },
    { "predecessorId": 405, "successorId": 406 },
    { "predecessorId": 406, "successorId": 407 },
    { "predecessorId": 407, "successorId": 408 },
    { "predecessorId": 407, "successorId": 423 },
    { "predecessorId": 408, "successorId": 409 },
    { "predecessorId": 409, "successorId": 410 },
    { "predecessorId": 410, "successorId": 411 },
    { "predecessorId": 410, "successorId": 426 },
    { "predecessorId": 411, "successorId": 412 },
    { "predecessorId": 412, "successorId": 413 },
    { "predecessorId": 413, "successorId": 414 },
    { "predecessorId": 413, "successorId": 427 },
    { "predecessorId": 414, "successorId": 415 },
    { "predecessorId": 415, "successorId": 416 },
    { "predecessorId": 416, "successorId": 417 },
    { "predecessorId": 417, "successorId": 418 },
    { "predecessorId": 418, "successorId": 419 },
    { "predecessorId": 419, "successorId": 420 },
    { "predecessorId": 420, "successorId": 421 },
    { "predecessorId": 421, "successorId": 422 },
    { "predecessorId": 423, "successorId": 424 },
    { "predecessorId": 424, "successorId": 425 },
    { "predecessorId": 426, "successorId": 428 },
    { "predecessorId": 427, "successorId": 428 },
    { "predecessorId": 425, "successorId": 429 },
    { "predecessorId": 428, "successorId": 429 },
    { "predecessorId": 423, "successorId": 430 },
    { "predecessorId": 426, "successorId": 430 },
    { "predecessorId": 427, "successorId": 430 },
    { "predecessorId": 422, "successorId": 432 },
    { "predecessorId": 432, "successorId": 431 },
    { "predecessorId": 429, "successorId": 433 },
    { "predecessorId": 430, "successorId": 433 },
    { "predecessorId": 431, "successorId": 433 },
    { "predecessorId": 433, "successorId": "PROJECT_END" }
  ],
  "boq": null,
  "accomplishments": [],
  "changeOrders": [],
  "changeOrderItems": [],
  "changeOrderDupas": []
}
</file>

<file path="sample projects/default project.json">
{
  "project": {
    "projectName": "Default Residential House Project",
    "address": "Generic St., Bacolod City",
    "clientName": "Juan dela Cruz",
    "projectDescription": "A two-story residential building sample project.",
    "id": 1
  },
  "quantities": [
    { "id": 1, "scopeOfWork": "Site Clearing", "quantity": 1, "unit": "lot", "category": "Site Works", "projectId": 1 },
    { "id": 2, "scopeOfWork": "Structural Excavation", "quantity": 45, "unit": "cu.m", "category": "Earthworks", "projectId": 1 },
    { "id": 3, "scopeOfWork": "Footing Concrete", "quantity": 15, "unit": "cu.m", "category": "Structural Concrete", "projectId": 1 },
    { "id": 4, "scopeOfWork": "Column Concrete", "quantity": 8, "unit": "cu.m", "category": "Structural Concrete", "projectId": 1 },
    { "id": 5, "scopeOfWork": "Beam Concrete", "quantity": 12, "unit": "cu.m", "category": "Structural Concrete", "projectId": 1 },
    { "id": 6, "scopeOfWork": "Slab Concrete", "quantity": 20, "unit": "cu.m", "category": "Structural Concrete", "projectId": 1 },
    { "id": 7, "scopeOfWork": "CHB Wall Laying", "quantity": 250, "unit": "sq.m", "category": "Masonry", "projectId": 1 },
    { "id": 8, "scopeOfWork": "Wall Plastering", "quantity": 500, "unit": "sq.m", "category": "Masonry", "projectId": 1 },
    { "id": 9, "scopeOfWork": "Roof Framing Installation", "quantity": 120, "unit": "sq.m", "category": "Roofing", "projectId": 1 },
    { "id": 10, "scopeOfWork": "Roofing Sheet Installation", "quantity": 120, "unit": "sq.m", "category": "Roofing", "projectId": 1 },
    { "id": 11, "scopeOfWork": "Door and Window Installation", "quantity": 1, "unit": "lot", "category": "Architectural", "projectId": 1 },
    { "id": 12, "scopeOfWork": "Floor Tiling", "quantity": 150, "unit": "sq.m", "category": "Architectural Finishes", "projectId": 1 },
    { "id": 13, "scopeOfWork": "Wall Tiling (T&B)", "quantity": 40, "unit": "sq.m", "category": "Architectural Finishes", "projectId": 1 },
    { "id": 14, "scopeOfWork": "Ceiling Installation", "quantity": 150, "unit": "sq.m", "category": "Architectural Finishes", "projectId": 1 },
    { "id": 15, "scopeOfWork": "Interior Painting", "quantity": 600, "unit": "sq.m", "category": "Architectural Finishes", "projectId": 1 },
    { "id": 16, "scopeOfWork": "Exterior Painting", "quantity": 300, "unit": "sq.m", "category": "Architectural Finishes", "projectId": 1 },
    { "id": 17, "scopeOfWork": "Plumbing Rough-ins", "quantity": 1, "unit": "lot", "category": "Plumbing", "projectId": 1 },
    { "id": 18, "scopeOfWork": "Electrical Rough-ins", "quantity": 1, "unit": "lot", "category": "Electrical", "projectId": 1 },
    { "id": 19, "scopeOfWork": "Plumbing and Electrical Fixtures", "quantity": 1, "unit": "lot", "category": "MEP", "projectId": 1 }
  ],
  "dupas": [
    { "id": 1, "quantityId": 1, "duration": 3, "directCosts": [{ "type": "labor", "laborType": "Laborer", "mandays": 5, "rate": 500 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 2, "quantityId": 2, "duration": 5, "directCosts": [{ "type": "labor", "laborType": "Laborer", "mandays": 10, "rate": 500 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 3, "quantityId": 3, "duration": 4, "directCosts": [{ "type": "material", "name": "Concrete Mix", "quantity": 15, "unit": "cu.m", "unitPrice": 5000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 4, "quantityId": 4, "duration": 7, "directCosts": [{ "type": "material", "name": "Concrete Mix", "quantity": 8, "unit": "cu.m", "unitPrice": 5000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 5, "quantityId": 5, "duration": 7, "directCosts": [{ "type": "material", "name": "Concrete Mix", "quantity": 12, "unit": "cu.m", "unitPrice": 5000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 6, "quantityId": 6, "duration": 5, "directCosts": [{ "type": "material", "name": "Concrete Mix", "quantity": 20, "unit": "cu.m", "unitPrice": 5000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 7, "quantityId": 7, "duration": 14, "directCosts": [{ "type": "labor", "laborType": "Mason", "mandays": 30, "rate": 550 }, { "type": "material", "name": "CHB", "quantity": 3125, "unit": "pcs", "unitPrice": 15 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 8, "quantityId": 8, "duration": 14, "directCosts": [{ "type": "labor", "laborType": "Mason", "mandays": 25, "rate": 550 }, { "type": "material", "name": "Plaster Mix", "quantity": 100, "unit": "bags", "unitPrice": 220 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 9, "quantityId": 9, "duration": 10, "directCosts": [{ "type": "labor", "laborType": "Roofer", "mandays": 15, "rate": 600 }, { "type": "material", "name": "C-Purlins", "quantity": 1, "unit": "lot", "unitPrice": 30000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 10, "quantityId": 10, "duration": 5, "directCosts": [{ "type": "labor", "laborType": "Roofer", "mandays": 10, "rate": 600 }, { "type": "material", "name": "Roof Sheets", "quantity": 120, "unit": "sq.m", "unitPrice": 450 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 11, "quantityId": 11, "duration": 7, "directCosts": [{ "type": "labor", "laborType": "Carpenter", "mandays": 12, "rate": 550 }, { "type": "material", "name": "Doors", "quantity": 8, "unit": "sets", "unitPrice": 5000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 12, "quantityId": 12, "duration": 12, "directCosts": [{ "type": "labor", "laborType": "Tile Setter", "mandays": 20, "rate": 600 }, { "type": "material", "name": "Floor Tiles", "quantity": 155, "unit": "sq.m", "unitPrice": 350 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 13, "quantityId": 13, "duration": 5, "directCosts": [{ "type": "labor", "laborType": "Tile Setter", "mandays": 8, "rate": 600 }, { "type": "material", "name": "Wall Tiles", "quantity": 42, "unit": "sq.m", "unitPrice": 380 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 14, "quantityId": 14, "duration": 7, "directCosts": [{ "type": "labor", "laborType": "Installer", "mandays": 10, "rate": 550 }, { "type": "material", "name": "Gypsum Board", "quantity": 60, "unit": "pcs", "unitPrice": 400 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 15, "quantityId": 15, "duration": 10, "directCosts": [{ "type": "labor", "laborType": "Painter", "mandays": 20, "rate": 550 }, { "type": "material", "name": "Latex Paint", "quantity": 50, "unit": "gal", "unitPrice": 800 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 16, "quantityId": 16, "duration": 8, "directCosts": [{ "type": "labor", "laborType": "Painter", "mandays": 15, "rate": 550 }, { "type": "material", "name": "Elastomeric Paint", "quantity": 30, "unit": "gal", "unitPrice": 1200 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 17, "quantityId": 17, "duration": 10, "directCosts": [{ "type": "labor", "laborType": "Plumber", "mandays": 12, "rate": 650 }, { "type": "material", "name": "PPR Pipes", "quantity": 1, "unit": "lot", "unitPrice": 25000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 18, "quantityId": 18, "duration": 10, "directCosts": [{ "type": "labor", "laborType": "Electrician", "mandays": 12, "rate": 650 }, { "type": "material", "name": "Wires and Conduits", "quantity": 1, "unit": "lot", "unitPrice": 35000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } },
    { "id": 19, "quantityId": 19, "duration": 7, "directCosts": [{ "type": "labor", "laborType": "Master Electrician", "mandays": 10, "rate": 750 }, { "type": "material", "name": "Lighting and Outlets", "quantity": 1, "unit": "lot", "unitPrice": 40000 }], "indirectCosts": { "ocm": 10, "profit": 15, "taxes": 5 } }
  ],
  "tasks": [
    { "id": 1, "projectId": 1, "predecessorId": "PROJECT_START", "successorId": 1 },
    { "id": 2, "projectId": 1, "predecessorId": 1, "successorId": 2 },
    { "id": 3, "projectId": 1, "predecessorId": 2, "successorId": 3 },
    { "id": 4, "projectId": 1, "predecessorId": 3, "successorId": 4 },
    { "id": 5, "projectId": 1, "predecessorId": 4, "successorId": 5 },
    { "id": 6, "projectId": 1, "predecessorId": 5, "successorId": 6 },
    { "id": 7, "projectId": 1, "predecessorId": 6, "successorId": 7 },
    { "id": 8, "projectId": 1, "predecessorId": 6, "successorId": 9 },
    { "id": 9, "projectId": 1, "predecessorId": 7, "successorId": 8 },
    { "id": 10, "projectId": 1, "predecessorId": 7, "successorId": 17 },
    { "id": 11, "projectId": 1, "predecessorId": 7, "successorId": 18 },
    { "id": 12, "projectId": 1, "predecessorId": 9, "successorId": 10 },
    { "id": 13, "projectId": 1, "predecessorId": 8, "successorId": 11 },
    { "id": 14, "projectId": 1, "predecessorId": 10, "successorId": 16 },
    { "id": 15, "projectId": 1, "predecessorId": 11, "successorId": 14 },
    { "id": 16, "projectId": 1, "predecessorId": 11, "successorId": 12 },
    { "id": 17, "projectId": 1, "predecessorId": 12, "successorId": 13 },
    { "id": 18, "projectId": 1, "predecessorId": 14, "successorId": 15 },
    { "id": 19, "projectId": 1, "predecessorId": 13, "successorId": 19 },
    { "id": 20, "projectId": 1, "predecessorId": 15, "successorId": 19 },
    { "id": 21, "projectId": 1, "predecessorId": 16, "successorId": 19 },
    { "id": 22, "projectId": 1, "predecessorId": 17, "successorId": 19 },
    { "id": 23, "projectId": 1, "predecessorId": 18, "successorId": 19 },
    { "id": 24, "projectId": 1, "predecessorId": 19, "successorId": "PROJECT_END" }
  ]
}
</file>

<file path="sample projects/desktop.ini">
[.ShellClassInfo]
IconResource=C:\Program Files\Google\Drive File Stream\113.0.1.0\GoogleDriveFS.exe,26
</file>

<file path="sample projects/library.json">
{
  "materials": [
    { "id": 1, "name": "Portland Cement (40kg)", "unit": "bag", "unitPrice": 255 },
    { "id": 2, "name": "Washed Sand", "unit": "cu.m", "unitPrice": 1350 },
    { "id": 3, "name": "Gravel 3/4\"", "unit": "cu.m", "unitPrice": 1450 },
    { "id": 4, "name": "Deformed Rebar 16mm", "unit": "kg", "unitPrice": 52 },
    { "id": 5, "name": "Deformed Rebar 10mm", "unit": "kg", "unitPrice": 48 },
    { "id": 6, "name": "G.I. Tie Wire #16", "unit": "kg", "unitPrice": 85 },
    { "id": 7, "name": "CHB 4\"", "unit": "pc", "unitPrice": 14 },
    { "id": 8, "name": "CHB 6\"", "unit": "pc", "unitPrice": 18 },
    { "id": 9, "name": "Phenolic Plywood 1/2\"", "unit": "sheet", "unitPrice": 950 },
    { "id": 10, "name": "Common Wire Nails", "unit": "kg", "unitPrice": 120 }
  ],
  "resources": [
    { "id": 101, "name": "Construction Foreman", "type": "labor", "unit": "manday", "rate": 850 },
    { "id": 102, "name": "Skilled Labor (Carpenter)", "type": "labor", "unit": "manday", "rate": 650 },
    { "id": 103, "name": "Skilled Labor (Mason)", "type": "labor", "unit": "manday", "rate": 650 },
    { "id": 104, "name": "Skilled Labor (Steelman)", "type": "labor", "unit": "manday", "rate": 650 },
    { "id": 105, "name": "Unskilled Labor (Laborer)", "type": "labor", "unit": "manday", "rate": 480 },
    { "id": 201, "name": "Concrete Mixer (1-Bagger)", "type": "equipment", "unit": "hour", "rate": 190 },
    { "id": 202, "name": "Concrete Vibrator", "type": "equipment", "unit": "hour", "rate": 150 },
    { "id": 203, "name": "Bar Cutter", "type": "equipment", "unit": "hour", "rate": 250 },
    { "id": 204, "name": "Bar Bender", "type": "equipment", "unit": "hour", "rate": 250 }
  ],
  "crews": [
    { "id": 51, "name": "Concrete Pouring Crew (Foundations)", "productivityRate": 5, "productivityUnit": "cu.m/day" },
    { "id": 52, "name": "Rebar Installation Crew", "productivityRate": 1000, "productivityUnit": "kg/day" },
    { "id": 53, "name": "Plastering Crew", "productivityRate": 80, "productivityUnit": "sq.m/day" }
  ],
  "crewComposition": [
    { "id": 301, "crewId": 51, "resourceId": 101, "quantity": 1 },
    { "id": 302, "crewId": 51, "resourceId": 103, "quantity": 1 },
    { "id": 303, "crewId": 51, "resourceId": 105, "quantity": 4 },
    { "id": 304, "crewId": 51, "resourceId": 201, "quantity": 1 },
    { "id": 305, "crewId": 51, "resourceId": 202, "quantity": 1 },
    { "id": 306, "crewId": 52, "resourceId": 101, "quantity": 1 },
    { "id": 307, "crewId": 52, "resourceId": 104, "quantity": 6 },
    { "id": 308, "crewId": 52, "resourceId": 203, "quantity": 1 },
    { "id": 309, "crewId": 52, "resourceId": 204, "quantity": 1 },
    { "id": 310, "crewId": 53, "resourceId": 101, "quantity": 1 },
    { "id": 311, "crewId": 53, "resourceId": 103, "quantity": 2 },
    { "id": 312, "crewId": 53, "resourceId": 105, "quantity": 2 }
  ]
}
</file>

<file path="sample projects/materials_lib.json">
{
  "materials": [
    {
      "name": "Tubular Steel 1″ x 1″ x 1.0 mm",
      "unit": "pc",
      "unitPrice": 360
    },
    {
      "name": "Tubular Steel 1″ x 1″ x 1.2 mm",
      "unit": "pc",
      "unitPrice": 420
    },
    {
      "name": "Tubular Steel 1″ x 1″ x 1.5 mm",
      "unit": "pc",
      "unitPrice": 520
    },
    {
      "name": "Tubular Steel 1″ x 2″ x 1.2 mm",
      "unit": "pc",
      "unitPrice": 620
    },
    {
      "name": "Tubular Steel 1″ x 2″ x 1.5 mm",
      "unit": "pc",
      "unitPrice": 770
    },
    {
      "name": "Tubular Steel 1″ x 2″ x 1.8 mm",
      "unit": "pc",
      "unitPrice": 920
    },
    {
      "name": "Tubular Steel 2″ x 2″ x 1.2 mm",
      "unit": "pc",
      "unitPrice": 830
    },
    {
      "name": "Tubular Steel 2″ x 2″ x 1.5 mm",
      "unit": "pc",
      "unitPrice": 1030
    },
    {
      "name": "Tubular Steel 2″ x 2″ x 1.8 mm",
      "unit": "pc",
      "unitPrice": 1230
    },
    {
      "name": "Tubular Steel 2″ x 2″ x 2.8 mm",
      "unit": "pc",
      "unitPrice": 1890
    },
    {
      "name": "Tubular Steel 2″ x 4″ x 1.5 mm",
      "unit": "pc",
      "unitPrice": 1550
    },
    {
      "name": "Tubular Steel 2″ x 4″ x 1.8 mm",
      "unit": "pc",
      "unitPrice": 1850
    },
    {
      "name": "Tubular Steel 2″ x 4″ x 2.5 mm",
      "unit": "pc",
      "unitPrice": 2550
    },
    {
      "name": "Tubular Steel 2″ x 4″ x 2.8 mm",
      "unit": "pc",
      "unitPrice": 2850
    },
    {
      "name": "Tubular Steel 2″ x 6″ x 1.8 mm",
      "unit": "pc",
      "unitPrice": 2480
    },
    {
      "name": "Tubular Steel 2″ x 6″ x 2.8 mm",
      "unit": "pc",
      "unitPrice": 3810
    },
    {
      "name": "Round Bar 10 mm",
      "unit": "pc",
      "unitPrice": 195
    },
    {
      "name": "Round Bar 12 mm",
      "unit": "pc",
      "unitPrice": 280
    },
    {
      "name": "Round Bar 16 mm",
      "unit": "pc",
      "unitPrice": 500
    },
    {
      "name": "Round Bar 20 mm",
      "unit": "pc",
      "unitPrice": 780
    },
    {
      "name": "Round Bar 25 mm",
      "unit": "pc",
      "unitPrice": 1210
    },
    {
      "name": "C-Channel 2″ x 4″",
      "unit": "pc",
      "unitPrice": 1500
    },
    {
      "name": "C-Channel 2″ x 5″",
      "unit": "pc",
      "unitPrice": 1850
    },
    {
      "name": "C-Channel 2″ x 6″",
      "unit": "pc",
      "unitPrice": 2080
    },
    {
      "name": "Deformed Rebar 10 mm x 6.0 M",
      "unit": "pc",
      "unitPrice": 200
    },
    {
      "name": "Deformed Rebar 10 mm x 7.5 M",
      "unit": "pc",
      "unitPrice": 250
    },
    {
      "name": "Deformed Rebar 10 mm x 9.0 M",
      "unit": "pc",
      "unitPrice": 300
    },
    {
      "name": "Deformed Rebar 12 mm x 6.0 M",
      "unit": "pc",
      "unitPrice": 288
    },
    {
      "name": "Deformed Rebar 12 mm x 7.5 M",
      "unit": "pc",
      "unitPrice": 360
    },
    {
      "name": "Deformed Rebar 12 mm x 9.0 M",
      "unit": "pc",
      "unitPrice": 432
    },
    {
      "name": "Deformed Rebar 16 mm x 6.0 M",
      "unit": "pc",
      "unitPrice": 512
    },
    {
      "name": "Deformed Rebar 16 mm x 7.5 M",
      "unit": "pc",
      "unitPrice": 640
    },
    {
      "name": "Deformed Rebar 16 mm x 9.0 M",
      "unit": "pc",
      "unitPrice": 768
    },
    {
      "name": "Deformed Rebar 20 mm x 6.0 M",
      "unit": "pc",
      "unitPrice": 800
    },
    {
      "name": "Deformed Rebar 20 mm x 7.5 M",
      "unit": "pc",
      "unitPrice": 1000
    },
    {
      "name": "Deformed Rebar 20 mm x 9.0 M",
      "unit": "pc",
      "unitPrice": 1200
    },
    {
      "name": "Deformed Rebar 25 mm x 6.0 M",
      "unit": "pc",
      "unitPrice": 1250
    },
    {
      "name": "Deformed Rebar 25 mm x 7.5 M",
      "unit": "pc",
      "unitPrice": 1560
    },
    {
      "name": "Deformed Rebar 25 mm x 9.0 M",
      "unit": "pc",
      "unitPrice": 1870
    }
  ],
  "resources": [],
  "crews": [],
  "crewComposition": []
}
</file>

<file path="js/dashboard.js">
// Author: Gemini
// OS support: Cross-platform
// Description: Logic for the application's main dashboard view.

let projectStatusChart = null;
let projectsGanttChart = null;

const getProjectActualPercentComplete = async (projectId) => {
    // Note: Depends on the corrected getAllTasksForReport function from the previous step
    const { allTasks, allDupas } = await getAllTasksForReport(projectId, true);
    if (allTasks.length === 0) return 0;

    const dupaMap = new Map();
    allDupas.forEach(d => {
        const key = d.quantityId || d.changeOrderItemId;
        dupaMap.set(key, d);
    });

    let totalProjectValue = 0;
    let accomplishedValue = 0;

    // We need the original quantities to correctly apportion costs for sub-tasks
    const quantities = await db.quantities.where({ projectId }).toArray();
    const parentQuantityMap = new Map(quantities.map(q => [q.id, q]));

    for (const task of allTasks) {
        let taskCost = 0;
        // Determine the cost for each type of task
        if (task.type === 'subquantity') {
            const parentDupa = dupaMap.get(task.quantityId);
            const parentQuantity = parentQuantityMap.get(task.quantityId);
            const parentTotalCost = calculateDupaTotalCost(parentDupa);
            const numSubtasks = parentQuantity?.subquantities?.length || 1;
            taskCost = parentTotalCost / numSubtasks; // Apportion the parent's cost
        } else { // For regular 'quantity' or 'changeOrderItem' tasks
            const dupa = dupaMap.get(task.id);
            taskCost = calculateDupaTotalCost(dupa);
        }
        
        totalProjectValue += taskCost;
        accomplishedValue += taskCost * ((task.percentComplete || 0) / 100);
    }

    if (totalProjectValue === 0) return 0;
    return (accomplishedValue / totalProjectValue) * 100;
};

const getProjectPlannedPercentComplete = async (project) => {
    const sCurveData = await getSCurveData(project.id, true);
    if (!sCurveData || !project.startDate) return 0;

    const today = new Date();
    const startDate = new Date(project.startDate);
    const daysElapsed = Math.floor((today - startDate) / (1000 * 60 * 60 * 24));

    if (daysElapsed < 0) return 0;
    if (daysElapsed >= sCurveData.plannedPercentage.length) return 100;
    
    return sCurveData.plannedPercentage[daysElapsed];
};

const updateDashboard = async () => {
    try {
        const allProjects = await db.projects.toArray();
        const allChangeOrders = await db.changeOrders.toArray();
        
        updateSummaryCards(allProjects, allChangeOrders);
        updateStatusChart(allProjects);
        updateAttentionList(allProjects);
        updateDashboardGanttChart(allProjects);

    } catch (error) {
        console.error("Failed to update dashboard:", error);
    }
};

const updateSummaryCards = (projects, changeOrders) => {
    const onGoingProjects = projects.filter(p => (p.projectStatus || 'On-Going') === 'On-Going');
    const completedProjects = projects.filter(p => p.projectStatus === 'Completed');
    const pendingChangeOrders = changeOrders.filter(co => co.status === 'Pending');
    const totalActiveValue = onGoingProjects.reduce((sum, p) => sum + (p.contractAmount || 0), 0);
    document.getElementById('ongoing-project-count').textContent = onGoingProjects.length;
    document.getElementById('completed-project-count').textContent = completedProjects.length;
    document.getElementById('pending-co-count').textContent = pendingChangeOrders.length;
    document.getElementById('active-contract-value').textContent = totalActiveValue.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' });
};

const updateStatusChart = (projects) => {
    const statusCounts = projects.reduce((acc, p) => {
        const status = p.projectStatus || 'On-Going';
        acc[status] = (acc[status] || 0) + 1;
        return acc;
    }, {});

    const chartCanvas = document.getElementById('project-status-chart');
    if (projectStatusChart) {
        projectStatusChart.destroy();
    }
    projectStatusChart = new Chart(chartCanvas, {
        type: 'pie',
        data: {
            labels: Object.keys(statusCounts),
            datasets: [{
                label: 'Projects',
                data: Object.values(statusCounts),
                backgroundColor: [
                    'rgba(13, 110, 253, 0.7)', 'rgba(25, 135, 84, 0.7)',
                    'rgba(255, 193, 7, 0.7)', 'rgba(108, 117, 125, 0.7)', 'rgba(220, 53, 69, 0.7)'
                ],
                borderColor: '#fff',
                borderWidth: 2
            }]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            plugins: { legend: { position: 'bottom' } }
        }
    });
};

const updateAttentionList = (projects) => {
    const attentionList = document.getElementById('attention-projects-list');
    attentionList.innerHTML = '';
    const today = new Date().toISOString().split('T')[0];
    const stalledProjects = projects.filter(p => 
        (p.projectStatus || 'On-Going') === 'On-Going' && p.targetStartDate && p.targetStartDate < today && !p.startDate 
    );
    if (stalledProjects.length === 0) {
        attentionList.innerHTML = '<li>All projects are on track! ✨</li>';
        return;
    }
    stalledProjects.forEach(p => {
        const li = document.createElement('li');
        li.innerHTML = `<strong>${p.projectName}</strong><span>Target start was ${p.targetStartDate}, but no progress has been reported.</span>`;
        attentionList.appendChild(li);
    });
};

const updateDashboardGanttChart = async (projects) => {
    const ganttContainer = document.getElementById('dashboard-gantt-chart-target');
    ganttContainer.innerHTML = '';

    const ongoingProjects = projects.filter(p =>
        (p.projectStatus || 'On-Going') === 'On-Going' && p.startDate && p.contractDuration > 0
    );

    if (ongoingProjects.length === 0) {
        ganttContainer.innerHTML = '<p style="text-align: center; color: var(--grey-color);">No active projects with a start date to display.</p>';
        return;
    }

    let tasksForGantt = [];
    for (const p of ongoingProjects) {
        const startDate = new Date(p.startDate);
        startDate.setMinutes(startDate.getMinutes() + startDate.getTimezoneOffset());
        const endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + p.contractDuration);
        const { allTasks } = await getAllTasksForReport(p.id, true);
        let overallProgress = 0;
        if(allTasks.length > 0) {
            const total = allTasks.reduce((sum, task) => sum + (task.percentComplete || 0), 0);
            overallProgress = total / allTasks.length;
        }
        tasksForGantt.push({
            id: `proj_${p.id}`,
            name: p.projectName,
            start: startDate.toISOString().split('T')[0],
            end: endDate.toISOString().split('T')[0],
            progress: overallProgress,
        });
    }
    
    const sortBy = document.getElementById('dashboard-gantt-sort').value;
    tasksForGantt.sort((a, b) => {
        if (sortBy === 'name') return a.name.localeCompare(b.name);
        if (sortBy === 'progress') return a.progress - b.progress;
        return new Date(a.start) - new Date(b.start);
    });

    projectsGanttChart = new Gantt("#dashboard-gantt-chart-target", tasksForGantt, {
        view_mode: 'Week',
        custom_popup_html: function(task) {
            return `<div class="gantt-popup-wrapper">
                <strong>${task.name}</strong>
                <p>Overall Progress: ${task.progress.toFixed(1)}%</p>
            </div>`;
        }
    });
};
function initializeDashboardModule() {
    // Add these three event listeners
    document.getElementById('dashboard-gantt-view-day').addEventListener('click', () => {
        if (projectsGanttChart) projectsGanttChart.change_view_mode('Day');
    });
    document.getElementById('dashboard-gantt-view-week').addEventListener('click', () => {
        if (projectsGanttChart) projectsGanttChart.change_view_mode('Week');
    });
    document.getElementById('dashboard-gantt-view-month').addEventListener('click', () => {
        if (projectsGanttChart) projectsGanttChart.change_view_mode('Month');
    });
}

// --- End of dashboard.js ---
</file>

<file path="js/dupa_library.js">
// js/dupa_library.js

let dupaLibraryModuleInitialized = false;

// --- DOM References ---
const resourcesTableBody = document.querySelector('#resources-table tbody');
const resourceSearchInput = document.getElementById('resource-search-input');
const addNewResourceBtn = document.getElementById('add-new-resource-btn');
const crewsTableBody = document.querySelector('#crews-table tbody');
const crewSearchInput = document.getElementById('crew-search-input');
const addNewCrewBtn = document.getElementById('add-new-crew-btn');

// --- Modal References ---
const resourceModal = document.getElementById('resource-modal');
const resourceModalTitle = document.getElementById('resource-modal-title');
const resourceModalClose = document.querySelector('.resource-modal-close');
const resourceForm = document.getElementById('resource-form');
const resourceIdInput = document.getElementById('resource-id');
const resourceNameInput = document.getElementById('resource-name');
const resourceTypeInput = document.getElementById('resource-type');
const resourceRateInput = document.getElementById('resource-rate');
const resourceUnitInput = document.getElementById('resource-unit');

const crewModal = document.getElementById('crew-modal');
const crewModalTitle = document.getElementById('crew-modal-title');
const crewModalClose = document.querySelector('.crew-modal-close');
const crewForm = document.getElementById('crew-form');
const crewIdInput = document.getElementById('crew-id');
const crewNameInput = document.getElementById('crew-name');
const crewRateInput = document.getElementById('crew-productivity-rate');
const crewUnitInput = document.getElementById('crew-productivity-unit');

const availableResourcesList = document.getElementById('available-resources-list');
const crewCompositionTableBody = document.querySelector('#crew-composition-table tbody');
const availableResourceSearch = document.getElementById('available-resource-search');

// --- Functions ---
const openResourceModal = () => resourceModal.style.display = 'block';
const closeResourceModal = () => resourceModal.style.display = 'none';
const openCrewModal = () => crewModal.style.display = 'block';
const closeCrewModal = () => crewModal.style.display = 'none';

const displayResources = async () => {
    const filter = resourceSearchInput.value.toLowerCase();
    const allResources = await db.resources.orderBy('name').toArray();
    resourcesTableBody.innerHTML = '';
    const filtered = allResources.filter(r => r.name.toLowerCase().includes(filter));
    if (filtered.length === 0) {
        resourcesTableBody.innerHTML = `<tr><td colspan="5">No resources found.</td></tr>`;
        return;
    }
    filtered.forEach(resource => {
        const row = resourcesTableBody.insertRow();
        row.innerHTML = `
            <td>${resource.name}</td>
            <td>${resource.type}</td>
            <td>${resource.rate.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td>
            <td>${resource.unit}</td>
            <td class="actions-cell">
                <button class="btn btn-warning edit-resource-btn" data-id="${resource.id}">Edit</button>
                <button class="btn btn-danger delete-resource-btn" data-id="${resource.id}">Delete</button>
            </td>
        `;
    });
};

const displayCrews = async () => {
    const filter = crewSearchInput.value.toLowerCase();
    const allCrews = await db.crews.orderBy('name').toArray();
    crewsTableBody.innerHTML = '';
    const filtered = allCrews.filter(c => c.name.toLowerCase().includes(filter));
    if (filtered.length === 0) {
        crewsTableBody.innerHTML = `<tr><td colspan="3">No crews found.</td></tr>`;
        return;
    }
    filtered.forEach(crew => {
        const row = crewsTableBody.insertRow();
        row.innerHTML = `
            <td>${crew.name}</td>
            <td>${crew.productivityRate} ${crew.productivityUnit}</td>
            <td class="actions-cell">
                <button class="btn btn-warning edit-crew-btn" data-id="${crew.id}">Edit</button>
                <button class="btn btn-danger delete-crew-btn" data-id="${crew.id}">Delete</button>
            </td>
        `;
    });
};

const openAndPopulateCrewModal = async (crewId = null) => {
    crewForm.reset();
    crewIdInput.value = '';
    crewCompositionTableBody.innerHTML = '';
    availableResourcesList.innerHTML = '';
    
    const allResources = await db.resources.orderBy('name').toArray();
    let currentResourceIds = new Set();

    if (crewId) {
        // This is an EDIT operation
        const crew = await db.crews.get(crewId);
        const currentComposition = await db.crewComposition.where({ crewId }).toArray();
        currentResourceIds = new Set(currentComposition.map(c => c.resourceId));

        crewModalTitle.textContent = 'Edit Crew';
        crewIdInput.value = crew.id;
        crewNameInput.value = crew.name;
        crewRateInput.value = crew.productivityRate;
        crewUnitInput.value = crew.productivityUnit;

        for (const comp of currentComposition) {
            const resource = allResources.find(r => r.id === comp.resourceId);
            if (resource) {
                const row = crewCompositionTableBody.insertRow();
                row.dataset.id = resource.id;
                row.innerHTML = `
                    <td>${resource.name}</td>
                    <td><input type="number" class="composition-quantity" value="${comp.quantity}" min="0.1" step="any" required></td>
                    <td><button type="button" class="btn-remove">X</button></td>
                `;
            }
        }
    } else {
        // This is an ADD operation
        crewModalTitle.textContent = 'Add New Crew';
    }
    
    // Populate available resources for both Add and Edit
    allResources
        .filter(r => !currentResourceIds.has(r.id))
        .forEach(r => {
            const li = document.createElement('li');
            li.dataset.id = r.id;
            li.innerHTML = `<span>${r.name} <i>(${r.type})</i></span><button type="button" class="btn-add-sm">+</button>`;
            availableResourcesList.appendChild(li);
        });

    openCrewModal();
};

function initializeDupaLibraryModule() {
    if (dupaLibraryModuleInitialized) return;

    // --- Resource Listeners ---
    addNewResourceBtn.addEventListener('click', () => {
        resourceModalTitle.textContent = 'Add New Resource';
        resourceForm.reset();
        resourceIdInput.value = '';
        openResourceModal();
    });
    resourceModalClose.addEventListener('click', closeResourceModal);
    resourceSearchInput.addEventListener('input', displayResources);
    resourceForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const id = resourceIdInput.value ? parseInt(resourceIdInput.value) : null;
        const data = { name: resourceNameInput.value, type: resourceTypeInput.value, rate: parseFloat(resourceRateInput.value), unit: resourceUnitInput.value };
        try {
            if (id) {
                await db.resources.update(id, data);
            } else {
                await db.resources.add(data);
            }
            closeResourceModal();
            await displayResources();
        } catch (error) {
            console.error("Failed to save resource:", error);
            alert(`Error saving resource: ${error.message}. The resource name may already exist for that type.`);
        }
    });
    resourcesTableBody.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.classList.contains('edit-resource-btn')) {
            const resource = await db.resources.get(parseInt(target.dataset.id));
            if (resource) {
                resourceModalTitle.textContent = 'Edit Resource';
                resourceIdInput.value = resource.id;
                resourceNameInput.value = resource.name;
                resourceTypeInput.value = resource.type;
                resourceRateInput.value = resource.rate;
                resourceUnitInput.value = resource.unit;
                openResourceModal();
            }
        }
        if (target.classList.contains('delete-resource-btn')) {
            const id = parseInt(target.dataset.id);
            if (confirm('Are you sure you want to delete this resource? Note: This will not remove it from existing crews.')) {
                await db.resources.delete(id);
                await displayResources();
            }
        }
    });

    // --- Crew Listeners (Unified) ---
    addNewCrewBtn.addEventListener('click', () => openAndPopulateCrewModal());
    crewModalClose.addEventListener('click', closeCrewModal);
    crewSearchInput.addEventListener('input', displayCrews);

    crewForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const id = crewIdInput.value ? parseInt(crewIdInput.value) : null;
        const crewData = { 
            name: crewNameInput.value, 
            productivityRate: parseFloat(crewRateInput.value), 
            productivityUnit: crewUnitInput.value 
        };
    
        const compositionData = [];
        crewCompositionTableBody.querySelectorAll('tr').forEach(row => {
            compositionData.push({
                resourceId: parseInt(row.dataset.id),
                quantity: parseFloat(row.querySelector('.composition-quantity').value)
            });
        });
    
        try {
            await db.transaction('rw', db.crews, db.crewComposition, async () => {
                if (id) { // Update existing crew
                    await db.crews.update(id, crewData);
                    await db.crewComposition.where({ crewId: id }).delete();
                    if (compositionData.length > 0) {
                        await db.crewComposition.bulkAdd(compositionData.map(c => ({ ...c, crewId: id })));
                    }
                } else { // Add new crew
                    const newCrewId = await db.crews.add(crewData);
                    if (compositionData.length > 0) {
                        await db.crewComposition.bulkAdd(compositionData.map(c => ({ ...c, crewId: newCrewId })));
                    }
                }
            });
            closeCrewModal();
            await displayCrews();
        } catch (error) {
            console.error("Failed to save crew:", error);
            alert(`Error saving crew: ${error.message}. The crew name may already exist.`);
        }
    });

    crewsTableBody.addEventListener('click', async (e) => {
        const target = e.target;
        if (target.classList.contains('edit-crew-btn')) {
            openAndPopulateCrewModal(parseInt(target.dataset.id));
        }
        if (target.classList.contains('delete-crew-btn')) {
            const id = parseInt(target.dataset.id);
            if (confirm('Are you sure you want to delete this crew? This will also remove its composition.')) {
                await db.transaction('rw', db.crews, db.crewComposition, async () => {
                    await db.crewComposition.where({ crewId: id }).delete();
                    await db.crews.delete(id);
                });
                await displayCrews();
            }
        }
    });
    
    availableResourcesList.addEventListener('click', async (e) => {
        if (e.target.classList.contains('btn-add-sm')) {
            const li = e.target.closest('li');
            const resourceId = parseInt(li.dataset.id);
            const resource = await db.resources.get(resourceId);
            if (resource) {
                const row = crewCompositionTableBody.insertRow();
                row.dataset.id = resource.id;
                row.innerHTML = `
                    <td>${resource.name}</td>
                    <td><input type="number" class="composition-quantity" value="1" min="0.1" step="any" required></td>
                    <td><button type="button" class="btn-remove">X</button></td>
                `;
                li.remove();
            }
        }
    });

     crewCompositionTableBody.addEventListener('click', async (e) => {
        if (e.target.classList.contains('btn-remove')) {
            const row = e.target.closest('tr');
            const resourceId = parseInt(row.dataset.id);
            const resource = await db.resources.get(resourceId);
            if (resource) {
                // Add it back to the available list
                const li = document.createElement('li');
                li.dataset.id = resource.id;
                li.innerHTML = `<span>${resource.name} <i>(${resource.type})</i></span><button type="button" class="btn-add-sm">+</button>`;
                availableResourcesList.appendChild(li);
            }
            row.remove();
        }
    });
    
    dupaLibraryModuleInitialized = true;
}
</file>

<file path="js/library_management.js">
// js/library_management.js

let libraryManagementModuleInitialized = false;
let importPreviewData = null; // Holds the parsed data for the import modal

const exportLibrary = async () => {
    try {
        const materials = await db.materials.toArray();
        const resources = await db.resources.toArray();
        const crews = await db.crews.toArray();
        const crewComposition = await db.crewComposition.toArray();

        const libraryData = { materials, resources, crews, crewComposition };

        const blob = new Blob([JSON.stringify(libraryData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `constructapp_library_export_${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(URL.createObjectURL(blob));
    } catch (error) {
        console.error("Failed to export library:", error);
        alert("An error occurred while exporting the library.");
    }
};

const processAndPreviewImport = async (data) => {
    try {
        if (!data.materials || !data.resources || !data.crews || !data.crewComposition) {
            throw new Error("Invalid library file format.");
        }

        const existingMaterials = await db.materials.toArray();
        const existingResources = await db.resources.toArray();
        const existingCrews = await db.crews.toArray();

        const existingMaterialNames = new Set(existingMaterials.map(m => m.name));
        const existingResourceKeys = new Set(existingResources.map(r => `${r.name}|${r.type}`));
        const existingCrewNames = new Set(existingCrews.map(c => c.name));

        const newMaterials = data.materials.filter(m => !existingMaterialNames.has(m.name));
        const duplicateMaterials = data.materials.filter(m => existingMaterialNames.has(m.name));

        const newResources = data.resources.filter(r => !existingResourceKeys.has(`${r.name}|${r.type}`));
        const duplicateResources = data.resources.filter(r => existingResourceKeys.has(`${r.name}|${r.type}`));

        const newCrews = data.crews.filter(c => !existingCrewNames.has(c.name));
        const duplicateCrews = data.crews.filter(c => existingCrewNames.has(c.name));

        importPreviewData = {
            newMaterials, duplicateMaterials,
            newResources, duplicateResources,
            newCrews, duplicateCrews,
            fullData: data 
        };

        const previewContentEl = document.getElementById('import-preview-content');
        let html = '';
        const createList = (title, items, nameKey = 'name') => {
            let listHtml = `<h5>${title} (${items.length})</h5>`;
            if (items.length > 0) {
                listHtml += '<ul>';
                items.forEach(item => {
                    listHtml += `<li>${item[nameKey]} ${item.type ? `(${item.type})` : ''}</li>`;
                });
                listHtml += '</ul>';
            } else {
                listHtml += '<p>None</p>';
            }
            return listHtml;
        };
        
        html += createList('New Materials', newMaterials);
        html += createList('Duplicate Materials (will be overwritten)', duplicateMaterials);
        html += '<hr>';
        html += createList('New Resources', newResources);
        html += createList('Duplicate Resources (will be overwritten)', duplicateResources);
        html += '<hr>';
        html += createList('New Crews', newCrews);
        html += createList('Duplicate Crews (will be overwritten)', duplicateCrews);
        
        previewContentEl.innerHTML = html;
        openImportPreviewModal();

    } catch (error) {
        console.error("Failed to process library file:", error);
        alert(`Failed to process library file: ${error.message}`);
    }
};

const executeImport = async (mode) => {
    if (!importPreviewData) return;

    const { newMaterials, newResources, newCrews, fullData } = importPreviewData;
    const materialsToImport = (mode === 'overwrite') ? fullData.materials : newMaterials;
    const resourcesToImport = (mode === 'overwrite') ? fullData.resources : newResources;
    const crewsToImport = (mode === 'overwrite') ? fullData.crews : newCrews;

    closeImportPreviewModal();

    try {
        await db.transaction('rw', db.materials, db.resources, db.crews, db.crewComposition, async () => {
            const stripId = (obj) => {
                const { id, ...rest } = obj;
                return rest;
            };

            if (materialsToImport.length > 0) {
                await db.materials.bulkPut(materialsToImport.map(stripId));
            }
            if (resourcesToImport.length > 0) {
                await db.resources.bulkPut(resourcesToImport.map(stripId));
            }

            const fileCrewMap = new Map(fullData.crews.map(c => [c.id, c]));
            const fileResourceMap = new Map(fullData.resources.map(r => [r.id, r]));

            const crewsToProcess = crewsToImport.map(stripId);
            if (crewsToProcess.length > 0) {
                await db.crews.bulkPut(crewsToProcess);
            }
            
            const allDbCrews = await db.crews.toArray();
            const allDbResources = await db.resources.toArray();
            const dbCrewMap = new Map(allDbCrews.map(c => [c.name, c.id]));
            const dbResourceMap = new Map(allDbResources.map(r => [`${r.name}|${r.type}`, r.id]));
            
            const importedCrewNames = new Set(crewsToImport.map(c => c.name));
            const relevantCompositions = fullData.crewComposition.filter(comp => {
                const crew = fileCrewMap.get(comp.crewId);
                return crew && importedCrewNames.has(crew.name);
            });

            const newCompositions = [];
            for (const comp of relevantCompositions) {
                const crew = fileCrewMap.get(comp.crewId);
                const resource = fileResourceMap.get(comp.resourceId);
                if (crew && resource) {
                    const newCrewId = dbCrewMap.get(crew.name);
                    const newResourceId = dbResourceMap.get(`${resource.name}|${resource.type}`);
                    if (newCrewId && newResourceId) {
                        newCompositions.push({
                            crewId: newCrewId,
                            resourceId: newResourceId,
                            quantity: comp.quantity
                        });
                    }
                }
            }
            
            if (newCompositions.length > 0) {
                const crewIdsToUpdate = newCompositions.map(c => c.crewId);
                await db.crewComposition.where('crewId').anyOf(crewIdsToUpdate).delete();
                await db.crewComposition.bulkAdd(newCompositions);
            }
        });
        alert('Library imported successfully!');
    } catch (error) {
        console.error('Error during library import:', error);
        alert(`A critical error occurred during import: ${error.message}`);
    } finally {
        importPreviewData = null;
    }
};

function initializeLibraryManagementModule() {
    if (libraryManagementModuleInitialized) return;

    const exportBtn = document.getElementById('export-library-btn');
    const importBtn = document.getElementById('import-library-btn');
    const importInput = document.getElementById('import-library-input');
    
    exportBtn.addEventListener('click', exportLibrary);
    importBtn.addEventListener('click', () => importInput.click());
    
    importInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const data = JSON.parse(e.target.result);
                await processAndPreviewImport(data);
            } catch (error) {
                console.error("Failed to import library:", error);
                alert(`Failed to parse library file: ${error.message}`);
            } finally {
                event.target.value = ''; // Reset file input
            }
        };
        reader.readAsText(file);
    });

    document.getElementById('import-cancel-btn').addEventListener('click', closeImportPreviewModal);
    document.querySelector('.import-preview-modal-close').addEventListener('click', closeImportPreviewModal);
    document.getElementById('import-proceed-duplicates-btn').addEventListener('click', () => executeImport('overwrite'));
    document.getElementById('import-proceed-new-btn').addEventListener('click', () => executeImport('new_only'));
    
    libraryManagementModuleInitialized = true;
}
</file>

<file path="js/dupa.js">
// Author: -REPLACE WITH YOUR NAME-
// OS support: -REPLACE WITH YOUR OS SUPPORT-
// Description: Logic for the DUPA module.

let dupaProjectsListDiv, dupaQuantitiesListDiv, dupaProjectName, dupaQuantityName, dupaForm, dupaQuantityIdInput, dupaIdInput, dupaDurationInput, addLaborBtn, laborTbody, addMaterialBtn, materialTbody, addEquipmentBtn, equipmentTbody, ocmPercentInput, profitPercentInput, taxesPercentInput;
let addMaterialFromLibraryBtn, addLaborFromLibraryBtn, addCrewFromLibraryBtn, addEquipmentFromLibraryBtn;
let dupaModuleInitialized = false;

const displayDupaProjects = async () => {
    const allProjects = await db.projects.orderBy('projectName').toArray();
    dupaProjectsListDiv.innerHTML = '';
    if (allProjects.length === 0) {
        dupaProjectsListDiv.innerHTML = '<p>No projects created yet. Add one in the "Projects" module first.</p>';
    } else {
        allProjects.forEach(p => {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary view-dupa-quantities-btn" data-id="${p.id}" data-name="${p.projectName}">Select</button>`;
            dupaProjectsListDiv.appendChild(item);
        });
    }
};

const displayDupaQuantities = async () => {
    const quantities = await db.quantities.where('projectId').equals(currentDupaProjectId).toArray();
    dupaQuantitiesListDiv.innerHTML = '';
    if (quantities.length === 0) {
        dupaQuantitiesListDiv.innerHTML = "<p>No quantities found for this project.</p>";
        return;
    }
    const grouped = quantities.reduce((acc, q) => {
        const category = q.category || 'Uncategorized';
        if (!acc[category]) { acc[category] = []; }
        acc[category].push(q);
        return acc;
    }, {});
    const sortedCategories = Object.keys(grouped).sort();
    for (const category of sortedCategories) {
        const header = document.createElement('h3');
        header.className = 'dupa-category-header';
        header.textContent = category;
        dupaQuantitiesListDiv.appendChild(header);
        grouped[category].forEach(q => {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.innerHTML = `<h3>${q.scopeOfWork}</h3><button class="btn btn-primary show-dupa-form-btn" data-id="${q.id}" data-name="${q.scopeOfWork}">Show DUPA</button>`;
            dupaQuantitiesListDiv.appendChild(item);
        });
    }
};

const showDupaQuantitiesForProject = async (projectId, projectName) => {
    currentDupaProjectId = projectId;
    dupaProjectName.textContent = projectName;
    dupaProjectListView.classList.add('hidden');
    dupaFormView.classList.add('hidden');
    dupaQuantityListView.classList.remove('hidden');
    await displayDupaQuantities();
};

const addLaborRow = (data = {}) => {
    const row = laborTbody.insertRow();
    row.innerHTML = `<td><input type="text" class="labor-type" value="${data.laborType || ''}" required></td><td><input type="number" class="labor-mandays" value="${data.mandays || ''}" step="any" min="0" required></td><td><input type="number" class="labor-rate" value="${data.rate || ''}" step="any" min="0" required></td><td class="row-total" style="text-align:right;"></td><td><button type="button" class="btn-remove">X</button></td>`;
};

const addMaterialRow = (data = {}) => {
    const row = materialTbody.insertRow();
    row.innerHTML = `<td><input type="text" class="material-name" value="${data.name || ''}" required></td><td><input type="number" class="material-qty" value="${data.quantity || ''}" step="any" min="0" required></td><td><input type="text" class="material-unit" value="${data.unit || ''}" required></td><td><input type="number" class="material-price" value="${data.unitPrice || ''}" step="any" min="0" required></td><td class="row-total" style="text-align:right;"></td><td><button type="button" class="btn-remove">X</button></td>`;
};

const addEquipmentRow = (data = {}) => {
    const row = equipmentTbody.insertRow();
    row.innerHTML = `<td><input type="text" class="equipment-name" value="${data.name || ''}" required></td><td><input type="number" class="equipment-hours" value="${data.hours || ''}" step="any" min="0" required></td><td><input type="number" class="equipment-rate" value="${data.rate || ''}" step="any" min="0" required></td><td class="row-total" style="text-align:right;"></td><td><button type="button" class="btn-remove">X</button></td>`;
};

const calculateAndDisplayDupaTotals = async () => {
    const formatCurrency = (value) => value.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' });

    let laborSubtotal = 0;
    document.querySelectorAll('#labor-tbody tr').forEach(row => {
        const mandays = parseFloat(row.querySelector('.labor-mandays').value) || 0;
        const rate = parseFloat(row.querySelector('.labor-rate').value) || 0;
        const rowTotal = mandays * rate;
        laborSubtotal += rowTotal;
        row.querySelector('.row-total').textContent = formatCurrency(rowTotal);
    });
    document.getElementById('labor-subtotal').textContent = formatCurrency(laborSubtotal);

    let materialSubtotal = 0;
    document.querySelectorAll('#material-tbody tr').forEach(row => {
        const qty = parseFloat(row.querySelector('.material-qty').value) || 0;
        const price = parseFloat(row.querySelector('.material-price').value) || 0;
        const rowTotal = qty * price;
        materialSubtotal += rowTotal;
        row.querySelector('.row-total').textContent = formatCurrency(rowTotal);
    });
    document.getElementById('material-subtotal').textContent = formatCurrency(materialSubtotal);

    let equipmentSubtotal = 0;
    document.querySelectorAll('#equipment-tbody tr').forEach(row => {
        const hours = parseFloat(row.querySelector('.equipment-hours').value) || 0;
        const rate = parseFloat(row.querySelector('.equipment-rate').value) || 0;
        const rowTotal = hours * rate;
        equipmentSubtotal += rowTotal;
        row.querySelector('.row-total').textContent = formatCurrency(rowTotal);
    });
    document.getElementById('equipment-subtotal').textContent = formatCurrency(equipmentSubtotal);

    const totalDirectCost = laborSubtotal + materialSubtotal + equipmentSubtotal;
    document.getElementById('total-direct-cost-summary').textContent = formatCurrency(totalDirectCost);

    const ocmPercent = parseFloat(ocmPercentInput.value) || 0;
    const profitPercent = parseFloat(profitPercentInput.value) || 0;
    const taxesPercent = parseFloat(taxesPercentInput.value) || 0;

    const ocmAmount = totalDirectCost * (ocmPercent / 100);
    const profitAmount = totalDirectCost * (profitPercent / 100);
    const totalIndirectCost = ocmAmount + profitAmount;
    const subtotalBeforeTax = totalDirectCost + totalIndirectCost;
    const taxAmount = subtotalBeforeTax * (taxesPercent / 100);
    const grandTotal = subtotalBeforeTax + taxAmount;

    document.getElementById('ocm-amount').textContent = formatCurrency(ocmAmount);
    document.getElementById('profit-amount').textContent = formatCurrency(profitAmount);
    document.getElementById('tax-amount').textContent = formatCurrency(taxAmount);
    document.getElementById('total-indirect-cost-summary').textContent = formatCurrency(totalIndirectCost + taxAmount);
    
    document.getElementById('summary-grand-total').textContent = formatCurrency(grandTotal);
    
    const quantityId = parseInt(dupaQuantityIdInput.value);
    if (quantityId) {
        const quantityItem = await db.quantities.get(quantityId);
        const quantity = quantityItem ? quantityItem.quantity : 0;
        document.getElementById('summary-quantity').textContent = `${quantity.toLocaleString()} ${quantityItem ? quantityItem.unit : ''}`;
        const unitPrice = quantity > 0 ? grandTotal / quantity : 0;
        document.getElementById('summary-unit-price').textContent = formatCurrency(unitPrice);
    } else {
        document.getElementById('summary-quantity').textContent = 'N/A';
        document.getElementById('summary-unit-price').textContent = formatCurrency(0);
    }
};

const showDupaFormForQuantity = async (quantityId, quantityName) => {
    currentDupaQuantityId = quantityId;
    dupaQuantityName.textContent = `DUPA for: ${quantityName}`;
    dupaQuantityListView.classList.add('hidden');
    dupaFormView.classList.remove('hidden');
    laborTbody.innerHTML = '';
    materialTbody.innerHTML = '';
    equipmentTbody.innerHTML = '';
    dupaForm.reset();
    dupaQuantityIdInput.value = quantityId;

    const lockedBoq = await db.boqs.get({ projectId: currentDupaProjectId });
    const isLocked = !!lockedBoq;

    const existingDupa = await db.dupas.where({ quantityId: quantityId }).first();
    if (existingDupa) {
        dupaIdInput.value = existingDupa.id;
        dupaDurationInput.value = existingDupa.duration;
        (existingDupa.directCosts || []).forEach(item => {
            if (item.type === 'labor') addLaborRow(item);
            if (item.type === 'material') addMaterialRow(item);
            if (item.type === 'equipment') addEquipmentRow(item);
        });
        ocmPercentInput.value = existingDupa.indirectCosts.ocm;
        profitPercentInput.value = existingDupa.indirectCosts.profit;
        taxesPercentInput.value = existingDupa.indirectCosts.taxes;
    } else {
        dupaIdInput.value = '';
    }

    Array.from(dupaForm.elements).forEach(element => {
        element.disabled = isLocked;
    });
    
    await calculateAndDisplayDupaTotals();
};

const addCrewToDupa = async (crew, multiplier) => {
    try {
        const quantityId = parseInt(dupaQuantityIdInput.value);
        const quantity = await db.quantities.get(quantityId);
        
        if (!quantity || crew.productivityRate <= 0) {
            alert("Cannot calculate crew mandays. Ensure the DUPA quantity and crew productivity are set and greater than zero.");
            return;
        }

        const taskDurationDays = quantity.quantity / crew.productivityRate;
        
        const composition = await db.crewComposition.where({ crewId: crew.id }).toArray();
        const resourceIds = composition.map(c => c.resourceId);
        if (resourceIds.length === 0) {
            alert("This crew has no resources assigned to it.");
            return;
        }

        const resources = await db.resources.where('id').anyOf(resourceIds).toArray();
        const resourceMap = new Map(resources.map(r => [r.id, r]));

        composition.forEach(comp => {
            const resource = resourceMap.get(comp.resourceId);
            if (resource) {
                if (resource.type === 'labor') {
                    const mandays = taskDurationDays * comp.quantity * multiplier;
                    addLaborRow({ laborType: resource.name, mandays: mandays.toFixed(2), rate: resource.rate });
                } else if (resource.type === 'equipment') {
                    const hours = taskDurationDays * 8 * comp.quantity * multiplier; 
                    addEquipmentRow({ name: resource.name, hours: hours.toFixed(2), rate: resource.rate });
                }
            }
        });
        await calculateAndDisplayDupaTotals();
    } catch (error) {
        console.error("Error adding crew to DUPA:", error);
        alert("An error occurred while calculating crew composition.");
    }
};

function initializeDupaModule() {
    if (dupaModuleInitialized) return;

    dupaProjectsListDiv = document.getElementById('dupa-projects-list');
    dupaQuantitiesListDiv = document.getElementById('dupa-quantities-list');
    dupaProjectName = document.getElementById('dupa-project-name');
    dupaQuantityName = document.getElementById('dupa-quantity-name');
    dupaForm = document.getElementById('dupa-form');
    dupaQuantityIdInput = document.getElementById('dupaQuantityId');
    dupaIdInput = document.getElementById('dupaId');
    dupaDurationInput = document.getElementById('dupaDuration');
    addLaborBtn = document.getElementById('add-labor-btn');
    laborTbody = document.getElementById('labor-tbody');
    addMaterialBtn = document.getElementById('add-material-btn');
    materialTbody = document.getElementById('material-tbody');
    addEquipmentBtn = document.getElementById('add-equipment-btn');
    equipmentTbody = document.getElementById('equipment-tbody');
    ocmPercentInput = document.getElementById('ocmPercent');
    profitPercentInput = document.getElementById('profitPercent');
    taxesPercentInput = document.getElementById('taxesPercent');
    addMaterialFromLibraryBtn = document.getElementById('add-material-from-library-btn');
    addLaborFromLibraryBtn = document.getElementById('add-labor-from-library-btn');
    addCrewFromLibraryBtn = document.getElementById('add-crew-from-library-btn');
    addEquipmentFromLibraryBtn = document.getElementById('add-equipment-from-library-btn');

    addLaborBtn.addEventListener('click', () => addLaborRow());
    addMaterialBtn.addEventListener('click', () => addMaterialRow());
    addEquipmentBtn.addEventListener('click', () => addEquipmentRow());

    addMaterialFromLibraryBtn.addEventListener('click', async () => {
        const materials = await db.materials.orderBy('name').toArray();
        openLibraryPicker({
            title: 'Select Material from Library',
            dataSource: materials,
            onSelect: (item) => { 
                addMaterialRow({ name: item.name, unit: item.unit, unitPrice: item.unitPrice });
                calculateAndDisplayDupaTotals();
            },
            searchKeys: ['name'],
            isCrewPicker: false
        });
    });

    addLaborFromLibraryBtn.addEventListener('click', async () => {
        const labor = await db.resources.where('type').equals('labor').sortBy('name');
        openLibraryPicker({
            title: 'Select Labor from Library',
            dataSource: labor,
            onSelect: (item) => {
                addLaborRow({ laborType: item.name, rate: item.rate });
                calculateAndDisplayDupaTotals();
            },
            searchKeys: ['name'],
            isCrewPicker: false
        });
    });

    addEquipmentFromLibraryBtn.addEventListener('click', async () => {
        const equipment = await db.resources.where('type').equals('equipment').sortBy('name');
        openLibraryPicker({
            title: 'Select Equipment from Library',
            dataSource: equipment,
            onSelect: (item) => {
                addEquipmentRow({ name: item.name, rate: item.rate });
                calculateAndDisplayDupaTotals();
            },
            searchKeys: ['name'],
            isCrewPicker: false
        });
    });

    addCrewFromLibraryBtn.addEventListener('click', async () => {
        const crews = await db.crews.orderBy('name').toArray();
        openLibraryPicker({
            title: 'Select Crew from Library',
            dataSource: crews,
            onSelect: (item, multiplier) => addCrewToDupa(item, multiplier),
            searchKeys: ['name'],
            isCrewPicker: true
        });
    });

    dupaView.addEventListener('click', (e) => {
        if (e.target.classList.contains('view-dupa-quantities-btn')) { showDupaQuantitiesForProject(parseInt(e.target.dataset.id), e.target.dataset.name); }
        if (e.target.classList.contains('show-dupa-form-btn')) { showDupaFormForQuantity(parseInt(e.target.dataset.id), e.target.dataset.name); }
        if (e.target.classList.contains('btn-remove')) { 
            e.target.closest('tr').remove();
            calculateAndDisplayDupaTotals();
        }
    });
    
    dupaForm.addEventListener('input', calculateAndDisplayDupaTotals);

    dupaForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const directCosts = [];
        laborTbody.querySelectorAll('tr').forEach(row => directCosts.push({ type: 'labor', laborType: row.querySelector('.labor-type').value, mandays: parseFloat(row.querySelector('.labor-mandays').value), rate: parseFloat(row.querySelector('.labor-rate').value) }));
        materialTbody.querySelectorAll('tr').forEach(row => directCosts.push({ type: 'material', name: row.querySelector('.material-name').value, quantity: parseFloat(row.querySelector('.material-qty').value), unit: row.querySelector('.material-unit').value, unitPrice: parseFloat(row.querySelector('.material-price').value) }));
        equipmentTbody.querySelectorAll('tr').forEach(row => directCosts.push({ type: 'equipment', name: row.querySelector('.equipment-name').value, hours: parseFloat(row.querySelector('.equipment-hours').value), rate: parseFloat(row.querySelector('.equipment-rate').value) }));
        const dupaData = {
            quantityId: parseInt(dupaQuantityIdInput.value),
            duration: parseInt(dupaDurationInput.value),
            directCosts: directCosts,
            indirectCosts: { ocm: parseFloat(ocmPercentInput.value) || 0, profit: parseFloat(profitPercentInput.value) || 0, taxes: parseFloat(taxesPercentInput.value) || 0 }
        };
        if (dupaIdInput.value) { dupaData.id = parseInt(dupaIdInput.value); }
        await db.dupas.put(dupaData);
        alert('DUPA saved successfully!');
        showDupaQuantitiesForProject(currentDupaProjectId, dupaProjectName.textContent);
    });

    dupaModuleInitialized = true;
}
</file>

<file path="js/projects.js">
// Author: -REPLACE WITH YOUR NAME-
// OS support: -REPLACE WITH YOUR OS SUPPORT-
// Description: Logic for the Projects module.

const lotAreaInput = document.getElementById('lotArea');
const floorAreaInput = document.getElementById('floorArea');
const numFloorsInput = document.getElementById('numFloors');
const contractAmountInput = document.getElementById('contractAmount');
const contractDateInput = document.getElementById('contractDate');
const projectStatusInput = document.getElementById('projectStatus');
const targetStartDateInput = document.getElementById('targetStartDate');
const contractDurationInput = document.getElementById('contractDuration');
const projectManagerInput = document.getElementById('projectManager');
const clientContactInput = document.getElementById('clientContact');
const addProjectBtn = document.getElementById('add-project-btn');
const copyProjectBtn = document.getElementById('copy-project-btn');
const copyProjectModal = document.getElementById('copy-project-modal');
const copyProjectModalClose = document.querySelector('.copy-project-modal-close');
const copyProjectForm = document.getElementById('copy-project-form');
const sourceProjectSelect = document.getElementById('source-project-select');
const newProjectNameInputCopy = document.getElementById('new-project-name-copy');
const importProjectBtn = document.getElementById('import-project-btn');
const importProjectInput = document.getElementById('import-project-input');
const projectModal = document.getElementById('project-modal');
const projectModalClose = document.querySelector('.project-modal-close');
const projectForm = document.getElementById('project-form');
const projectsTableBody = document.querySelector('#projects-table tbody');
const projectModalTitle = document.getElementById('modal-title');
const projectIdInput = document.getElementById('projectId');
const projectNameInput = document.getElementById('projectName');
const projectAddressInput = document.getElementById('projectAddress');
const clientNameInput = document.getElementById('clientName');
const projectDescriptionInput = document.getElementById('projectDescription');

let projectsModuleInitialized = false;

const openProjectModal = () => projectModal.style.display = 'block';
const closeProjectModal = () => projectModal.style.display = 'none';
const openCopyProjectModal = () => copyProjectModal.style.display = 'block';
const closeCopyProjectModal = () => copyProjectModal.style.display = 'none';

const showProjectSummary = async (projectId) => {
    try {
        const project = await db.projects.get(projectId);
        if (!project) {
            alert('Project details not found.');
            return;
        }

        // Switch to the summary view
        showView(projectSummaryView);

        // Populate all the fields on the summary page
        document.getElementById('summary-project-name').textContent = project.projectName;
        document.getElementById('summary-client-name').textContent = project.clientName || 'N/A';
        document.getElementById('summary-address').textContent = project.address || 'N/A';
        document.getElementById('summary-status').textContent = project.projectStatus || 'N/A';
        document.getElementById('summary-project-manager').textContent = project.projectManager || 'N/A';
        document.getElementById('summary-client-contact').textContent = project.clientContact || 'N/A';
        document.getElementById('summary-contract-amount').textContent = project.contractAmount ? project.contractAmount.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' }) : 'N/A';
        document.getElementById('summary-contract-date').textContent = project.contractDate || 'N/A';
        document.getElementById('summary-target-start').textContent = project.targetStartDate || 'N/A';
        document.getElementById('summary-duration').textContent = project.contractDuration ? `${project.contractDuration} days` : 'N/A';
        document.getElementById('summary-lot-area').textContent = project.lotArea ? `${project.lotArea} m²` : 'N/A';
        document.getElementById('summary-floor-area').textContent = project.floorArea ? `${project.floorArea} m²` : 'N/A';
        document.getElementById('summary-floors').textContent = project.numFloors || 'N/A';
        document.getElementById('summary-description').textContent = project.projectDescription || 'No description provided.';

    } catch (error) {
        console.error('Failed to show project summary:', error);
        alert('An error occurred while trying to load the project summary.');
    }
};

const exportProject = async (projectId) => {
    try {
        // Fetch all 9 data categories for the project
        const project = await db.projects.get(projectId);
        if (!project) {
            alert('Project not found.');
            return;
        }
        const quantities = await db.quantities.where({ projectId }).toArray();
        const quantityIds = quantities.map(q => q.id);

        const dupas = quantityIds.length > 0 ? await db.dupas.where('quantityId').anyOf(quantityIds).toArray() : [];
        const tasks = await db.tasks.where({ projectId }).toArray();
        const boq = await db.boqs.where({ projectId }).first();
        const accomplishments = quantityIds.length > 0 ? await db.accomplishments.where('quantityId').anyOf(quantityIds).toArray() : [];
        const changeOrders = await db.changeOrders.where({ projectId }).toArray();
        const changeOrderIds = changeOrders.map(co => co.id);

        const changeOrderItems = changeOrderIds.length > 0 ? await db.changeOrderItems.where('changeOrderId').anyOf(changeOrderIds).toArray() : [];
        const changeOrderItemIds = changeOrderItems.map(item => item.id);
        
        const changeOrderDupas = changeOrderItemIds.length > 0 ? await db.changeOrderDupas.where('changeOrderItemId').anyOf(changeOrderItemIds).toArray() : [];

        // Bundle everything into one object
        const exportData = { 
            project, 
            quantities, 
            dupas, 
            tasks, 
            boq, 
            accomplishments, 
            changeOrders, 
            changeOrderItems, 
            changeOrderDupas 
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${project.projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    } catch (error) {
        console.error('Failed to export project:', error);
        alert('An error occurred while exporting the project.');
    }
};

const importProjectData = async (data) => {
    if (!data.project || !data.quantities) {
        alert('Invalid project file format.');
        throw new Error('Invalid project file format.');
    }
    const newProjectName = prompt('Please enter a name for the imported project:', `Copy of ${data.project.projectName}`);
    if (!newProjectName) {
        alert('Import cancelled.');
        return;
    }
    data.project.projectName = newProjectName;
    delete data.project.id;

    const allTables = db.tables.map(t => t.name);

    try {
        await db.transaction('rw', allTables, async () => {
            // ID maps to relink everything
            const quantityIdMap = new Map();
            const changeOrderIdMap = new Map();
            const changeOrderItemIdMap = new Map();

            // 1. Project
            const newProjectId = await db.projects.add(data.project);

            // 2. Quantities
            if (data.quantities && data.quantities.length > 0) {
                for (const q of data.quantities) {
                    const oldId = q.id;
                    delete q.id;
                    q.projectId = newProjectId;
                    const newId = await db.quantities.add(q);
                    quantityIdMap.set(oldId, newId);
                }
            }

            // 3. Dupas & 6. Accomplishments
            if (data.dupas && data.dupas.length > 0) {
                const newDupas = data.dupas.map(d => ({ ...d, id: undefined, quantityId: quantityIdMap.get(d.quantityId) }));
                await db.dupas.bulkAdd(newDupas);
            }
            if (data.accomplishments && data.accomplishments.length > 0) {
                const newAccomplishments = data.accomplishments.map(a => ({ ...a, id: undefined, quantityId: quantityIdMap.get(a.quantityId) }));
                await db.accomplishments.bulkAdd(newAccomplishments);
            }
            
            // 4. Tasks (Sequencing)
            if (data.tasks && data.tasks.length > 0) {
                const newTasks = data.tasks.map(t => ({
                    ...t,
                    id: undefined,
                    projectId: newProjectId,
                    predecessorId: typeof t.predecessorId === 'number' ? quantityIdMap.get(t.predecessorId) : t.predecessorId,
                    successorId: typeof t.successorId === 'number' ? quantityIdMap.get(t.successorId) : t.successorId,
                }));
                await db.tasks.bulkAdd(newTasks);
            }
            
            // 5. BOQ
            if (data.boq) {
                delete data.boq.id;
                data.boq.projectId = newProjectId;
                await db.boqs.add(data.boq);
            }
            
            // 7. Change Orders
            if (data.changeOrders && data.changeOrders.length > 0) {
                 for (const co of data.changeOrders) {
                    const oldId = co.id;
                    delete co.id;
                    co.projectId = newProjectId;
                    const newId = await db.changeOrders.add(co);
                    changeOrderIdMap.set(oldId, newId);
                }
            }
            
            // 8. Change Order Items
            if (data.changeOrderItems && data.changeOrderItems.length > 0) {
                for (const item of data.changeOrderItems) {
                    const oldId = item.id;
                    delete item.id;
                    item.changeOrderId = changeOrderIdMap.get(item.changeOrderId);
                    if (item.originalQuantityId) {
                        item.originalQuantityId = quantityIdMap.get(item.originalQuantityId);
                    }
                    const newId = await db.changeOrderItems.add(item);
                    changeOrderItemIdMap.set(oldId, newId);
                }
            }

            // 9. Change Order Dupas
            if (data.changeOrderDupas && data.changeOrderDupas.length > 0) {
                const newCoDupas = data.changeOrderDupas.map(d => ({ ...d, id: undefined, changeOrderItemId: changeOrderItemIdMap.get(d.changeOrderItemId) }));
                await db.changeOrderDupas.bulkAdd(newCoDupas);
            }
        });
        alert('Project imported successfully!');
        await displayProjects();
    } catch (error) {
        console.error('Error during project import transaction:', error);
        alert('A critical error occurred during the import process. The operation has been rolled back.');
    }
};

const displayProjects = async () => {
    const allProjects = await db.projects.orderBy('projectName').toArray();
    projectsTableBody.innerHTML = '';
    if (allProjects.length === 0) {
        projectsTableBody.innerHTML = '<tr><td colspan="3">No projects found.</td></tr>';
    } else {
        allProjects.forEach(p => {
            const r = projectsTableBody.insertRow();
            r.innerHTML = `
                <td>${p.projectName}</td>
                <td>${p.projectStatus || 'N/A'}</td>
                <td class="actions-cell">
                    <button class="btn btn-primary summary-btn" data-id="${p.id}">Summary</button>
                    <button class="btn btn-warning edit-btn" data-id="${p.id}">Edit</button>
                    <button class="btn btn-secondary export-btn" data-id="${p.id}">Export</button>
                    <button class="btn btn-danger delete-btn" data-id="${p.id}">Delete</button>
                </td>`;
        });
    }
};

function initializeProjectsModule() {
    if (projectsModuleInitialized) return;

    addProjectBtn.addEventListener('click', () => {
        projectModalTitle.textContent = 'Add New Project';
        projectForm.reset();
        projectIdInput.value = '';
        openProjectModal();
    });

    projectModalClose.addEventListener('click', closeProjectModal);
    
    copyProjectBtn.addEventListener('click', async () => {
        const allProjects = await db.projects.orderBy('projectName').toArray();
        sourceProjectSelect.innerHTML = '<option value="">-- Select a Project --</option>';
        allProjects.forEach(p => {
            sourceProjectSelect.innerHTML += `<option value="${p.id}">${p.projectName}</option>`;
        });
        copyProjectForm.reset();
        openCopyProjectModal();
    });

    copyProjectModalClose.addEventListener('click', closeCopyProjectModal);
    
    copyProjectForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const sourceProjectId = parseInt(sourceProjectSelect.value);
        const newProjectName = newProjectNameInputCopy.value.trim();

        if (!sourceProjectId || !newProjectName) {
            alert('Please select a source project and provide a new name.');
            return;
        }

        const allTables = db.tables.map(t => t.name);

        try {
            await db.transaction('rw', allTables, async () => {
                const sourceProject = await db.projects.get(sourceProjectId);
                const quantities = await db.quantities.where({ projectId: sourceProjectId }).toArray();
                const quantityIds = quantities.map(q => q.id);
                
                const accomplishments = quantityIds.length > 0 ? await db.accomplishments.where('type').equals('quantity').and(record => quantityIds.includes(record.taskId)).toArray() : [];
                const dupas = quantityIds.length > 0 ? await db.dupas.where('quantityId').anyOf(quantityIds).toArray() : [];
                const tasks = await db.tasks.where({ projectId: sourceProjectId }).toArray();
                const boq = await db.boqs.where({ projectId: sourceProjectId }).first();
                const changeOrders = await db.changeOrders.where({ projectId: sourceProjectId }).toArray();
                const changeOrderIds = changeOrders.map(co => co.id);
                const changeOrderItems = changeOrderIds.length > 0 ? await db.changeOrderItems.where('changeOrderId').anyOf(changeOrderIds).toArray() : [];
                const changeOrderItemIds = changeOrderItems.map(item => item.id);
                const changeOrderDupas = changeOrderItemIds.length > 0 ? await db.changeOrderDupas.where('changeOrderItemId').anyOf(changeOrderItemIds).toArray() : [];

                const quantityIdMap = new Map();
                const changeOrderIdMap = new Map();
                const changeOrderItemIdMap = new Map();

                const newProjectData = { ...sourceProject, id: undefined, projectName: newProjectName };
                const newProjectId = await db.projects.add(newProjectData);

                for (const q of quantities) {
                    const oldId = q.id;
                    const newId = await db.quantities.add({ ...q, id: undefined, projectId: newProjectId });
                    quantityIdMap.set(oldId, newId);
                }

                if (dupas.length > 0) await db.dupas.bulkAdd(dupas.map(d => ({ ...d, id: undefined, quantityId: quantityIdMap.get(d.quantityId) })));
                
                if (accomplishments.length > 0) {
                    await db.accomplishments.bulkAdd(accomplishments.map(a => ({
                        ...a,
                        id: undefined,
                        taskId: quantityIdMap.get(a.taskId)
                    })));
                }
                
                if (tasks.length > 0) {
                    await db.tasks.bulkAdd(tasks.map(t => ({
                        ...t,
                        id: undefined,
                        projectId: newProjectId,
                        predecessorId: typeof t.predecessorId === 'number' ? quantityIdMap.get(t.predecessorId) : t.predecessorId,
                        successorId: typeof t.successorId === 'number' ? quantityIdMap.get(t.successorId) : t.successorId,
                    })));
                }
                
                if (boq) await db.boqs.add({ ...boq, id: undefined, projectId: newProjectId });
                
                for (const co of changeOrders) {
                    const oldId = co.id;
                    const newId = await db.changeOrders.add({ ...co, id: undefined, projectId: newProjectId });
                    changeOrderIdMap.set(oldId, newId);
                }
                
                for (const item of changeOrderItems) {
                    const oldId = item.id;
                    const newItemData = {
                        ...item,
                        id: undefined,
                        changeOrderId: changeOrderIdMap.get(item.changeOrderId)
                    };
                    if (item.originalQuantityId) {
                        newItemData.originalQuantityId = quantityIdMap.get(item.originalQuantityId);
                    }
                    const newId = await db.changeOrderItems.add(newItemData);
                    changeOrderItemIdMap.set(oldId, newId);
                }

                if (changeOrderDupas.length > 0) await db.changeOrderDupas.bulkAdd(changeOrderDupas.map(d => ({ ...d, id: undefined, changeOrderItemId: changeOrderItemIdMap.get(d.changeOrderItemId) })));
            });
            alert('Project copied successfully!');
            closeCopyProjectModal();
            await displayProjects();
        } catch (error) {
            console.error('Failed to copy project:', error);
            alert('An error occurred while copying the project.');
        }
    });

    importProjectBtn.addEventListener('click', () => {
        importProjectInput.click();
    });

    importProjectInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const data = JSON.parse(e.target.result);
                await importProjectData(data);
            } catch (error) {
                console.error('Failed to import project:', error);
                alert('Failed to parse project file. Please ensure it is a valid project JSON file.');
            }
        };
        reader.readAsText(file);
        event.target.value = '';
    });

    projectForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const id = parseInt(projectIdInput.value);
        const projectData = {
            projectName: projectNameInput.value,
            address: projectAddressInput.value,
            clientName: clientNameInput.value,
            projectDescription: projectDescriptionInput.value,
            lotArea: lotAreaInput.value ? parseFloat(lotAreaInput.value) : null,
            floorArea: floorAreaInput.value ? parseFloat(floorAreaInput.value) : null,
            numFloors: numFloorsInput.value ? parseInt(numFloorsInput.value) : null,
            contractAmount: contractAmountInput.value ? parseFloat(contractAmountInput.value) : null,
            contractDate: contractDateInput.value || null,
            projectStatus: projectStatusInput.value || null,
            targetStartDate: targetStartDateInput.value || null,
            contractDuration: contractDurationInput.value ? parseInt(contractDurationInput.value) : null,
            projectManager: projectManagerInput.value || null,
            clientContact: clientContactInput.value || null,
        };
        if (id) await db.projects.update(id, projectData);
        else await db.projects.add(projectData);
        closeProjectModal();
        await displayProjects();
    });

    projectsTableBody.addEventListener('click', async (event) => {
    const target = event.target;
    if (!target.dataset.id) return;
    const id = parseInt(target.dataset.id);

    if (target.classList.contains('summary-btn')) {
        showProjectSummary(id);
    }
    if (target.classList.contains('edit-btn')) {
        const p = await db.projects.get(id);
        projectModalTitle.textContent = 'Edit Project';
        projectIdInput.value = p.id;
        projectNameInput.value = p.projectName;
        projectAddressInput.value = p.address;
        clientNameInput.value = p.clientName;
        projectDescriptionInput.value = p.projectDescription;
        lotAreaInput.value = p.lotArea || '';
        floorAreaInput.value = p.floorArea || '';
        numFloorsInput.value = p.numFloors || '';
        contractAmountInput.value = p.contractAmount || '';
        contractDateInput.value = p.contractDate || '';
        projectStatusInput.value = p.projectStatus || 'On-Going';
        targetStartDateInput.value = p.targetStartDate || '';
        contractDurationInput.value = p.contractDuration || '';
        projectManagerInput.value = p.projectManager || '';
        clientContactInput.value = p.clientContact || '';
        openProjectModal();
    }
    if (target.classList.contains('delete-btn')) {
        if (confirm('Are you sure you want to permanently delete this project and ALL of its associated data (quantities, reports, change orders, progress, etc.)? This action cannot be undone.')) {
            try {
                await db.transaction('rw', db.tables.map(t => t.name), async () => {
                    const quantities = await db.quantities.where({ projectId: id }).toArray();
                    const quantityIds = quantities.map(q => q.id);
                    
                    const changeOrders = await db.changeOrders.where({ projectId: id }).toArray();
                    const changeOrderIds = changeOrders.map(co => co.id);
                    
                    let changeOrderItemIds = [];
                    if (changeOrderIds.length > 0) {
                        const changeOrderItems = await db.changeOrderItems.where('changeOrderId').anyOf(changeOrderIds).toArray();
                        changeOrderItemIds = changeOrderItems.map(item => item.id);
                    }

                    if (quantityIds.length > 0) {
                        await db.accomplishments.where('type').equals('quantity').and(record => quantityIds.includes(record.taskId)).delete();
                        await db.dupas.where('quantityId').anyOf(quantityIds).delete();
                    }
                    if (changeOrderItemIds.length > 0) {
                        await db.changeOrderDupas.where('changeOrderItemId').anyOf(changeOrderItemIds).delete();
                    }
                    if (changeOrderIds.length > 0) {
                        await db.changeOrderItems.where('changeOrderId').anyOf(changeOrderIds).delete();
                    }
                    await db.changeOrders.where({ projectId: id }).delete();
                    await db.tasks.where({ projectId: id }).delete();
                    await db.boqs.where({ projectId: id }).delete();
                    await db.quantities.where({ projectId: id }).delete();
                    
                    await db.projects.delete(id);
                });
                alert('Project and all associated data deleted successfully.');
                await displayProjects();
            } catch (error) {
                console.error("Failed to delete project:", error);
                alert("An error occurred while deleting the project and its data.");
            }
        }
    }
    if (target.classList.contains('export-btn')) {
        await exportProject(id);
    }
    });

    projectsModuleInitialized = true;
}
// --- End of projects.js ---
</file>

<file path="js/reports.js">
// Author: Gemini
// OS support: Cross-platform
// Description: Logic for the Reports module (BOQ, PERT-CPM, and Gantt Chart).

const boqProjectsListDiv = document.getElementById('boq-projects-list');
const boqProjectName = document.getElementById('boq-project-name');
const boqStatusMessage = document.getElementById('boq-status-message');
const boqTbody = document.querySelector('#boq-table tbody');
const boqTfoot = document.querySelector('#boq-table tfoot');
const deleteBoqBtn = document.getElementById('delete-boq-btn');
const viewPertCpmBtn = document.getElementById('view-pert-cpm-btn');
const viewGanttChartBtn = document.getElementById('view-gantt-chart-btn');
const viewSCurveBtn = document.getElementById('view-s-curve-btn');
const viewNetworkDiagramBtn = document.getElementById('view-network-diagram-btn');
const viewResourceScheduleBtn = document.getElementById('view-resource-schedule-btn');

const pertCpmProjectName = document.getElementById('pert-cpm-project-name');
const pertCpmTbody = document.querySelector('#pert-cpm-table tbody');
const ganttChartProjectName = document.getElementById('gantt-chart-project-name');
const sCurveProjectName = document.getElementById('s-curve-project-name');
const sCurveChartCanvas = document.getElementById('s-curve-chart');
const networkDiagramProjectName = document.getElementById('network-diagram-project-name');

const revisedBoqProjectsListDiv = document.getElementById('revised-boq-projects-list');
const revisedBoqProjectName = document.getElementById('revised-boq-project-name');
const revisedBoqTableContainer = document.getElementById('revised-boq-table-container');
const viewRevisedPertCpmBtn = document.getElementById('view-revised-pert-cpm-btn');
const revisedPertCpmProjectName = document.getElementById('revised-pert-cpm-project-name');
const revisedPertCpmTableContainer = document.getElementById('revised-pert-cpm-table-container');

let sCurveChart = null;
let ganttChart = null;

const showReportsProjectList = () => {
    boqDisplayView.classList.add('hidden');
    pertCpmDisplayView.classList.add('hidden');
    ganttChartDisplayView.classList.add('hidden');
    sCurveDisplayView.classList.add('hidden');
    pertCpmNetworkView.classList.add('hidden');
    resourceScheduleView.classList.add('hidden');
    boqProjectListView.classList.remove('hidden');
    displayBoqProjects();
};

const displayBoqProjects = async () => {
    const allProjects = await db.projects.orderBy('projectName').toArray();
    boqProjectsListDiv.innerHTML = '';
    if (allProjects.length === 0) {
        boqProjectsListDiv.innerHTML = '<p>No projects created yet.</p>';
    } else {
        allProjects.forEach(p => {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary view-boq-btn" data-id="${p.id}" data-name="${p.projectName}">View BOQ</button>`;
            boqProjectsListDiv.appendChild(item);
        });
    }
};

const displayBoqFromData = (boqData) => {
    boqTbody.innerHTML = '';
    boqTfoot.innerHTML = '';
    let grandTotal = 0;
    const sortedCategories = Object.keys(boqData).sort();
    for (const category of sortedCategories) {
        const categorySubtotal = boqData[category].reduce((sum, item) => sum + item.totalAmount, 0);
        grandTotal += categorySubtotal;

        const headerRow = boqTbody.insertRow();
        headerRow.className = 'category-header-row';
        headerRow.innerHTML = `
            <td colspan="4"><strong>${category}</strong></td>
            <td style="text-align: right;"><strong>${categorySubtotal.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</strong></td>
            <td></td>
        `;

        boqData[category].forEach(item => {
            const row = boqTbody.insertRow();
            row.innerHTML = `
                <td>${item.scopeOfWork}</td>
                <td>${item.quantity.toLocaleString()}</td>
                <td>${item.unit}</td>
                <td style="text-align: right;">${item.unitPrice.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td>
                <td style="text-align: right;">${item.totalAmount.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td>
                <td class="actions-cell"><button class="btn btn-secondary view-dupa-details-btn" data-quantity-id="${item.quantityId}">View DUPA</button></td>
            `;
        });
    }
    boqTfoot.innerHTML = `
        <tr class="boq-summary-row">
            <td colspan="5" style="text-align: right;">Grand Total</td>
            <td style="text-align: right;">${grandTotal.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td>
        </tr>
    `;
};

const generateAndLockBoq = async () => {
    const quantities = await db.quantities.where('projectId').equals(currentBoqProjectId).toArray();
    if (quantities.length === 0) {
        alert("Cannot generate a BOQ with no quantities.");
        return;
    }
    const dupas = await db.dupas.where('quantityId').anyOf(quantities.map(q => q.id)).toArray();
    const dupaMap = new Map(dupas.map(d => [d.quantityId, d]));
    const boqData = quantities.reduce((acc, q) => {
        const category = q.category || 'Uncategorized';
        if (!acc[category]) acc[category] = [];
        const dupa = dupaMap.get(q.id);
        const totalAmount = calculateDupaTotalCost(dupa);
        const unitPrice = (q.quantity > 0) ? (totalAmount / q.quantity) : 0;
        acc[category].push({
            quantityId: q.id,
            scopeOfWork: q.scopeOfWork,
            quantity: q.quantity,
            unit: q.unit,
            unitPrice: unitPrice,
            totalAmount: totalAmount
        });
        return acc;
    }, {});
    await db.boqs.add({
        projectId: currentBoqProjectId,
        generatedAt: new Date(),
        boqData: boqData
    });
    await showBoqForProject(currentBoqProjectId, boqProjectName.textContent.replace('Bill of Quantities: ', ''));
};

const promptToGenerateBoq = () => {
    const modal = document.getElementById('generate-boq-modal');
    if (!modal) {
        console.error('Generate BOQ Modal not found in the HTML file.');
        if (confirm("No locked BOQ found for this project. Do you want to generate one? This will lock all pre-construction data.")) {
             generateAndLockBoq();
        }
        return;
    }

    const confirmBtn = document.getElementById('confirm-generate-boq-btn');
    const cancelBtn = document.getElementById('cancel-generate-boq-btn');
    const closeBtn = document.getElementById('close-generate-boq-modal');

    const confirmHandler = async () => {
        confirmBtn.removeEventListener('click', confirmHandler);
        cancelBtn.removeEventListener('click', cancelHandler);
        closeBtn.removeEventListener('click', cancelHandler);
        modal.style.display = 'none';
        await generateAndLockBoq();
    };

    const cancelHandler = () => {
        confirmBtn.removeEventListener('click', confirmHandler);
        cancelBtn.removeEventListener('click', cancelHandler);
        closeBtn.removeEventListener('click', cancelHandler);
        modal.style.display = 'none';
    };

    confirmBtn.addEventListener('click', confirmHandler);
    cancelBtn.addEventListener('click', cancelHandler);
    closeBtn.addEventListener('click', cancelHandler);

    modal.style.display = 'block';
};

const showBoqForProject = async (projectId, projectName) => {
    currentBoqProjectId = projectId;
    boqProjectName.textContent = `Bill of Quantities: ${projectName}`;
    boqProjectListView.classList.add('hidden');
    pertCpmDisplayView.classList.add('hidden');
    ganttChartDisplayView.classList.add('hidden');
    sCurveDisplayView.classList.add('hidden');
    pertCpmNetworkView.classList.add('hidden');
    resourceScheduleView.classList.add('hidden');
    boqDisplayView.classList.remove('hidden');

    const lockedBoq = await db.boqs.where({ projectId: projectId }).first();

    if (lockedBoq) {
        boqStatusMessage.textContent = `This BOQ was generated and locked on ${lockedBoq.generatedAt.toLocaleString()}. Data can no longer be edited.`;
        deleteBoqBtn.classList.remove('hidden');
        viewPertCpmBtn.classList.remove('hidden');
        displayBoqFromData(lockedBoq.boqData);
    } else {
        boqStatusMessage.textContent = '';
        deleteBoqBtn.classList.add('hidden');
        viewPertCpmBtn.classList.add('hidden');
        boqTbody.innerHTML = '<tr><td colspan="6">No locked BOQ found for this project.</td></tr>';
        boqTfoot.innerHTML = '';
        promptToGenerateBoq();
    }
};

const handleDeleteBoq = () => {
    const modal = document.getElementById('delete-boq-modal');
    if (!modal) {
        console.error('Delete Confirmation Modal not found in the HTML file.');
        alert('Error: Could not find the confirmation dialog. Please ensure the HTML is up to date.');
        return;
    }

    const confirmBtn = document.getElementById('confirm-delete-boq-btn');
    const cancelBtn = document.getElementById('cancel-delete-boq-btn');
    const closeBtn = document.getElementById('close-delete-boq-modal');

    const confirmHandler = async () => {
        confirmBtn.removeEventListener('click', confirmHandler);
        cancelBtn.removeEventListener('click', cancelHandler);
        closeBtn.removeEventListener('click', cancelHandler);

        modal.style.display = 'none';

        if (!currentBoqProjectId) {
            alert('Error: No project selected.');
            return;
        }

        try {
            await db.transaction('rw', ['boqs', 'quantities', 'accomplishments', 'projects'], async () => {
                const boqToDelete = await db.boqs.where({ projectId: currentBoqProjectId }).first();
                if (boqToDelete) {
                    await db.boqs.delete(boqToDelete.id);
                }
                const quantitiesToReset = await db.quantities.where({ projectId: currentBoqProjectId }).toArray();
                const quantityIds = quantitiesToReset.map(q => q.id);
                if (quantityIds.length > 0) {
                    await db.accomplishments
                        .where('taskId').anyOf(quantityIds)
                        .and(record => record.type === 'quantity')
                        .delete();
                    await db.quantities.where('projectId').equals(currentBoqProjectId).modify({ percentComplete: null });
                }
                await db.projects.update(currentBoqProjectId, { startDate: null });
            });

            alert("BOQ and all construction progress deleted successfully. Pre-construction data is now unlocked.");
            showReports();
        } catch (error) {
            console.error("Failed to delete BOQ and related data:", error);
            alert("An error occurred during the deletion process. Please check the console for details.");
        }
    };

    const cancelHandler = () => {
        confirmBtn.removeEventListener('click', confirmHandler);
        cancelBtn.removeEventListener('click', cancelHandler);
        closeBtn.removeEventListener('click', cancelHandler);
        modal.style.display = 'none';
    };

    confirmBtn.addEventListener('click', confirmHandler);
    cancelBtn.addEventListener('click', cancelHandler);
    closeBtn.addEventListener('click', cancelHandler);

    modal.style.display = 'block';
};

const showPertCpmForProject = async () => {
    boqDisplayView.classList.add('hidden');
    ganttChartDisplayView.classList.add('hidden');
    sCurveDisplayView.classList.add('hidden');
    pertCpmNetworkView.classList.add('hidden');
    resourceScheduleView.classList.add('hidden');
    pertCpmDisplayView.classList.remove('hidden');
    pertCpmProjectName.textContent = `PERT-CPM: ${boqProjectName.textContent.replace('Bill of Quantities: ', '')}`;
    const data = await getPertCpmData(currentBoqProjectId);
    if (!data) {
        pertCpmTbody.innerHTML = '<tr><td colspan="7">No tasks found for this project.</td></tr>';
        return;
    }
    pertCpmTbody.innerHTML = '';
    data.quantities.sort((a,b) => data.tasks.get(a.id).es - data.tasks.get(b.id).es).forEach(q => {
        const task = data.tasks.get(q.id);
        const slack = task.ls - task.es;
        const isCritical = slack <= 0;
        const row = pertCpmTbody.insertRow();
        if (isCritical) row.classList.add('critical-path');
        row.innerHTML = `<td>${task.name}</td><td>${task.duration}</td><td>${task.es}</td><td>${task.ef}</td><td>${task.ls}</td><td>${task.lf}</td><td>${slack}</td>`;
    });
};

const showGanttChartForProject = async () => {
    pertCpmDisplayView.classList.add('hidden');
    sCurveDisplayView.classList.add('hidden');
    pertCpmNetworkView.classList.add('hidden');
    resourceScheduleView.classList.add('hidden');
    ganttChartDisplayView.classList.remove('hidden');
    ganttChartProjectName.textContent = `Gantt Chart: ${boqProjectName.textContent.replace('Bill of Quantities: ', '')}`;
    
    const ganttContainer = document.getElementById('gantt-chart-target');
    ganttContainer.innerHTML = 'Loading Chart...';

    const data = await getPertCpmData(currentBoqProjectId, false);
    const project = await db.projects.get(currentBoqProjectId);

    if (!data || data.quantities.length === 0) {
        ganttContainer.innerHTML = 'No tasks to display.';
        return;
    }

    const projectStartDate = project.startDate ? new Date(project.startDate) : new Date();
    projectStartDate.setMinutes(projectStartDate.getMinutes() + projectStartDate.getTimezoneOffset());

    let tasksForGantt = data.quantities.map(q => {
        const task = data.tasks.get(q.id);
        if (!task) return null;
        const isCritical = (task.ls - task.es) <= 0;
        const startDate = new Date(projectStartDate);
        startDate.setDate(startDate.getDate() + task.es);
        const endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + task.duration);
        const dependencies = Array.from(task.predecessors)
            .filter(pId => typeof pId === 'number' && data.tasks.has(pId))
            .map(pId => `task_${pId}`)
            .join(', ');

        return {
            id: `task_${q.id}`,
            name: task.name,
            start: startDate.toISOString().split('T')[0],
            end: endDate.toISOString().split('T')[0],
            progress: 0,
            dependencies: dependencies,
            custom_class: isCritical ? 'bar-critical' : '',
            duration: task.duration // Add duration property for sorting
        };
    }).filter(Boolean);

    // **NEW**: Sort tasks based on the dropdown value
    const sortBy = document.getElementById('reports-gantt-sort').value;
    tasksForGantt.sort((a, b) => {
        if (sortBy === 'name') return a.name.localeCompare(b.name);
        if (sortBy === 'duration') return a.duration - b.duration;
        return new Date(a.start) - new Date(b.start); // Default to sorting by start date
    });

    ganttContainer.innerHTML = '';
    ganttChart = new Gantt("#gantt-chart-target", tasksForGantt, {
        view_mode: 'Week',
        custom_popup_html: function(task) {
            // Use the duration property we just added
            return `<div class="gantt-popup-wrapper">
                <strong>${task.name}</strong>
                <p>Duration: ${task.duration} days</p>
            </div>`;
        }
    });
};

const showSCurveForProject = async () => {
    pertCpmDisplayView.classList.add('hidden');
    ganttChartDisplayView.classList.add('hidden');
    pertCpmNetworkView.classList.add('hidden');
    resourceScheduleView.classList.add('hidden');
    sCurveDisplayView.classList.remove('hidden');
    sCurveProjectName.textContent = `S-Curve: ${boqProjectName.textContent.replace('Bill of Quantities: ', '')}`;

    const data = await getSCurveData(currentBoqProjectId);

    if (sCurveChart) {
        sCurveChart.destroy();
    }

    if (!data) {
        sCurveChartCanvas.getContext('2d').clearRect(0, 0, sCurveChartCanvas.width, sCurveChartCanvas.height);
        alert("Could not generate S-Curve. Ensure the project has tasks with durations and costs.");
        return;
    }

    sCurveChart = new Chart(sCurveChartCanvas, {
        type: 'line',
        data: {
            labels: data.labels,
            datasets: [{
                label: 'Planned Cumulative % Completion',
                data: data.plannedPercentage,
                borderColor: 'rgb(75, 192, 192)',
                tension: 0.4,
                fill: false
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    title: {
                        display: true,
                        text: 'Cumulative Completion (%)'
                    },
                    ticks: {
                        callback: function(value) {
                            return value + '%';
                        }
                    }
                },
                x: {
                    title: {
                        display: true,
                        text: 'Project Day'
                    }
                }
            },
            plugins: {
                title: {
                    display: true,
                    text: `Planned S-Curve (Total Project Cost: PHP ${data.grandTotalCost.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })})`
                },
                tooltip: {
                     callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(2) + '%';
                            }
                            return label;
                        }
                    }
                }
            }
        }
    });
};

const showNetworkDiagram = async () => {
    pertCpmDisplayView.classList.add('hidden');
    ganttChartDisplayView.classList.add('hidden');
    sCurveDisplayView.classList.add('hidden');
    resourceScheduleView.classList.add('hidden');
    pertCpmNetworkView.classList.remove('hidden');
    networkDiagramProjectName.textContent = `Network Diagram: ${boqProjectName.textContent.replace('Bill of Quantities: ', '')}`;

    const diagramContainer = pertCpmNetworkView.querySelector('.mermaid');
    diagramContainer.innerHTML = 'Loading diagram...';

    const data = await getPertCpmData(currentBoqProjectId, false);
    if (!data || !data.tasks) {
        diagramContainer.innerHTML = 'No data to display.';
        return;
    }

    let mermaidSyntax = 'graph TD;\n';

    data.quantities.forEach(q => {
        const task = data.tasks.get(q.id);
        if (!task) return;
        const slack = task.ls - task.es;
        const isCritical = slack <= 0;
        const nodeId = `T${q.id}`;
        const nodeText = `"${task.name} (D:${task.duration})<br/>ES:${task.es} EF:${task.ef}<br/>LS:${task.ls} LF:${task.lf}<br/>Slack:${slack}"`;
        mermaidSyntax += `    ${nodeId}(${nodeText});\n`;
        if (isCritical) {
            mermaidSyntax += `    style ${nodeId} fill:#f8d7da,stroke:#c00,stroke-width:2px;\n`;
        }
    });

    mermaidSyntax += '    PRJ_START((Start));\n';
    mermaidSyntax += '    PRJ_END((End));\n';
    mermaidSyntax += '    style PRJ_START fill:#d1e7dd,stroke:#333,stroke-width:2px;\n';
    mermaidSyntax += '    style PRJ_END fill:#d1e7dd,stroke:#333,stroke-width:2px;\n';

    data.tasks.forEach((task, taskId) => {
        const predecessorNodeId = taskId === 'PROJECT_START' ? 'PRJ_START' : `T${taskId}`;

        task.successors.forEach(successorId => {
            const successorNodeId = successorId === 'PROJECT_END'
                ? 'PRJ_END'
                : `T${successorId}`;

            if (data.tasks.has(taskId) && data.tasks.has(successorId)) {
                mermaidSyntax += `    ${predecessorNodeId} --> ${successorNodeId};\n`;
            }
        });
    });

    try {
        const { svg } = await mermaid.render('mermaid-graph-render', mermaidSyntax);
        diagramContainer.innerHTML = svg;
    } catch (e) {
        diagramContainer.innerHTML = 'Error rendering diagram. Check console for details.';
        console.error("Mermaid rendering error:", e);
    }
};

const showManpowerEquipmentSchedule = async () => {
    pertCpmDisplayView.classList.add('hidden');
    ganttChartDisplayView.classList.add('hidden');
    sCurveDisplayView.classList.add('hidden');
    pertCpmNetworkView.classList.add('hidden');
    resourceScheduleView.classList.remove('hidden');

    const resourceScheduleProjectName = document.getElementById('resource-schedule-project-name');
    resourceScheduleProjectName.textContent = `Resource Schedule: ${boqProjectName.textContent.replace('Bill of Quantities: ', '')}`;

    const scheduleContainer = document.getElementById('resource-schedule-container');
    scheduleContainer.innerHTML = 'Loading schedule...';

    const pertData = await getPertCpmData(currentBoqProjectId, true);
    if (!pertData || pertData.projectDuration === 0) {
        scheduleContainer.innerHTML = '<p>No data available to generate schedule.</p>';
        return;
    }

    const { tasks, projectDuration } = pertData;
    const { allDupas } = await getAllTasksForReport(currentBoqProjectId, true);
    const dupaMap = new Map();
    allDupas.forEach(d => {
        const key = d.quantityId || d.changeOrderItemId;
        dupaMap.set(key, d);
    });

    const dailyResources = {};

    for (const [taskId, task] of tasks.entries()) {
        if (typeof taskId !== 'number' || task.duration <= 0) continue;

        const dupa = dupaMap.get(taskId);
        if (!dupa || !dupa.directCosts) continue;

        dupa.directCosts.forEach(dc => {
            let resourceName = '';
            let dailyAmount = 0;
            let unit = '';

            if (dc.type === 'labor') {
                resourceName = dc.laborType;
                dailyAmount = dc.mandays / task.duration;
                unit = 'md';
            } else if (dc.type === 'equipment') {
                resourceName = dc.name;
                dailyAmount = dc.hours / task.duration;
                unit = 'hrs';
            }

            if (resourceName) {
                if (!dailyResources[resourceName]) {
                    dailyResources[resourceName] = {
                        unit: unit,
                        schedule: new Array(projectDuration).fill(0)
                    };
                }
                for (let day = task.es; day < task.ef; day++) {
                    if (day < projectDuration) {
                        dailyResources[resourceName].schedule[day] += dailyAmount;
                    }
                }
            }
        });
    }

    if (Object.keys(dailyResources).length === 0) {
        scheduleContainer.innerHTML = '<p>No labor or equipment resources found in DUPAs.</p>';
        return;
    }

    let tableHtml = '<table id="resource-schedule-table"><thead><tr><th class="sticky-col">Resource</th>';
    for (let i = 1; i <= projectDuration; i++) {
        tableHtml += `<th>${i}</th>`;
    }
    tableHtml += '</tr></thead><tbody>';

    const groupedResources = { 'Labor': [], 'Equipment': [] };
    Object.keys(dailyResources).sort().forEach(name => {
        if (dailyResources[name].unit === 'md') {
            groupedResources['Labor'].push(name);
        } else {
            groupedResources['Equipment'].push(name);
        }
    });

    for (const group in groupedResources) {
        if (groupedResources[group].length > 0) {
            tableHtml += `<tr class="category-header-row"><td class="sticky-col" colspan="${projectDuration + 1}">${group}</td></tr>`;
            groupedResources[group].forEach(resourceName => {
                const data = dailyResources[resourceName];
                tableHtml += `<tr><td class="sticky-col">${resourceName} (${data.unit})</td>`;
                data.schedule.forEach(amount => {
                    tableHtml += `<td>${amount > 0 ? amount.toFixed(2) : '-'}</td>`;
                });
                tableHtml += '</tr>';
            });
        }
    }

    tableHtml += '</tbody></table>';
    scheduleContainer.innerHTML = tableHtml;
};

const showDupaDetails = async (quantityId) => {
    const quantity = await db.quantities.get(quantityId);
    const dupa = await db.dupas.where('quantityId').equals(quantityId).first();
    if (!quantity || !dupa) {
        alert('DUPA details not found for this item.');
        return;
    }
    let content = '';
    let directCostTotal = 0;
    content += '<h5 class="dupa-category-header">Direct Costs</h5><table class="dupa-table"><thead><tr><th>Description</th><th style="text-align:right;">Amount</th></tr></thead><tbody>';
    dupa.directCosts.forEach(item => {
        let itemTotal = 0;
        let description = '';
        switch (item.type) {
            case 'labor':
                itemTotal = item.mandays * item.rate;
                description = `${item.laborType} (${item.mandays} md @ ${item.rate.toFixed(2)})`;
                break;
            case 'material':
                itemTotal = item.quantity * item.unitPrice;
                description = `${item.name} (${item.quantity} ${item.unit} @ ${item.unitPrice.toFixed(2)})`;
                break;
            case 'equipment':
                itemTotal = item.hours * item.rate;
                description = `${item.name} (${item.hours} hrs @ ${item.rate.toFixed(2)})`;
                break;
        }
        directCostTotal += itemTotal;
        content += `<tr><td>${description}</td><td style="text-align:right;">${itemTotal.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    });
    content += `<tr><td style="text-align:right; font-weight:bold;">Total Direct Cost</td><td style="text-align:right; font-weight:bold;">${directCostTotal.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += '</tbody></table>';

    const ocmCost = directCostTotal * (dupa.indirectCosts.ocm / 100);
    const profitCost = directCostTotal * (dupa.indirectCosts.profit / 100);
    const subtotal = directCostTotal + ocmCost + profitCost;
    const taxCost = subtotal * (dupa.indirectCosts.taxes / 100);
    const totalAmount = subtotal + taxCost;
    const unitPrice = quantity.quantity > 0 ? totalAmount / quantity.quantity : 0;

    content += '<h5 class="dupa-category-header">Cost Summary</h5><table class="dupa-table"><tbody>';
    content += `<tr><td>Total Direct Cost</td><td style="text-align:right;">${directCostTotal.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += `<tr><td>OCM (${dupa.indirectCosts.ocm}%)</td><td style="text-align:right;">${ocmCost.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += `<tr><td>Contractor's Profit (${dupa.indirectCosts.profit}%)</td><td style="text-align:right;">${profitCost.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += `<tr><td>VAT (${dupa.indirectCosts.taxes}%)</td><td style="text-align:right;">${taxCost.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += `<tr style="font-weight:bold; border-top: 2px solid black;"><td >Item Total Amount</td><td style="text-align:right;">${totalAmount.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += '</tbody></table>';

    content += '<h5 class="dupa-category-header">Unit Price Computation</h5><table class="dupa-table"><tbody>';
    content += `<tr><td>(Total Amount / Quantity)</td><td style="text-align:right;">(${totalAmount.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })} / ${quantity.quantity} ${quantity.unit})</td></tr>`;
    content += `<tr style="font-weight:bold;"><td >Final Unit Price</td><td style="text-align:right;">${unitPrice.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += '</tbody></table>';

    dupaReportContent.innerHTML = content;
    dupaReportTitle.textContent = `DUPA Breakdown`;
    openDupaReportModal();
};

const showCoItemDupaDetails = async (coItemId) => {
    const item = await db.changeOrderItems.get(coItemId);
    const dupa = await db.changeOrderDupas.where('changeOrderItemId').equals(coItemId).first();
    if (!item || !dupa) {
        alert('DUPA details not found for this change order item.');
        return;
    }
    let content = '';
    let directCostTotal = 0;
    content += '<h5 class="dupa-category-header">Direct Costs</h5><table class="dupa-table"><thead><tr><th>Description</th><th style="text-align:right;">Amount</th></tr></thead><tbody>';
    dupa.directCosts.forEach(dc_item => {
        let itemTotal = 0;
        let description = '';
        switch (dc_item.type) {
            case 'labor':
                itemTotal = dc_item.mandays * dc_item.rate;
                description = `${dc_item.laborType} (${dc_item.mandays} md @ ${dc_item.rate.toFixed(2)})`;
                break;
            case 'material':
                itemTotal = dc_item.quantity * dc_item.unitPrice;
                description = `${dc_item.name} (${dc_item.quantity} ${dc_item.unit} @ ${dc_item.unitPrice.toFixed(2)})`;
                break;
            case 'equipment':
                itemTotal = dc_item.hours * dc_item.rate;
                description = `${dc_item.name} (${dc_item.hours} hrs @ ${dc_item.rate.toFixed(2)})`;
                break;
        }
        directCostTotal += itemTotal;
        content += `<tr><td>${description}</td><td style="text-align:right;">${itemTotal.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    });
    content += `<tr><td style="text-align:right; font-weight:bold;">Total Direct Cost</td><td style="text-align:right; font-weight:bold;">${directCostTotal.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += '</tbody></table>';

    const ocmCost = directCostTotal * (dupa.indirectCosts.ocm / 100);
    const profitCost = directCostTotal * (dupa.indirectCosts.profit / 100);
    const subtotal = directCostTotal + ocmCost + profitCost;
    const taxCost = subtotal * (dupa.indirectCosts.taxes / 100);
    const totalAmount = subtotal + taxCost;
    const unitPrice = item.quantity > 0 ? totalAmount / item.quantity : 0;

    content += '<h5 class="dupa-category-header">Cost Summary</h5><table class="dupa-table"><tbody>';
    content += `<tr><td>Total Direct Cost</td><td style="text-align:right;">${directCostTotal.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += `<tr><td>OCM (${dupa.indirectCosts.ocm}%)</td><td style="text-align:right;">${ocmCost.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += `<tr><td>Contractor's Profit (${dupa.indirectCosts.profit}%)</td><td style="text-align:right;">${profitCost.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += `<tr><td>VAT (${dupa.indirectCosts.taxes}%)</td><td style="text-align:right;">${taxCost.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += `<tr style="font-weight:bold; border-top: 2px solid black;"><td >Item Total Amount</td><td style="text-align:right;">${totalAmount.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += '</tbody></table>';

    content += '<h5 class="dupa-category-header">Unit Price Computation</h5><table class="dupa-table"><tbody>';
    content += `<tr><td>(Total Amount / Quantity)</td><td style="text-align:right;">(${totalAmount.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })} / ${item.quantity} ${item.unit})</td></tr>`;
    content += `<tr style="font-weight:bold;"><td >Final Unit Price</td><td style="text-align:right;">${unitPrice.toLocaleString('en-PH', { style: 'currency', currency: 'PHP' })}</td></tr>`;
    content += '</tbody></table>';

    dupaReportContent.innerHTML = content;
    dupaReportTitle.textContent = `DUPA Breakdown (Change Order)`;
    openDupaReportModal();
};

const displayRevisedBoqProjects = async () => {
    const constructionReadyProjects = await getConstructionReadyProjects();
    revisedBoqProjectsListDiv.innerHTML = '';
    if (constructionReadyProjects.length === 0) {
        revisedBoqProjectsListDiv.innerHTML = '<p>No projects with a generated BOQ found.</p>';
        return;
    }
    constructionReadyProjects.forEach(p => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary view-revised-boq-btn" data-id="${p.id}" data-name="${p.projectName}">View Revised BOQ</button>`;
        revisedBoqProjectsListDiv.appendChild(item);
    });
};

const showRevisedBoqForProject = async (projectId, projectName) => {
    currentBoqProjectId = projectId;
    revisedBoqProjectName.textContent = `Revised BOQ: ${projectName}`;
    revisedBoqProjectListView.classList.add('hidden');
    revisedPertCpmDisplayView.classList.add('hidden');
    revisedBoqDisplayView.classList.remove('hidden');

    const { allTasks, allDupas } = await getAllTasksForReport(projectId, true);
    const dupaMap = new Map();
    allDupas.forEach(d => {
        const key = d.quantityId || d.changeOrderItemId;
        dupaMap.set(key, d);
    });

    const originalItems = allTasks.filter(task => !task.changeOrderId);
    const changeOrderItems = allTasks.filter(task => task.changeOrderId);

    const groupedOriginals = originalItems.reduce((acc, task) => {
        const category = task.category || 'Uncategorized';
        if (!acc[category]) acc[category] = [];
        acc[category].push(task);
        return acc;
    }, {});

    let tableHtml = '<table id="revised-boq-table"><thead><tr><th>Scope of Work</th><th>Quantity</th><th>Unit</th><th>Unit Price</th><th>Total Amount</th><th>Actions</th></tr></thead><tbody>';
    let grandTotal = 0;

    const sortedCategories = Object.keys(groupedOriginals).sort();
    for (const category of sortedCategories) {
        const categoryTasks = groupedOriginals[category];
        const categorySubtotal = categoryTasks.reduce((sum, task) => {
            const dupa = dupaMap.get(task.id);
            return sum + calculateDupaTotalCost(dupa);
        }, 0);
        grandTotal += categorySubtotal;

        tableHtml += `<tr class="category-header-row">
                        <td colspan="5"><strong>${category}</strong></td>
                        <td style="text-align: right;"><strong>${categorySubtotal.toLocaleString('en-ph', { style: 'currency', currency: 'PHP' })}</strong></td>
                      </tr>`;

        categoryTasks.forEach(task => {
            const dupa = dupaMap.get(task.id);
            const totalAmount = calculateDupaTotalCost(dupa);
            const unitPrice = (task.quantity !== 0) ? (totalAmount / task.quantity) : 0;
            tableHtml += `
                <tr>
                    <td>${task.displayName}</td>
                    <td>${task.quantity.toLocaleString()}</td>
                    <td>${task.unit}</td>
                    <td style="text-align: right;">${unitPrice.toLocaleString('en-ph', { style: 'currency', currency: 'PHP' })}</td>
                    <td style="text-align: right;">${totalAmount.toLocaleString('en-ph', { style: 'currency', currency: 'PHP' })}</td>
                    <td></td>
                </tr>
            `;
        });
    }

    if (changeOrderItems.length > 0) {
        const coSubtotal = changeOrderItems.reduce((sum, task) => {
            const dupa = dupaMap.get(task.id);
            return sum + calculateDupaTotalCost(dupa);
        }, 0);
        grandTotal += coSubtotal;

        tableHtml += `<tr class="category-header-row">
                        <td colspan="5"><strong>Change Orders</strong></td>
                        <td style="text-align: right;"><strong>${coSubtotal.toLocaleString('en-ph', { style: 'currency', currency: 'PHP' })}</strong></td>
                      </tr>`;

        changeOrderItems.forEach(task => {
            const dupa = dupaMap.get(task.id);
            const totalAmount = calculateDupaTotalCost(dupa);
            const unitPrice = (task.quantity !== 0) ? (totalAmount / task.quantity) : 0;
            tableHtml += `
                <tr>
                    <td>${task.displayName}</td>
                    <td>${task.quantity.toLocaleString()}</td>
                    <td>${task.unit}</td>
                    <td style="text-align: right;">${unitPrice.toLocaleString('en-ph', { style: 'currency', currency: 'PHP' })}</td>
                    <td style="text-align: right;">${totalAmount.toLocaleString('en-ph', { style: 'currency', currency: 'PHP' })}</td>
                    <td class="actions-cell"><button class="btn btn-secondary view-co-dupa-details-btn" data-co-item-id="${task.id}">View DUPA</button></td>
                </tr>
            `;
        });
    }

    tableHtml += `</tbody><tfoot><tr class="boq-summary-row"><td colspan="5" style="text-align:right;">Revised Grand Total</td><td style="text-align: right;">${grandTotal.toLocaleString('en-ph', { style: 'currency', currency: 'PHP' })}</td></tr></tfoot></table>`;
    revisedBoqTableContainer.innerHTML = tableHtml;
};

const showRevisedPertCpmForProject = async () => {
    revisedBoqDisplayView.classList.add('hidden');
    revisedPertCpmDisplayView.classList.remove('hidden');
    revisedPertCpmProjectName.textContent = `Revised PERT-CPM: ${revisedBoqProjectName.textContent.replace('Revised BOQ: ', '')}`;

    const data = await getPertCpmData(currentBoqProjectId, true);
    if (!data) {
        revisedPertCpmTableContainer.innerHTML = '<p>No data to display.</p>';
        return;
    }

    let tableHtml = '<table id="revised-pert-cpm-table"><thead><tr><th>Task</th><th>Duration</th><th>ES</th><th>EF</th><th>LS</th><th>LF</th><th>Slack</th></tr></thead><tbody>';
    data.quantities.forEach(q => {
        const task = data.tasks.get(q.id);
        if(!task) return;
        const slack = task.ls - task.es;
        const isCritical = slack <= 0;
        tableHtml += `<tr class="${isCritical ? 'critical-path' : ''}">
            <td>${task.name}</td><td>${task.duration}</td><td>${task.es}</td><td>${task.ef}</td><td>${task.ls}</td><td>${task.lf}</td><td>${slack}</td>
        </tr>`;
    });
    tableHtml += '</tbody></table>';
    revisedPertCpmTableContainer.innerHTML = tableHtml;
};

function initializeReportsModule() {
    boqProjectsListDiv.addEventListener('click', (e) => {
        if (e.target.classList.contains('view-boq-btn')) {
            showBoqForProject(parseInt(e.target.dataset.id), e.target.dataset.name);
        }
    });
    deleteBoqBtn.addEventListener('click', handleDeleteBoq);
    viewPertCpmBtn.addEventListener('click', showPertCpmForProject);
    viewSCurveBtn.addEventListener('click', showSCurveForProject);
    viewGanttChartBtn.addEventListener('click', showGanttChartForProject);
    document.getElementById('gantt-view-day').addEventListener('click', () => {
        if (ganttChart) ganttChart.change_view_mode('Day');
    });
    document.getElementById('gantt-view-week').addEventListener('click', () => {
        if (ganttChart) ganttChart.change_view_mode('Week');
    });
    document.getElementById('gantt-view-month').addEventListener('click', () => {
        if (ganttChart) ganttChart.change_view_mode('Month');
    });
    viewNetworkDiagramBtn.addEventListener('click', showNetworkDiagram);
    viewResourceScheduleBtn.addEventListener('click', showManpowerEquipmentSchedule);

    dupaReportModalClose.addEventListener('click', closeDupaReportModal);

    boqTbody.addEventListener('click', (e) => {
        if (e.target.classList.contains('view-dupa-details-btn')) {
            const quantityId = parseInt(e.target.dataset.quantityId);
            if (isNaN(quantityId)) {
                alert('This BOQ is outdated and does not support this feature. Please delete this BOQ and regenerate it to use this function.');
                return;
            }
            showDupaDetails(quantityId);
        }
    });

    revisedBoqTableContainer.addEventListener('click', (e) => {
        if (e.target.classList.contains('view-co-dupa-details-btn')) {
            const coItemId = parseInt(e.target.dataset.coItemId);
            showCoItemDupaDetails(coItemId);
        }
    });

    revisedBoqProjectsListDiv.addEventListener('click', (e) => {
        if (e.target.classList.contains('view-revised-boq-btn')) {
            showRevisedBoqForProject(parseInt(e.target.dataset.id), e.target.dataset.name);
        }
    });
    viewRevisedPertCpmBtn.addEventListener('click', showRevisedPertCpmForProject);
}

// --- End of reports.js ---
</file>

<file path="js/sequencing.js">
// Author: Gemini
// OS support: Cross-platform
// Description: Logic for the Task Sequencing module.

const sequencingProjectsListDiv = document.getElementById('sequencing-projects-list');
const sequencingProjectName = document.getElementById('sequencing-project-name');
const sequencesOverviewTbody = document.getElementById('sequences-overview-tbody');
const unsequencedTasksList = document.getElementById('unsequenced-tasks-list');
const sequenceEditModal = document.getElementById('sequence-edit-modal');
const sequenceModalClose = document.querySelector('.sequence-modal-close');
const sequenceModalTitle = document.getElementById('sequence-modal-title');
const sequenceEditForm = document.getElementById('sequence-edit-form');
const editingTaskIdInput = document.getElementById('editingTaskId');
const modalPredecessorsSelect = document.getElementById('modal-predecessors-multiselect');
const modalSuccessorsSelect = document.getElementById('modal-successors-multiselect');
const sortSequencesBtn = document.getElementById('sort-sequences-btn');

const openSequenceEditModal = () => sequenceEditModal.style.display = 'block';
const closeSequenceEditModal = () => sequenceEditModal.style.display = 'none';

const getAllProjectTasks = async (projectId) => {
    const quantities = await db.quantities.where({ projectId }).toArray();
    const approvedChangeOrders = await db.changeOrders.where({ projectId, status: 'Approved' }).toArray();
    const approvedChangeOrderIds = approvedChangeOrders.map(co => co.id);
    const changeOrderItems = approvedChangeOrderIds.length > 0 ? await db.changeOrderItems.where('changeOrderId').anyOf(approvedChangeOrderIds).toArray() : [];

    const allTasks = [];

    quantities.forEach(q => {
        if (q.subquantities && q.subquantities.length > 0) {
            q.subquantities.forEach((sub, index) => {
                allTasks.push({
                    id: `q_${q.id}_sub_${index}`,
                    displayName: `${q.scopeOfWork}: ${sub.name}`
                });
            });
        } else {
            allTasks.push({ id: q.id, displayName: q.scopeOfWork });
        }
    });

    allTasks.push(...changeOrderItems.map(ci => ({ id: ci.id, displayName: `(CO) ${ci.scopeOfWork}` })));
    
    return allTasks;
};

const displaySequencingProjects = async () => {
    const allProjects = await db.projects.orderBy('projectName').toArray();
    sequencingProjectsListDiv.innerHTML = '';
    if (allProjects.length === 0) {
        sequencingProjectsListDiv.innerHTML = '<p>No projects created yet.</p>';
    } else {
        allProjects.forEach(p => {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary view-sequences-btn" data-id="${p.id}" data-name="${p.projectName}">Select</button>`;
            sequencingProjectsListDiv.appendChild(item);
        });
    }
};

const displayUnsequencedTasks = async (allTasks, allLinks) => {
    const sequencedIds = new Set();
    allLinks.forEach(link => {
        sequencedIds.add(link.predecessorId);
        sequencedIds.add(link.successorId);
    });

    unsequencedTasksList.innerHTML = '';
    const unsequencedTasks = allTasks.filter(task => !sequencedIds.has(task.id));
    
    if (unsequencedTasks.length === 0) {
        unsequencedTasksList.innerHTML = '<li>All tasks are sequenced!</li>';
    } else {
        unsequencedTasks.forEach(task => {
            const li = document.createElement('li');
            li.textContent = task.displayName;
            li.dataset.id = task.id;
            li.style.cursor = 'pointer';
            unsequencedTasksList.appendChild(li);
        });
    }
};

const displaySequencesOverview = async () => {
    let allTasks = await getProjectTasks(currentSequencingProjectId); 
    const allLinks = await db.tasks.where('projectId').equals(currentSequencingProjectId).toArray();
    const pertData = await getPertCpmData(currentSequencingProjectId, true);

    sequencesOverviewTbody.innerHTML = '';
    
    await displayUnsequencedTasks(allTasks, allLinks);

    if (allTasks.length === 0) {
        sequencesOverviewTbody.innerHTML = '<tr><td colspan="4">No tasks exist for this project.</td></tr>';
        return;
    }

    const sortBy = document.getElementById('sequence-sort').value;
    const startTaskIds = new Set(allLinks.filter(l => l.predecessorId === 'PROJECT_START').map(l => l.successorId));

    if (pertData && pertData.tasks) {
        const esMap = new Map(Array.from(pertData.tasks.values()).map(task => [task.id, task.es]));
        allTasks.sort((a, b) => {
            const aIsStart = startTaskIds.has(a.id);
            const bIsStart = startTaskIds.has(b.id);
            if (aIsStart && !bIsStart) return -1;
            if (bIsStart && !aIsStart) return 1;
            
            if (sortBy === 'name') return a.displayName.localeCompare(b.displayName);
            
            const taskA_es = esMap.get(a.uniqueId || a.id) || Infinity;
            const taskB_es = esMap.get(b.uniqueId || b.id) || Infinity;
            if (taskA_es === taskB_es) return a.displayName.localeCompare(b.displayName);
            return taskA_es - taskB_es;
        });
    }

    const taskMap = new Map(allTasks.map(t => [t.uniqueId, { ...t, predecessors: [], successors: [] }]));
    taskMap.set('PROJECT_START', { displayName: '-- Project Start --', successors: [] });
    taskMap.set('PROJECT_END', { displayName: '-- Project End --', predecessors: [] });

    allLinks.forEach(link => {
        const predTaskObj = allTasks.find(t => t.id == link.predecessorId && t.type !== 'subquantity');
        const succTaskObj = allTasks.find(t => t.id == link.successorId && t.type !== 'subquantity');
        
        const predDisplayName = predTaskObj ? predTaskObj.displayName : (link.predecessorId === 'PROJECT_START' ? '-- Project Start --' : '');
        const succDisplayName = succTaskObj ? succTaskObj.displayName : (link.successorId === 'PROJECT_END' ? '-- Project End --' : '');
        
        const predTask = taskMap.get(predTaskObj?.uniqueId || link.predecessorId);
        const succTask = taskMap.get(succTaskObj?.uniqueId || link.successorId);

        if (succTask && predDisplayName) succTask.predecessors.push(predDisplayName);
        if (predTask && succDisplayName) predTask.successors.push(succDisplayName);
    });
    
    const groupBy = document.getElementById('sequence-group').value;

    const renderTaskRow = (task) => {
        const data = taskMap.get(task.uniqueId);
        const predecessorsHtml = data.predecessors.length > 0 ? `<ul>${data.predecessors.map(p => `<li>${p}</li>`).join('')}</ul>` : '<em>None</em>';
        const successorsHtml = data.successors.length > 0 ? `<ul>${data.successors.map(s => `<li>${s}</li>`).join('')}</ul>` : '<em>None</em>';
        const isSubtask = task.type === 'subquantity';
        const disabledAttr = isSubtask ? 'disabled title="Sub-tasks inherit sequencing from their parent and cannot be edited individually."' : '';
        const row = sequencesOverviewTbody.insertRow();
        row.innerHTML = `
            <td>${predecessorsHtml}</td>
            <td><strong>${data.displayName}</strong></td>
            <td>${successorsHtml}</td>
            <td class="actions-cell">
                <button class="btn btn-warning edit-sequence-btn" data-id="${task.id}" ${disabledAttr}>Edit</button>
            </td>
        `;
    };

    if (groupBy === 'category') {
        const groupedTasks = allTasks.reduce((acc, task) => {
            const category = task.category || (task.type === 'changeOrderItem' ? 'Change Orders' : 'Uncategorized');
            if (!acc[category]) acc[category] = [];
            acc[category].push(task);
            return acc;
        }, {});
        Object.keys(groupedTasks).sort().forEach(category => {
            const headerRow = sequencesOverviewTbody.insertRow();
            headerRow.className = 'category-header-row';
            headerRow.innerHTML = `<td colspan="4">${category}</td>`;
            groupedTasks[category].forEach(renderTaskRow);
        });
    } else {
        allTasks.forEach(renderTaskRow);
    }
};

const handleEditSequenceClick = async (taskId) => {
    const allTasks = await getAllProjectTasks(currentSequencingProjectId);
    const currentTask = allTasks.find(t => String(t.id) === String(taskId));
    if (!currentTask) return;

    sequenceModalTitle.textContent = `Edit Sequence for: ${currentTask.displayName}`;
    editingTaskIdInput.value = taskId;
    
    const otherTasks = allTasks.filter(t => String(t.id) !== String(taskId));
    modalPredecessorsSelect.innerHTML = `<option value="PROJECT_START">-- Project Start --</option>`;
    modalSuccessorsSelect.innerHTML = `<option value="PROJECT_END">-- Project End --</option>`;
    otherTasks.forEach(t => {
        const optionHtml = `<option value="${t.id}">${t.displayName}</option>`;
        modalPredecessorsSelect.innerHTML += optionHtml;
        modalSuccessorsSelect.innerHTML += optionHtml;
    });

    const parsedTaskId = isNaN(parseInt(taskId)) ? taskId : parseInt(taskId);

    const existingPredecessorLinks = await db.tasks.where({ projectId: currentSequencingProjectId, successorId: parsedTaskId }).toArray();
    const existingPredecessorIds = existingPredecessorLinks.map(link => link.predecessorId);
    Array.from(modalPredecessorsSelect.options).forEach(opt => {
        opt.selected = existingPredecessorIds.some(id => String(id) === opt.value);
    });

    const existingSuccessorLinks = await db.tasks.where({ projectId: currentSequencingProjectId, predecessorId: parsedTaskId }).toArray();
    const existingSuccessorIds = existingSuccessorLinks.map(link => link.successorId);
    Array.from(modalSuccessorsSelect.options).forEach(opt => {
        opt.selected = existingSuccessorIds.some(id => String(id) === opt.value);
    });

    openSequenceEditModal();
};

const showSequencesForProject = async (projectId, projectName) => {
    currentSequencingProjectId = projectId;
    sequencingProjectName.textContent = projectName;
    sequencingProjectListView.classList.add('hidden');
    sequencingTasksView.classList.remove('hidden');
    await displaySequencesOverview();
};

function initializeSequencingModule() {
    sequencingView.addEventListener('click', (e) => {
        if (e.target.classList.contains('view-sequences-btn')) {
            showSequencesForProject(parseInt(e.target.dataset.id), e.target.dataset.name);
        }
    });

    sequencesOverviewTbody.addEventListener('click', (e) => {
        if (e.target.classList.contains('edit-sequence-btn')) {
            const taskId = e.target.dataset.id;
            console.log('Edit button clicked in main table. Task ID:', taskId);
            handleEditSequenceClick(taskId);
        }
    });

    unsequencedTasksList.addEventListener('click', (e) => {
        if (e.target.tagName === 'LI') {
            const taskId = e.target.dataset.id;
            console.log('Unsequenced task item clicked. Task ID:', taskId);
            handleEditSequenceClick(taskId);
        }
    });

    // REMOVE the old button listener for 'sort-sequences-btn'
    // sortSequencesBtn.addEventListener('click', displaySequencesOverview);

    // ADD these new listeners for the dropdowns
    document.getElementById('sequence-sort').addEventListener('change', displaySequencesOverview);
    document.getElementById('sequence-group').addEventListener('change', displaySequencesOverview);

    sequenceModalClose.addEventListener('click', closeSequenceEditModal);

    sequenceEditForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const currentTaskId = parseInt(editingTaskIdInput.value);
        if (!currentTaskId) return;

        const newPredecessorIds = new Set(Array.from(modalPredecessorsSelect.selectedOptions).map(opt => opt.value === 'PROJECT_START' ? 'PROJECT_START' : parseInt(opt.value)));
        const newSuccessorIds = new Set(Array.from(modalSuccessorsSelect.selectedOptions).map(opt => opt.value === 'PROJECT_END' ? 'PROJECT_END' : parseInt(opt.value)));

        await db.transaction('rw', db.tasks, async () => {
            await db.tasks.where({ successorId: currentTaskId, projectId: currentSequencingProjectId }).delete();
            await db.tasks.where({ predecessorId: currentTaskId, projectId: currentSequencingProjectId }).delete();

            const linksToAdd = [];
            newPredecessorIds.forEach(id => linksToAdd.push({ projectId: currentSequencingProjectId, predecessorId: id, successorId: currentTaskId }));
            newSuccessorsIds.forEach(id => linksToAdd.push({ projectId: currentSequencingProjectId, predecessorId: currentTaskId, successorId: id }));
            
            if (linksToAdd.length > 0) await db.tasks.bulkAdd(linksToAdd);
        });
        
        closeSequenceEditModal();
        await displaySequencesOverview();
    });
}
</file>

<file path="js/takeoff.js">
// js/takeoff.js

let takeoffModuleInitialized = false;

// --- DOM References ---
const takeoffProjectsListDiv = document.getElementById('takeoff-projects-list');
const quantitiesProjectName = document.getElementById('quantities-project-name');
const addQuantityBtn = document.getElementById('add-quantity-btn');
const quantitiesTableBody = document.querySelector('#quantities-table tbody');
const quantityModal = document.getElementById('quantity-modal');
const quantityModalClose = document.querySelector('.quantity-modal-close');
const quantityModalTitle = document.getElementById('quantity-modal-title');
const quantityForm = document.getElementById('quantity-form');
const quantityIdInput = document.getElementById('quantityId');
const categoryInput = document.getElementById('category');
const categoryList = document.getElementById('category-list');
const scopeOfWorkInput = document.getElementById('scopeOfWork');
const quantityInput = document.getElementById('quantity');
const unitInput = document.getElementById('unit');
const addSubquantityBtn = document.getElementById('add-subquantity-btn');
const subquantitiesTableBody = document.querySelector('#subquantities-table tbody');

// --- Functions ---
const openQuantityModal = () => quantityModal.style.display = 'block';
const closeQuantityModal = () => quantityModal.style.display = 'none';

const populateCategoryDatalist = async () => {
    const allCategories = await db.quantities.orderBy('category').uniqueKeys();
    categoryList.innerHTML = allCategories.map(cat => `<option value="${cat}"></option>`).join('');
};

const displayTakeOffProjects = async () => {
    const allProjects = await db.projects.orderBy('projectName').toArray();
    takeoffProjectsListDiv.innerHTML = '';
    if (allProjects.length === 0) {
        takeoffProjectsListDiv.innerHTML = '<p>No projects created yet. Add one in the "Projects" module first.</p>';
    } else {
        allProjects.forEach(project => {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.innerHTML = `<h3>${project.projectName}</h3><button class="btn btn-primary view-quantities-btn" data-id="${project.id}" data-name="${project.projectName}">View Quantities</button>`;
            takeoffProjectsListDiv.appendChild(item);
        });
    }
};

const displayQuantities = async () => {
    const quantities = await db.quantities.where('projectId').equals(currentProjectId).toArray();
    const lockedBoq = await db.boqs.get({ projectId: currentProjectId });
    const isLocked = !!lockedBoq;

    quantitiesTableBody.innerHTML = '';
    if (quantities.length === 0) {
        quantitiesTableBody.innerHTML = '<tr><td colspan="4">No quantities added for this project yet.</td></tr>';
        return;
    }
    const grouped = quantities.reduce((acc, q) => {
        const category = q.category || 'Uncategorized';
        if (!acc[category]) { acc[category] = []; }
        acc[category].push(q);
        return acc;
    }, {});
    const sortedCategories = Object.keys(grouped).sort();
    for (const category of sortedCategories) {
        const headerRow = quantitiesTableBody.insertRow();
        headerRow.className = 'category-header-row';
        headerRow.innerHTML = `<td colspan="4">${category}</td>`;
        grouped[category].forEach(q => {
            const row = quantitiesTableBody.insertRow();
            row.innerHTML = `<td>${q.scopeOfWork}</td><td>${q.quantity}</td><td>${q.unit}</td><td class="actions-cell"><button class="btn btn-warning edit-quantity-btn" data-id="${q.id}" ${isLocked ? 'disabled' : ''}>Edit</button><button class="btn btn-danger delete-quantity-btn" data-id="${q.id}" ${isLocked ? 'disabled' : ''}>Delete</button></td>`;
        });
    }
};

const showQuantitiesForProject = async (projectId, projectName) => {
    currentProjectId = projectId;
    quantitiesProjectName.textContent = projectName;
    takeoffProjectListView.classList.add('hidden');
    takeoffQuantitiesView.classList.remove('hidden');

    const lockedBoq = await db.boqs.get({ projectId: projectId });
    addQuantityBtn.disabled = !!lockedBoq;

    await displayQuantities();
};

const addSubquantityRow = (data = {}) => {
    const row = subquantitiesTableBody.insertRow();
    row.innerHTML = `
        <td><input type="text" class="subquantity-name" value="${data.name || ''}" placeholder="e.g., External Walls" required></td>
        <td><input type="number" class="subquantity-value" value="${data.quantity || ''}" step="any" required></td>
        <td><button type="button" class="btn-remove">X</button></td>
    `;
};

const updateMainQuantityFromSubs = () => {
    const rows = subquantitiesTableBody.querySelectorAll('tr');
    if (rows.length > 0) {
        let total = 0;
        rows.forEach(row => {
            const value = parseFloat(row.querySelector('.subquantity-value').value);
            if (!isNaN(value)) {
                total += value;
            }
        });
        quantityInput.value = total;
        quantityInput.readOnly = true;
    } else {
        quantityInput.readOnly = false;
    }
};

function initializeTakeoffModule() {
    if (takeoffModuleInitialized) return;

    takeoffProjectsListDiv.addEventListener('click', (event) => {
        if (event.target.classList.contains('view-quantities-btn')) {
            const id = parseInt(event.target.dataset.id);
            const name = event.target.dataset.name;
            showQuantitiesForProject(id, name);
        }
    });

    addQuantityBtn.addEventListener('click', async () => {
        await populateCategoryDatalist();
        quantityModalTitle.textContent = 'Add Quantity';
        quantityForm.reset();
        quantityIdInput.value = '';
        subquantitiesTableBody.innerHTML = '';
        quantityInput.readOnly = false;
        openQuantityModal();
    });

    quantityModalClose.addEventListener('click', closeQuantityModal);
    
    addSubquantityBtn.addEventListener('click', addSubquantityRow);

    quantityForm.addEventListener('input', (e) => {
        if (e.target.classList.contains('subquantity-value')) {
            updateMainQuantityFromSubs();
        }
    });

    quantityForm.addEventListener('click', (e) => {
        if (e.target.classList.contains('btn-remove')) {
            e.target.closest('tr').remove();
            updateMainQuantityFromSubs();
        }
    });

    quantityForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        updateMainQuantityFromSubs();
        
        const id = parseInt(quantityIdInput.value);
        
        const subquantities = [];
        subquantitiesTableBody.querySelectorAll('tr').forEach(row => {
            subquantities.push({
                name: row.querySelector('.subquantity-name').value,
                quantity: parseFloat(row.querySelector('.subquantity-value').value)
            });
        });

        const quantityData = {
            scopeOfWork: scopeOfWorkInput.value,
            quantity: parseFloat(quantityInput.value),
            unit: unitInput.value,
            category: categoryInput.value.trim(),
            projectId: currentProjectId,
            subquantities: subquantities.length > 0 ? subquantities : null
        };

        if (id) await db.quantities.update(id, quantityData);
        else await db.quantities.add(quantityData);
        
        closeQuantityModal();
        await displayQuantities();
    });

    quantitiesTableBody.addEventListener('click', async (event) => {
        const target = event.target;
        const id = parseInt(target.dataset.id);
        if (target.classList.contains('edit-quantity-btn')) {
            await populateCategoryDatalist();
            const quantity = await db.quantities.get(id);
            quantityModalTitle.textContent = 'Edit Quantity';
            quantityIdInput.value = quantity.id;
            categoryInput.value = quantity.category;
            scopeOfWorkInput.value = quantity.scopeOfWork;
            quantityInput.value = quantity.quantity;
            unitInput.value = quantity.unit;

            subquantitiesTableBody.innerHTML = '';
            if (quantity.subquantities && quantity.subquantities.length > 0) {
                quantity.subquantities.forEach(sub => addSubquantityRow(sub));
                quantityInput.readOnly = true;
            } else {
                quantityInput.readOnly = false;
            }

            openQuantityModal();
        }
        if (target.classList.contains('delete-quantity-btn')) {
            if (confirm('Are you sure you want to delete this quantity?')) {
                await db.quantities.delete(id);
                await displayQuantities();
            }
        }
    });

    takeoffModuleInitialized = true;
}
</file>

<file path="js/app.js">
// Author: -REPLACE WITH YOUR NAME-
// OS support: -REPLACE WITH YOUR OS SUPPORT-
// Description: Main application entry point, state management, and initialization.

// --- Global State Variables ---
let currentProjectId = null;
let currentDupaProjectId = null;
let currentDupaQuantityId = null;
let currentSequencingProjectId = null;
let currentBoqProjectId = null;

// --- Application Initialization ---
// Replace the entire document.addEventListener('DOMContentLoaded',...) block with this:
window.addEventListener('load', () => {
    db.open().then(() => {
        console.log("Database opened successfully.");
        // This is now safe because the 'load' event guarantees the mermaid script is ready
        mermaid.initialize({ startOnLoad: false });
        
        // Initialize all modules
        initializeViewsModule();
        initializeProjectsModule();
        initializeTakeoffModule();
        initializeDupaModule();
        initializeSequencingModule();
        initializeConstructionModule();
        initializeReportsModule();
        initializeChangeOrdersModule();
        initializeDashboardModule();
        initializeMaterialsLibraryModule();
        initializeDupaLibraryModule();
        initializeLibraryManagementModule();

        // Universal modal closing listener
        window.addEventListener('click', (event) => {
            if (event.target == projectModal) closeProjectModal();
            if (event.target == quantityModal) closeQuantityModal();
            if (event.target == copyProjectModal) closeCopyProjectModal();
            if (event.target == dupaReportModal) closeDupaReportModal();
            if (event.target == coModal) closeCoModal();
            if (event.target == coItemDupaModal) closeCoItemDupaModal();
            if (event.target == coItemTypeModal) closeCoItemTypeModal();
            if (event.target == coExistingItemModal) closeCoExistingItemModal();
            if (event.target == importPreviewModal) closeImportPreviewModal();
        });

        // Show the initial view
        showDashboard();

    }).catch(err => {
        console.error("Failed to open db: ", err.stack || err);
    });
});
// --- End of app.js ---
</file>

<file path="js/db.js">
// Author: -REPLACE WITH YOUR NAME-
// OS support: -REPLACE WITH YOUR OS SUPPORT-
// Description: Defines the IndexedDB schema for the application.

const db = new Dexie('constructionManagerDb');

db.version(1).stores({
    projects: '++id, projectName'
});

db.version(2).stores({
    projects: '++id, projectName',
    quantities: '++id, projectId, scopeOfWork'
});

db.version(3).stores({
    projects: '++id, projectName',
    quantities: '++id, projectId, scopeOfWork, &category'
});

db.version(4).stores({
    projects: '++id, projectName',
    quantities: '++id, projectId, scopeOfWork, category'
});

db.version(5).stores({
    projects: '++id, projectName',
    quantities: '++id, projectId, scopeOfWork, category',
    dupas: '++id, &quantityId'
});

db.version(6).stores({
    projects: '++id, projectName',
    quantities: '++id, projectId, scopeOfWork, category',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId'
});

// VERSION 7: Adds the BOQ table to store locked reports.
// &projectId ensures only one locked BOQ per project.
db.version(7).stores({
    projects: '++id, projectName',
    quantities: '++id, projectId, scopeOfWork, category',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId' // Stores the locked BOQ data
});

db.version(8).stores({
    projects: '++id, projectName',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date'
});

db.version(9).stores({
    projects: '++id, projectName, startDate',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date'
});

db.version(10).stores({
    projects: '++id, projectName, startDate',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit',
    changeOrderDupas: '++id, &changeOrderItemId'
});

db.version(11).stores({
    projects: '++id, projectName, startDate',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId',
    changeOrderDupas: '++id, &changeOrderItemId'
});


db.version(12).stores({
    projects: '++id, projectName, startDate, lotArea, floorArea, numFloors',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId',
    changeOrderDupas: '++id, &changeOrderItemId'
});

db.version(13).stores({
    projects: '++id, projectName, startDate, lotArea, floorArea, numFloors, contractAmount, contractDate, projectStatus, targetStartDate, contractDuration, projectManager, clientContact',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId',
    changeOrderDupas: '++id, &changeOrderItemId'
});

db.version(14).stores({
    projects: '++id, projectName, startDate, lotArea, floorArea, numFloors, contractAmount, contractDate, projectStatus, targetStartDate, contractDuration, projectManager, clientContact',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId, percentComplete',
    changeOrderDupas: '++id, &changeOrderItemId'
});

db.version(15).stores({
    projects: '++id, projectName, startDate, lotArea, floorArea, numFloors, contractAmount, contractDate, projectStatus, targetStartDate, contractDuration, projectManager, clientContact',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId, percentComplete',
    changeOrderDupas: '++id, &changeOrderItemId',
    
    // New Library Tables
    materials: '++id, &name',
    resources: '++id, &[name+type]',
    crews: '++id, &name',
    crewComposition: '++id, crewId, resourceId'
});

db.version(16).stores({
    projects: '++id, projectName, startDate, lotArea, floorArea, numFloors, contractAmount, contractDate, projectStatus, targetStartDate, contractDuration, projectManager, clientContact',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete, subquantities',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+date], quantityId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId, percentComplete',
    changeOrderDupas: '++id, &changeOrderItemId',
    materials: '++id, &name',
    resources: '++id, &[name+type]',
    crews: '++id, &name',
    crewComposition: '++id, crewId, resourceId'
});

db.version(17).stores({
    projects: '++id, projectName, startDate, lotArea, floorArea, numFloors, contractAmount, contractDate, projectStatus, targetStartDate, contractDuration, projectManager, clientContact',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete, subquantities',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+subquantityIndex+date], quantityId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId, percentComplete',
    changeOrderDupas: '++id, &changeOrderItemId',
    materials: '++id, &name',
    resources: '++id, &[name+type]',
    crews: '++id, &name',
    crewComposition: '++id, crewId, resourceId'
});

db.version(18).stores({
    projects: '++id, projectName, startDate, lotArea, floorArea, numFloors, contractAmount, contractDate, projectStatus, targetStartDate, contractDuration, projectManager, clientContact',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete, subquantities',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    accomplishments: '++id, &[quantityId+subquantityIndex+date], &[changeOrderItemId+date], quantityId, subquantityIndex, changeOrderItemId, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId, percentComplete',
    changeOrderDupas: '++id, &changeOrderItemId',
    materials: '++id, &name',
    resources: '++id, &[name+type]',
    crews: '++id, &name',
    crewComposition: '++id, crewId, resourceId'
}).upgrade(tx => {
    // This upgrade migrates old accomplishment records to the new, clearer structure.
    return tx.table('accomplishments').toCollection().modify(async (acc) => {
        if (!acc.hasOwnProperty('quantityId')) return;
        const isQuantity = await tx.table('quantities').get(acc.quantityId);
        if (!isQuantity) {
            acc.changeOrderItemId = acc.quantityId;
            delete acc.quantityId;
        }
    });
});

db.version(19).stores({
    projects: '++id, projectName, startDate, lotArea, floorArea, numFloors, contractAmount, contractDate, projectStatus, targetStartDate, contractDuration, projectManager, clientContact',
    quantities: '++id, projectId, scopeOfWork, category, percentComplete, subquantities',
    dupas: '++id, &quantityId',
    tasks: '++id, projectId, predecessorId, successorId',
    boqs: '++id, &projectId',
    // This is the new, simplified, and robust schema for accomplishments
    accomplishments: '++id, &[type+taskId+subIndex+date], type, taskId, subIndex, date',
    changeOrders: '++id, projectId, date, status',
    changeOrderItems: '++id, changeOrderId, scopeOfWork, quantity, unit, originalQuantityId, percentComplete',
    changeOrderDupas: '++id, &changeOrderItemId',
    materials: '++id, &name',
    resources: '++id, &[name+type]',
    crews: '++id, &name',
    crewComposition: '++id, crewId, resourceId'
}).upgrade(tx => {
    // This migration converts your existing accomplishment data to the new format
    return tx.table('accomplishments').toCollection().modify(acc => {
        if (acc.changeOrderItemId !== null && acc.changeOrderItemId !== undefined) {
            acc.type = 'changeOrderItem';
            acc.taskId = acc.changeOrderItemId;
        } else {
            acc.type = 'quantity';
            acc.taskId = acc.quantityId;
        }
        acc.subIndex = (acc.subquantityIndex === undefined) ? null : acc.subquantityIndex;
        
        // Delete the old, now-redundant properties
        delete acc.quantityId;
        delete acc.subquantityIndex;
        delete acc.changeOrderItemId;
    });
});

db.version(20).stores({
    resources: '++id, &[name+type], type'
});
// --- End of db.js ---
</file>

<file path="css/style.css">
/* css/style.css */

:root {
    --primary-color: #0d6efd;
    --danger-color: #dc3545;
    --warning-color: #ffc107;
    --light-color: #f8f9fa;
    --dark-color: #212529;
    --grey-color: #6c757d;
    --background-color: #f4f7f9;
    --nav-background: #ffffff;
    --font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    --box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    --border-radius: 8px;
}

body {
    font-family: var(--font-family);
    margin: 0;
    background-color: var(--background-color);
    color: var(--dark-color);
}

/* --- Navigation Bar --- */
.navbar {
    background-color: var(--nav-background);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    padding: 0 40px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 60px;
}

.nav-brand {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--primary-color);
    text-decoration: none;
}

.navbar ul {
    list-style: none;
    margin: 0;
    padding: 0;
    display: flex;
}

.navbar ul li a {
    display: block;
    padding: 20px 15px;
    text-decoration: none;
    color: var(--grey-color);
    font-weight: 500;
    transition: color 0.3s;
}

.navbar ul li a:hover {
    color: var(--dark-color);
}

.navbar ul li a.active {
    color: var(--primary-color);
    border-bottom: 2px solid var(--primary-color);
}

.dropdown {
    position: relative;
    display: inline-block;
}

.dropdown-content {
    display: none;
    position: absolute;
    right: 0;
    background-color: var(--nav-background);
    min-width: 200px;
    box-shadow: var(--box-shadow);
    z-index: 1;
    border-radius: 0 0 var(--border-radius) var(--border-radius);
    overflow: hidden;
}

.dropdown-content a {
    color: var(--grey-color);
    padding: 12px 16px;
    text-decoration: none;
    display: block;
    white-space: nowrap;
}

.dropdown-content a:hover {
    background-color: var(--background-color);
    color: var(--dark-color);
}

.dropdown:hover .dropdown-content {
    display: block;
}
.dropdown .dropbtn.active {
    color: var(--primary-color);
}


/* --- Main Content Layout --- */
.content {
    padding: 30px 40px;
    max-width: 1200px;
    margin: 0 auto;
}

.page-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 2rem;
}

.page-header h1 {
    margin: 0;
}

/* --- Dashboard --- */
.dashboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 1.5rem;
}

.summary-card {
    background-color: #fff;
    padding: 25px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    text-align: center;
}

.summary-card h2 {
    margin-top: 0;
    color: var(--grey-color);
}

.summary-card p {
    font-size: 3rem;
    font-weight: bold;
    color: var(--primary-color);
    margin: 0;
}

/* --- Projects Page Table --- */
.table-container {
    background-color: #fff;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    overflow: auto;
}

#projects-table {
    width: 100%;
    border-collapse: collapse;
}

#projects-table th, #projects-table td {
    padding: 15px 20px;
    text-align: left;
    border-bottom: 1px solid #dee2e6;
}

#projects-table thead th {
    background-color: var(--light-color);
    font-weight: 600;
}

#projects-table tbody tr:last-child td {
    border-bottom: none;
}

#projects-table tbody tr:hover {
    background-color: #f1f3f5;
}

.actions-cell {
    display: flex;
    gap: 10px;
}

/* --- Buttons --- */
.btn {
    padding: 10px 18px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.95rem;
    font-weight: 500;
    transition: opacity 0.2s;
    color: #fff;
}
.btn:hover { opacity: 0.85; }
.btn-primary { background-color: var(--primary-color); }
.btn-danger { background-color: var(--danger-color); }
.btn-warning { background-color: var(--warning-color); color: var(--dark-color); }

.btn-sm {
    padding: 5px 10px;
    font-size: 0.85rem;
}


/* --- Modal --- */
.modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); }
.modal-content { background-color: #fff; margin: 10% auto; padding: 30px; border-radius: var(--border-radius); width: 90%; max-width: 500px; position: relative; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
.close-button { color: #aaa; position: absolute; top: 15px; right: 25px; font-size: 28px; font-weight: bold; cursor: pointer; }
.close-button:hover, .close-button:focus { color: var(--dark-color); }

#project-form { display: flex; flex-direction: column; gap: 1.2rem; }
.form-group label { font-weight: 600; margin-bottom: 8px; display: block; }
.form-group input[type="text"], .form-group textarea { width: 100%; padding: 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 1rem; box-sizing: border-box; }
.form-group input[type="text"]:focus, .form-group textarea:focus { outline: none; border-color: var(--primary-color); box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.25); }
/* Add this to the end of your style.css */
.hidden {
    display: none;
}

/* Styling for the project list in Take Off module */
.list-container {
    display: grid;
    gap: 1rem;
}

.list-item {
    background-color: #fff;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: transform 0.2s ease-in-out;
}

.list-item:hover {
    transform: translateY(-3px);
}

.list-item h3 {
    margin: 0;
    font-weight: 500;
}

/* Aligning the "Back" button with the header text */
.page-header h1 {
    margin-top: 10px;
}

.btn-secondary {
    background-color: var(--grey-color);
}

/* Add these to the end of your style.css */

/* Styling for the category headers in the quantities table */
.category-header-row td {
    background-color: #e9ecef; /* A light grey background */
    font-weight: bold;
    color: var(--dark-color);
    padding-top: 12px;
    padding-bottom: 12px;
    border-top: 2px solid #ced4da; /* A top border to separate groups */
    border-bottom: 1px solid #ced4da;
}

/* --- DUPA Module Styles --- */
.dupa-section {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: var(--border-radius);
    padding: 20px;
    margin-top: 2rem;
}

.dupa-section h3 {
    margin-top: 0;
    border-bottom: 1px solid #ccc;
    padding-bottom: 10px;
}

.dupa-section h4 {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.btn-add {
    background-color: var(--success-color, #28a745);
    color: white;
    border: none;
    border-radius: 50%;
    width: 28px;
    height: 28px;
    font-size: 1.2rem;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    padding: 0;
}

.dupa-table {
    width: 100%;
    margin-bottom: 1.5rem;
}

.dupa-table input {
    width: 95%;
}

.btn-remove {
    background-color: var(--danger-color);
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    padding: 5px 8px;
}

.indirect-grid {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 1rem;
    align-items: center;
}

.indirect-grid input {
    width: 150px;
}

/* Styling for the category headers in the DUPA quantity list */
.dupa-category-header {
    margin-top: 1.5rem;
    margin-bottom: 0.5rem;
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--primary-color);
    color: var(--dark-color);
}

.dupa-category-header:first-of-type {
    margin-top: 0;
}

/* --- Task Sequencing Module Styles --- */
.sequencing-layout {
    display: flex;
    gap: 2rem;
    align-items: flex-start;
}

.sequencing-main-panel {
    flex-grow: 1;
}

.sequencing-side-panel {
    flex-shrink: 0;
    width: 300px;
}

.sequencing-section {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: var(--border-radius);
    padding: 20px;
    margin-bottom: 2rem;
}

#sequences-overview-table td {
    vertical-align: top;
    padding-top: 15px;
    padding-bottom: 15px;
}

#sequences-overview-table ul {
    list-style-type: none;
    margin: 0;
    padding: 0;
}

#sequences-overview-table li {
    background-color: #e9ecef;
    padding: 5px 8px;
    border-radius: 4px;
    margin-bottom: 5px;
    font-size: 0.9rem;
}

#unsequenced-tasks-list {
    list-style-type: none;
    padding: 0;
    margin: 0;
}

#unsequenced-tasks-list li {
    background-color: #fff;
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #e0e0e0;
    margin-bottom: 8px;
}

.sequence-links-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin: 1rem 0;
}

.sequence-links-grid label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.5rem;
}

.sequence-links-grid select[multiple] {
    width: 100%;
    height: 250px;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #ced4da;
    font-size: 1rem;
}

/* --- Task Sequencing Module Styles --- */
.sequencing-layout {
    display: flex;
    gap: 2rem;
    align-items: flex-start;
}

.sequencing-main-panel {
    flex-grow: 1;
}

.sequencing-side-panel {
    flex-shrink: 0;
    width: 300px;
}

.sequencing-section {
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: var(--border-radius);
    padding: 20px;
    margin-bottom: 2rem;
}

#current-task-select, .sequence-links-grid select[multiple] {
    width: 100%;
    padding: 10px;
    border-radius: 6px;
    border: 1px solid #ced4da;
    font-size: 1rem;
}

.sequence-links-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin: 1rem 0;
}

.sequence-links-grid label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.5rem;
}

.sequence-links-grid select[multiple] {
    height: 200px;
}

#unsequenced-tasks-list {
    list-style-type: none;
    padding: 0;
    margin: 0;
}

#unsequenced-tasks-list li {
    background-color: #fff;
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid #e0e0e0;
    margin-bottom: 8px;
}

#task-centric-sequence-list .task-item {
    margin-bottom: 1.5rem;
}

#task-centric-sequence-list .task-item h4 {
    margin: 0 0 0.5rem 0;
    font-weight: 600;
}

#task-centric-sequence-list .task-links {
    display: grid;
    grid-template-columns: 100px 1fr;
}

#task-centric-sequence-list .task-links strong {
    color: var(--grey-color);
}

#task-centric-sequence-list .task-links ul {
    list-style-type: none;
    margin: 0;
    padding: 0 0 0.5rem 0.5rem;
    border-left: 3px solid #e0e0e0;
}

/* --- Reports Module Styles --- */
#boq-tfoot tr.boq-summary-row td {
    font-weight: bold;
    font-size: 1.1rem;
    background-color: var(--light-color);
    border-top: 2px solid var(--primary-color);
}
.status-message {
    margin: 5px 0 0 0;
    font-style: italic;
    color: var(--danger-color);
    font-weight: bold;
}
#pert-cpm-table tr.critical-path td {
    background-color: #f8d7da; /* A light red to indicate criticality */
    font-weight: bold;
}
.gantt-chart-container {
    background-color: var(--light-color);
}

.gantt-popup-wrapper {
    background: var(--dark-color) !important;
    color: white !important;
    border-radius: 6px !important;
    padding: 10px 15px !important;
}

.gantt-popup-wrapper .pointer {
    border-top-color: var(--dark-color) !important;
}
.chart-container {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    height: 60vh;
}

.mermaid-container {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    overflow: auto;
}

.mermaid {
    text-align: center;
}

#resource-schedule-table th, #resource-schedule-table td {
    white-space: nowrap;
    min-width: 50px;
    text-align: center;
}

#resource-schedule-table .sticky-col {
    text-align: left;
    min-width: 200px;
}

.sticky-col {
    position: -webkit-sticky;
    position: sticky;
    left: 0;
    z-index: 10;
    background-color: #f8f9fa;
}

#resource-schedule-table thead .sticky-col {
    z-index: 20;
    background-color: var(--light-color);
}

.category-header-row .sticky-col {
    background-color: #e9ecef;
}

.details-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 1.2rem;
    margin: 1.5rem 0;
}

.summary-container {
    background-color: #fff;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    padding: 30px;
}

.summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 25px;
    margin-bottom: 25px;
    padding-bottom: 25px;
    border-bottom: 1px solid #dee2e6;
}

.summary-item strong {
    color: var(--grey-color);
    font-size: 0.9rem;
    display: block;
    margin-bottom: 5px;
}

.summary-item span {
    font-size: 1.1rem;
}

.summary-description strong {
    color: var(--grey-color);
    font-size: 0.9rem;
}

.summary-description p {
    margin-top: 5px;
    line-height: 1.6;
    font-size: 1.1rem;
}

#project-form select {
    width: 100%;
    padding: 12px;
    border: 1px solid #ced4da;
    border-radius: 6px;
    font-size: 1rem;
    background-color: #fff;
}

.dashboard-grid-new {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1.5rem;
}

.dashboard-grid-new .summary-card p {
    font-size: 2.5rem;
}

.card-title {
    font-size: 1rem;
    font-weight: 600;
    color: var(--grey-color);
    margin-bottom: 0.5rem;
    margin-top: 0;
}

.dashboard-chart-container {
    grid-column: 1 / 3;
    background-color: #fff;
    padding: 25px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    height: 350px;
}

.dashboard-list-container {
    grid-column: 3 / 5;
    background-color: #fff;
    padding: 25px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    height: 350px;
    overflow-y: auto;
}

#attention-projects-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

#attention-projects-list li {
    padding: 15px 0;
    border-bottom: 1px solid #eee;
    display: flex;
    flex-direction: column;
}

#attention-projects-list li:last-child {
    border-bottom: none;
}

#attention-projects-list li span {
    font-size: 0.9rem;
    color: var(--grey-color);
    margin-top: 4px;
}

.report-controls {
    display: flex;
    gap: 1.5rem;
    align-items: flex-end;
    margin-bottom: 2rem;
    padding: 1.5rem;
    background-color: var(--light-color);
    border-radius: var(--border-radius);
}

.report-controls .form-group {
    margin-bottom: 0;
}

#lookahead-kpi-container {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    margin-bottom: 1.5rem;
    text-align: center;
    font-size: 1.2rem;
    font-weight: 500;
}

#lookahead-report-content .placeholder-text {
    text-align: center;
    color: var(--grey-color);
    font-size: 1.1rem;
    padding: 3rem;
}

.lookahead-task {
    background-color: #fff;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    margin-bottom: 1.5rem;
    border-left: 5px solid var(--primary-color);
}
.lookahead-task.at-risk {
    border-left-color: var(--danger-color);
}

.lookahead-task-header {
    padding: 15px 20px;
    border-bottom: 1px solid #eee;
}

.lookahead-task-header h3 {
    margin: 0;
    display: flex;
    justify-content: space-between;
}

.lookahead-task-header .status {
    font-weight: 600;
}
.lookahead-task-header .status.on-track {
    color: #198754;
}
.lookahead-task-header .status.at-risk {
    color: var(--danger-color);
}

.lookahead-task-body {
    padding: 20px;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}
.lookahead-task-body h4 {
    margin: 0 0 10px 0;
    color: var(--grey-color);
    font-size: 0.9rem;
    font-weight: 600;
}
.lookahead-task-body ul {
    list-style: none;
    padding: 0;
    margin: 0;
}

.library-controls {
    margin-bottom: 1.5rem;
}

.library-controls input[type="search"] {
    width: 100%;
    max-width: 400px;
    padding: 12px;
    border: 1px solid #ced4da;
    border-radius: 6px;
    font-size: 1rem;
}

.library-section {
    margin-top: 3rem;
}

.library-section:first-of-type {
    margin-top: 0;
}
.composition-editor {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-top: 1.5rem;
}

.resource-list-panel {
    border: 1px solid #dee2e6;
    border-radius: var(--border-radius);
    padding: 15px;
}

.resource-list-panel h4 {
    margin: 0 0 1rem 0;
}

.composition-search {
    width: 100%;
    padding: 8px;
    margin-bottom: 1rem;
    border: 1px solid #ced4da;
    border-radius: 6px;
}

#available-resources-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 400px;
    overflow-y: auto;
}

#available-resources-list li {
    padding: 8px;
    cursor: pointer;
    border-radius: 4px;
    margin-bottom: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

#available-resources-list li:hover {
    background-color: #e9ecef;
}

#crew-composition-table input[type="number"] {
    width: 60px;
    padding: 5px;
}
.dashboard-gantt-container {
    background-color: #fff;
    padding: 25px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    width: 100%;
    box-sizing: border-box;
    margin-top: 1.5rem;
}
.dashboard-gantt-container {
    grid-column: 1 / -1; /* Make it span the full width of the grid */
    background-color: #fff;
    padding: 25px;
    border-radius: var(--border-radius);
    box-shadow: var(--box-shadow);
    margin-top: 1.5rem;
}
#dashboard-gantt-chart-target .gantt .bar-wrapper {
    fill: var(--primary-color);
}
.app-footer {
    text-align: center;
}
</file>

<file path="js/construction.js">
// Author: Gemini
// OS support: Cross-platform
// Description: Logic for the construction phase modules, including accomplishment tracking and reporting.

let currentConstructionProjectId = null;
let trackingGanttChart = null;
let trackingSCurveChart = null;

const accomplishmentProjectsListDiv = document.getElementById('accomplishment-projects-list');
const accomplishmentProjectName = document.getElementById('accomplishment-project-name');
const accomplishmentEntryView = document.getElementById('accomplishment-entry-view');
const accomplishmentDateInput = document.getElementById('accomplishment-date');
const accomplishmentTableBody = document.querySelector('#accomplishment-table tbody');
const accomplishmentForm = document.getElementById('accomplishment-form');
const backToAccomplishmentProjectsBtn = document.getElementById('back-to-accomplishment-projects');
const trackingGanttChartView = document.getElementById('tracking-gantt-chart-view');
const trackingGanttProjectName = document.getElementById('tracking-gantt-project-name');
const backToTrackingGanttProjectsBtn = document.getElementById('back-to-tracking-gantt-projects');
const trackingSCurveChartView = document.getElementById('tracking-s-curve-chart-view');
const trackingSCurveProjectName = document.getElementById('tracking-s-curve-project-name');
const trackingSCurveCanvas = document.getElementById('tracking-s-curve-chart');
const backToTrackingSCurveProjectsBtn = document.getElementById('back-to-tracking-s-curve-projects');
const showAccomplishmentList = (projectId) => {
    document.getElementById('accomplishment-entry-view').classList.add('hidden');
    document.getElementById('accomplishment-detail-view').classList.add('hidden');
    document.getElementById('accomplishment-list-view').classList.remove('hidden');
    displayAccomplishmentHistory(projectId);
};

const showAccomplishmentDetail = (projectId, date) => {
    document.getElementById('accomplishment-list-view').classList.add('hidden');
    document.getElementById('accomplishment-detail-view').classList.remove('hidden');
    displayAccomplishmentDetails(projectId, date);
};
const calculateDupaTotalCost = (dupa) => {
    if (!dupa || !dupa.directCosts || !Array.isArray(dupa.directCosts) || dupa.directCosts.length === 0) return 0;
    
    let finalTotal = 0;

    if (dupa.changeOrderItemId) {
        const firstDirectCost = dupa.directCosts[0];
        if (firstDirectCost?.type === 'calculated') {
            finalTotal = firstDirectCost.total;
        } else if (firstDirectCost?.type === 'total') {
            const directCost = firstDirectCost.total;
            const ocm = directCost * (dupa.indirectCosts.ocm / 100);
            const profit = directCost * (dupa.indirectCosts.profit / 100);
            const subtotal = directCost + ocm + profit;
            const taxes = subtotal * (dupa.indirectCosts.taxes / 100);
            finalTotal = subtotal + taxes;
        }
    }
    
    if (finalTotal === 0) {
        const directCosts = dupa.directCosts.reduce((total, dc) => {
            if (!dc) return total;
            switch (dc.type) {
                case 'labor': return total + (dc.mandays * dc.rate);
                case 'material': return total + (dc.quantity * dc.unitPrice);
                case 'equipment': return total + (dc.hours * dc.rate);
                default: return total;
            }
        }, 0);
        const ocmCost = directCosts * (dupa.indirectCosts.ocm / 100);
        const profitCost = directCosts * (dupa.indirectCosts.profit / 100);
        const totalBeforeTax = directCosts + ocmCost + profitCost;
        const taxCost = totalBeforeTax * (dupa.indirectCosts.taxes / 100);
        finalTotal = totalBeforeTax + taxCost;
    }

    return Math.round(finalTotal * 100) / 100;
};

// 1. ADD THIS NEW, UNIFIED FUNCTION
// This is the new "source of truth" for fetching all task types with their real-time progress.
const getProjectTasks = async (projectId) => {
    // 1. Get all base items
    const quantities = await db.quantities.where({ projectId }).toArray();
    const approvedChangeOrders = await db.changeOrders.where({ projectId, status: 'Approved' }).toArray();
    const approvedChangeOrderIds = approvedChangeOrders.map(co => co.id);
    const changeOrderItems = approvedChangeOrderIds.length > 0
        ? await db.changeOrderItems.where('changeOrderId').anyOf(approvedChangeOrderIds).toArray()
        : [];

    // 2. Get all DUPAs to calculate costs
    const quantityIds = quantities.map(q => q.id);
    const changeOrderItemIds = changeOrderItems.map(ci => ci.id);
    const dupas = await db.dupas.where('quantityId').anyOf(quantityIds).toArray();
    const coDupas = changeOrderItemIds.length > 0 ? await db.changeOrderDupas.where('changeOrderItemId').anyOf(changeOrderItemIds).toArray() : [];
    const dupaMap = new Map();
    dupas.forEach(d => dupaMap.set(d.quantityId, d));
    coDupas.forEach(d => dupaMap.set(d.changeOrderItemId, d));

    // 3. Get all accomplishment records to calculate progress
    const qtyAccomplishments = await db.accomplishments.where('taskId').anyOf(quantityIds).and(r => r.type === 'quantity').toArray();
    // **THIS LINE IS FIXED**
    const coAccomplishments = await db.accomplishments.where('taskId').anyOf(changeOrderItemIds).and(r => r.type === 'changeOrderItem').toArray();
    const allAccomplishments = [...qtyAccomplishments, ...coAccomplishments];

    const progressMap = new Map();
    allAccomplishments.forEach(acc => {
        let key;
        if (acc.type === 'changeOrderItem') key = `co-${acc.taskId}`;
        else key = (acc.subIndex !== null) ? `sub-${acc.taskId}-${acc.subIndex}` : `qty-${acc.taskId}`;
        progressMap.set(key, (progressMap.get(key) || 0) + acc.percentComplete);
    });

    // 4. Build the final list of tasks, including their calculated cost
    const expandedTasks = [];
    quantities.forEach(q => {
        const dupa = dupaMap.get(q.id);
        const parentTotalCost = calculateDupaTotalCost(dupa);

        if (Array.isArray(q.subquantities) && q.subquantities.length > 0) {
            const numSubtasks = q.subquantities.length;
            const apportionedCost = numSubtasks > 0 ? parentTotalCost / numSubtasks : 0;
            
            q.subquantities.forEach((subName, index) => {
                const uniqueId = `sub-${q.id}-${index}`;
                expandedTasks.push({
                    uniqueId: uniqueId, id: uniqueId, quantityId: q.id, subIndex: index,
                    displayName: `${q.scopeOfWork} - ${subName.name}`, type: 'subquantity',
                    percentComplete: Math.min(100, progressMap.get(uniqueId) || 0),
                    cost: apportionedCost, category: q.category
                });
            });
        } else {
            const uniqueId = `qty-${q.id}`;
            expandedTasks.push({
                ...q, uniqueId: uniqueId, displayName: q.scopeOfWork, type: 'quantity',
                percentComplete: Math.min(100, progressMap.get(uniqueId) || 0),
                cost: parentTotalCost
            });
        }
    });

    changeOrderItems.forEach(ci => {
        const uniqueId = `co-${ci.id}`;
        const totalCost = calculateDupaTotalCost(dupaMap.get(ci.id));
        expandedTasks.push({
            ...ci, uniqueId: uniqueId, displayName: `(CO) ${ci.scopeOfWork}`,
            type: 'changeOrderItem',
            percentComplete: Math.min(100, progressMap.get(uniqueId) || 0),
            cost: totalCost
        });
    });

    // Sorting by display name is a sensible default
    return expandedTasks.sort((a, b) => a.displayName.localeCompare(b.displayName));
};


// 2. REPLACE your existing getAllTasksForReport function with this one.
// It now uses the new function and provides the data in the format your reports expect.
const getAllTasksForReport = async (projectId, isRevised = false) => {
    const allTasks = await getProjectTasks(projectId);
    
    // Reports also need the DUPA data, so we'll fetch that here.
    const quantities = await db.quantities.where({ projectId }).toArray();
    const quantityIds = quantities.map(q => q.id);
    let allDupas = quantityIds.length > 0 ? await db.dupas.where('quantityId').anyOf(quantityIds).toArray() : [];
    
    if (isRevised) {
        const approvedChangeOrders = await db.changeOrders.where({ projectId, status: 'Approved' }).toArray();
        const approvedChangeOrderIds = approvedChangeOrders.map(co => co.id);
        const changeOrderItems = approvedChangeOrderIds.length > 0 ? await db.changeOrderItems.where('changeOrderId').anyOf(approvedChangeOrderIds).toArray() : [];
        const changeOrderItemIds = changeOrderItems.map(item => item.id);
        if (changeOrderItemIds.length > 0) {
            const changeOrderDupas = await db.changeOrderDupas.where('changeOrderItemId').anyOf(changeOrderItemIds).toArray();
            allDupas.push(...changeOrderDupas);
        }
    }

    return { allTasks, allDupas };
};


// 3. REPLACE your existing getAllAccomplishmentTasks function with this one.
// It now just calls our new, reliable function.
const getAllAccomplishmentTasks = async (projectId) => {
    return await getProjectTasks(projectId);
};

const getPertCpmData = async (projectId, isRevised = false) => {
    const { allTasks, allDupas } = await getAllTasksForReport(projectId, isRevised);
    const links = await db.tasks.where('projectId').equals(projectId).toArray();
    if (allTasks.length === 0) return null;

    const dupaMap = new Map();
    allDupas.forEach(d => {
        const key = d.quantityId || d.changeOrderItemId;
        const parentId = allTasks.find(t => t.id === key || (t.parentQuantityId === key))?.parentQuantityId || key;
        dupaMap.set(key, allDupas.find(dupa => dupa.quantityId === parentId));
    });

    const tasks = new Map(allTasks.map(t => {
        const dupa = dupaMap.get(t.parentQuantityId || t.id);
        let duration = dupa?.duration || 0;

        if (t.parentQuantityId && t.totalParentQuantity > 0 && dupa) {
            const proportion = t.quantity / t.totalParentQuantity;
            duration = Math.round(dupa.duration * proportion);
        }

        return [t.id, { id: t.id, name: t.displayName, duration: duration, es: 0, ef: 0, ls: 0, lf: 0, predecessors: new Set(), successors: new Set() }]
    }));
    tasks.set('PROJECT_START', { id: 'PROJECT_START', duration: 0, es: 0, ef: 0, ls: 0, lf: 0, predecessors: new Set(), successors: new Set() });
    tasks.set('PROJECT_END', { id: 'PROJECT_END', duration: 0, es: 0, ef: 0, ls: 0, lf: 0, predecessors: new Set(), successors: new Set() });
    
    links.forEach(link => {
        if (tasks.has(link.predecessorId) && tasks.has(link.successorId)) {
            tasks.get(link.successorId).predecessors.add(link.predecessorId);
            tasks.get(link.predecessorId).successors.add(link.successorId);
        }
    });

    const sortedNodes = [];
    const queue = new Map();
    tasks.forEach((task, id) => {
        queue.set(id, task.predecessors.size);
        if (task.predecessors.size === 0) {
            sortedNodes.push(id);
        }
    });
    
    let head = 0;
    while(head < sortedNodes.length) {
        const currentId = sortedNodes[head++];
        const currentNode = tasks.get(currentId);
        if (!currentNode) continue;

        currentNode.ef = currentNode.es + currentNode.duration;

        currentNode.successors.forEach(succId => {
            const succNode = tasks.get(succId);
            if(succNode) {
                succNode.es = Math.max(succNode.es, currentNode.ef);
                const newPredCount = queue.get(succId) - 1;
                queue.set(succId, newPredCount);
                if (newPredCount === 0) {
                    sortedNodes.push(succId);
                }
            }
        });
    }

    const projectDuration = tasks.get('PROJECT_END').ef;
    tasks.forEach(task => task.lf = projectDuration);
    for (let i = sortedNodes.length - 1; i >= 0; i--) {
        const currentId = sortedNodes[i];
        const currentNode = tasks.get(currentId);
        if (!currentNode) continue;

        if (currentNode.successors.size === 0) currentNode.lf = projectDuration;
        currentNode.ls = currentNode.lf - currentNode.duration;
        currentNode.predecessors.forEach(predId => {
            const predNode = tasks.get(predId);
            if(predNode) {
                predNode.lf = Math.min(predNode.lf, currentNode.ls);
            }
        });
    }
    return { tasks, quantities: allTasks, projectDuration, links, allDupas };
};

const getSCurveData = async (projectId, isRevised = false) => {
    const pertData = await getPertCpmData(projectId, isRevised);
    const project = await db.projects.get(projectId);

    if (!pertData || pertData.projectDuration === 0) return null;

    const { tasks, quantities, projectDuration } = pertData;
    
    const { allDupas } = await getAllTasksForReport(projectId, isRevised);
    const dupaMap = new Map();
    allDupas.forEach(d => {
        const key = d.quantityId || d.changeOrderItemId;
        dupaMap.set(key, d);
    });

    let grandTotalCost = 0;
    const parentQuantityMap = new Map((await db.quantities.where({ projectId }).toArray()).map(q => [q.id, q]));
    
    quantities.forEach(q => {
        if (q.type === 'subquantity') {
            const parentDupa = dupaMap.get(q.quantityId);
            const parentQuantity = parentQuantityMap.get(q.quantityId);
            const parentTotalCost = calculateDupaTotalCost(parentDupa);
            const numSubtasks = parentQuantity?.subquantities?.length || 1;
            grandTotalCost += parentTotalCost / numSubtasks;
        } else {
            const dupa = dupaMap.get(q.id);
            grandTotalCost += calculateDupaTotalCost(dupa);
        }
    });

    if (grandTotalCost === 0) return null;

    const dailyCosts = new Array(projectDuration + 1).fill(0);
    quantities.forEach(q => {
        const task = tasks.get(q.id);
        if (!task) return;
        let totalTaskCost = 0;
        if (q.type === 'subquantity') {
            const parentDupa = dupaMap.get(q.quantityId);
            const parentQuantity = parentQuantityMap.get(q.quantityId);
            const parentTotalCost = calculateDupaTotalCost(parentDupa);
            const numSubtasks = parentQuantity?.subquantities?.length || 1;
            totalTaskCost = parentTotalCost / numSubtasks;
        } else {
            totalTaskCost = calculateDupaTotalCost(dupaMap.get(q.id));
        }
        if (task.duration > 0) {
            const costPerDay = totalTaskCost / task.duration;
            for (let day = task.es; day < task.ef; day++) {
                if (day < dailyCosts.length) dailyCosts[day] += costPerDay;
            }
        }
    });

    let cumulativeSum = 0;
    const cumulativeCosts = Array.from({ length: projectDuration }, (_, i) => {
        cumulativeSum += dailyCosts[i];
        return cumulativeSum;
    });
    
    const plannedPercentage = cumulativeCosts.map(cost => (cost / grandTotalCost) * 100);

    const labels = [];
    if (project.startDate) {
        const projectStartDate = new Date(project.startDate);
        projectStartDate.setMinutes(projectStartDate.getMinutes() + projectStartDate.getTimezoneOffset());
        const dateFormatter = new Intl.DateTimeFormat('en-US', { month: 'short', day: 'numeric' });
        for (let i = 0; i < projectDuration; i++) {
            const currentDate = new Date(projectStartDate);
            currentDate.setDate(currentDate.getDate() + i);
            labels.push(dateFormatter.format(currentDate));
        }
    } else {
        for (let i = 0; i < projectDuration; i++) {
            labels.push(`Day ${i + 1}`);
        }
    }

    return {
        labels: labels,
        plannedPercentage: plannedPercentage,
        grandTotalCost: grandTotalCost,
        projectDuration: projectDuration
    };
};

const displayAccomplishmentProjects = async () => {
    const allProjects = await db.projects.orderBy('projectName').toArray();
    accomplishmentProjectsListDiv.innerHTML = '';
    if (allProjects.length === 0) {
        accomplishmentProjectsListDiv.innerHTML = '<p>No projects with a generated BOQ found. Please generate a BOQ in the "Pre-construction Reports" module first.</p>';
    } else {
        allProjects.forEach(p => {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary view-accomplishment-btn" data-id="${p.id}" data-name="${p.projectName}">Select</button>`;
            accomplishmentProjectsListDiv.appendChild(item);
        });
    }
};

const populateAccomplishmentTable = async (projectId) => {
    try {
        console.log('Fetching all accomplishment tasks...');
        const allTasks = await getAllAccomplishmentTasks(projectId);
        console.log(`Found ${allTasks.length} tasks.`);
        const pertData = await getPertCpmData(projectId, true);
        console.log('PERT data fetched for sorting.');
        
        if (pertData && pertData.tasks) {
            const esMap = new Map();
            pertData.tasks.forEach((task, id) => esMap.set(id, task.es));
            allTasks.sort((a, b) => (esMap.get(a.id) || Infinity) - (esMap.get(b.id) || Infinity) || a.displayName.localeCompare(b.displayName));
            console.log('Tasks sorted by Early Start date.');
        }
        
        accomplishmentTableBody.innerHTML = '';
        if (allTasks.length === 0) {
            accomplishmentTableBody.innerHTML = '<tr><td colspan="3">No tasks found for this project.</td></tr>';
            console.log('Rendered empty table message.');
            return;
        }

        allTasks.forEach(task => {
            const row = accomplishmentTableBody.insertRow();
            const overallProgress = task.percentComplete || 0;
            row.dataset.taskId = task.id;
            row.dataset.parentQuantityId = task.parentQuantityId || task.id;
            row.dataset.isSubtask = !!task.parentQuantityId;
            
            row.innerHTML = `
                <td>${task.displayName}</td>
                <td><progress value="${overallProgress}" max="100"></progress> ${overallProgress.toFixed(2)}%</td>
                <td><input type="number" class="progress-input" min="0" max="${(100 - overallProgress).toFixed(2)}" step="any" placeholder="0.00"> %</td>
            `;
        });
        console.log(`Rendered ${allTasks.length} tasks into the table.`);
    } catch (error) {
        console.error('Error populating accomplishment table:', error);
        accomplishmentTableBody.innerHTML = '<tr><td colspan="3">Could not load tasks due to an error.</td></tr>';
    }
};

const showAccomplishmentForm = async (projectId, projectName) => {
    currentConstructionProjectId = projectId;
    accomplishmentProjectName.textContent = projectName;
    
    showView(accomplishmentView);
    document.getElementById('accomplishment-project-list-view').classList.add('hidden');
    document.getElementById('accomplishment-list-view').classList.add('hidden');
    document.getElementById('accomplishment-detail-view').classList.add('hidden');
    accomplishmentEntryView.classList.remove('hidden');

    accomplishmentDateInput.removeAttribute('readonly');
    document.getElementById('view-past-reports-btn').classList.remove('hidden');
    accomplishmentDateInput.valueAsDate = new Date();
    accomplishmentTableBody.innerHTML = '<tr><td colspan="3">Loading tasks...</td></tr>';
    
    const project = await db.projects.get(projectId);
    if (!project.startDate) {
        const inputDate = prompt("This is the first report for this project.\nPlease enter the Project Start Date (YYYY-MM-DD):");
        if (inputDate && !isNaN(new Date(inputDate))) {
            await db.projects.update(projectId, { startDate: inputDate });
        } else {
            alert("Invalid date. Please select the project again to set a valid start date.");
            showAccomplishment();
            return;
        }
    }

    let allTasks = await getProjectTasks(projectId);
    const pertData = await getPertCpmData(projectId, true);
    
    const sortBy = document.getElementById('accomplishment-sort').value;
    if (pertData && pertData.tasks) {
        const startTaskIds = new Set(pertData.links
            .filter(link => link.predecessorId === 'PROJECT_START')
            .map(link => link.successorId)
        );

        const esMap = new Map(Array.from(pertData.tasks.values()).map(task => [task.id, task.es]));
        allTasks.sort((a, b) => {
            if (sortBy === 'name') return a.displayName.localeCompare(b.displayName);
            if (sortBy === 'progress') return (a.percentComplete || 0) - (b.percentComplete || 0);

            const aIsStart = startTaskIds.has(a.id);
            const bIsStart = startTaskIds.has(b.id);

            if (aIsStart && !bIsStart) return -1;
            if (!aIsStart && bIsStart) return 1;

            const taskA_es = esMap.get(a.id) || Infinity;
            const taskB_es = esMap.get(b.id) || Infinity;
            if (taskA_es === taskB_es) return a.displayName.localeCompare(b.displayName);
            return taskA_es - taskB_es;
        });
    }

    accomplishmentTableBody.innerHTML = '';
    if (allTasks.length === 0) {
        accomplishmentTableBody.innerHTML = '<tr><td colspan="3">No tasks found for this project.</td></tr>';
        return;
    }

    const groupBy = document.getElementById('accomplishment-group').value;

    const renderTaskRow = (task) => {
        const row = accomplishmentTableBody.insertRow();
        const overallProgress = task.percentComplete || 0;
        row.dataset.uniqueId = task.uniqueId;
        row.dataset.type = task.type;
        if (task.type === 'subquantity') {
            row.dataset.quantityId = task.quantityId;
            row.dataset.subquantityIndex = task.subIndex;
        } else {
            row.dataset.quantityId = task.id;
        }
        row.innerHTML = `
            <td>${task.displayName}</td>
            <td><progress value="${overallProgress}" max="100"></progress> ${overallProgress.toFixed(2)}%</td>
            <td><input type="number" class="progress-input" min="0" max="${(100 - overallProgress).toFixed(2)}" step="any" placeholder="0.00"> %</td>
        `;
    };

    if (groupBy === 'category') {
        const groupedTasks = allTasks.reduce((acc, task) => {
            const category = task.category || (task.type === 'changeOrderItem' ? 'Change Orders' : 'Uncategorized');
            if (!acc[category]) acc[category] = [];
            acc[category].push(task);
            return acc;
        }, {});
        
        Object.keys(groupedTasks).sort().forEach(category => {
            const tasksInCategory = groupedTasks[category];
            
            let totalCategoryValue = 0;
            let accomplishedCategoryValue = 0;
            tasksInCategory.forEach(task => {
                const taskCost = task.cost || 0;
                totalCategoryValue += taskCost;
                accomplishedCategoryValue += taskCost * ((task.percentComplete || 0) / 100);
            });
            const categoryWeightedProgress = (totalCategoryValue > 0)
                ? (accomplishedCategoryValue / totalCategoryValue) * 100
                : 0;

            const headerRow = accomplishmentTableBody.insertRow();
            headerRow.className = 'category-header-row';
            headerRow.innerHTML = `
                <td colspan="2">${category}</td>
                <td style="font-weight: 500;">
                    <progress value="${categoryWeightedProgress}" max="100" style="width: 70%; vertical-align: middle;"></progress> 
                    ${categoryWeightedProgress.toFixed(2)}%
                </td>
            `;
            tasksInCategory.forEach(renderTaskRow);
        });
    } else {
        allTasks.forEach(renderTaskRow);
    }
};

const displayAccomplishmentHistory = async (projectId) => {
    document.getElementById('accomplishment-list-project-name').textContent = `Past Reports: ${accomplishmentProjectName.textContent}`;
    const historyTableBody = document.querySelector('#accomplishment-history-table tbody');
    if (!historyTableBody) return; // Safety check
    historyTableBody.innerHTML = '<tr><td colspan="3">Loading...</td></tr>';

    // 1. Get all tasks, which now includes their calculated costs
    const allTasks = await getProjectTasks(projectId);
    if (allTasks.length === 0) {
        historyTableBody.innerHTML = '<tr><td colspan="3">No tasks found for this project.</td></tr>';
        return;
    }
    const taskMap = new Map(allTasks.map(t => [t.uniqueId, t]));

    // 2. Calculate the total value of the entire project
    const totalProjectValue = allTasks.reduce((sum, task) => sum + (task.cost || 0), 0);

    // 3. Fetch all accomplishment records for the project
    const quantityTaskIds = allTasks.filter(t => t.type !== 'changeOrderItem').map(t => t.quantityId || t.id);
    const coTaskIds = allTasks.filter(t => t.type === 'changeOrderItem').map(t => t.id);
    const qtyAccomplishments = await db.accomplishments.where('taskId').anyOf(quantityTaskIds).and(r => r.type === 'quantity').toArray();
    const coAccomplishments = coTaskIds.length > 0 ? await db.accomplishments.where('taskId').anyOf(coTaskIds).and(r => r.type === 'changeOrderItem').toArray() : [];
    const allReports = [...qtyAccomplishments, ...coAccomplishments];

    // 4. Group reports by date and sum their cost-weighted "earned value"
    const dailyEarnedValue = allReports.reduce((acc, report) => {
        const date = report.date;
        let taskUniqueId;
        if (report.type === 'changeOrderItem') {
            taskUniqueId = `co-${report.taskId}`;
        } else {
            taskUniqueId = (report.subIndex !== null) ? `sub-${report.taskId}-${report.subIndex}` : `qty-${report.taskId}`;
        }
        
        const task = taskMap.get(taskUniqueId);
        const taskCost = task ? (task.cost || 0) : 0;
        const earnedValue = taskCost * (report.percentComplete / 100);
        
        acc.set(date, (acc.get(date) || 0) + earnedValue);
        return acc;
    }, new Map());
    
    const sortedDates = [...dailyEarnedValue.keys()].sort((a, b) => new Date(b) - new Date(a));

    if (sortedDates.length === 0) {
        historyTableBody.innerHTML = '<tr><td colspan="3">No past accomplishment reports found.</td></tr>';
        return;
    }

    historyTableBody.innerHTML = '';
    sortedDates.forEach(date => {
        const earnedValueForDay = dailyEarnedValue.get(date);
        // 5. Calculate the day's progress as a percentage of the TOTAL project value
        const weightedPercent = (totalProjectValue > 0) ? (earnedValueForDay / totalProjectValue) * 100 : 0;
        
        const row = historyTableBody.insertRow();
        row.innerHTML = `
            <td>${new Date(date).toLocaleDateString(undefined, { timeZone: 'UTC', year: 'numeric', month: 'long', day: 'numeric' })}</td>
            <td><strong>${weightedPercent.toFixed(2)}%</strong></td>
            <td class="actions-cell"><button class="btn btn-primary view-accomplishment-detail-btn" data-date="${date}">View</button></td>
        `;
    });
};
const displayAccomplishmentDetails = async (projectId, date) => {
    document.getElementById('accomplishment-detail-title').textContent = `Report for: ${new Date(date).toLocaleDateString(undefined, { timeZone: 'UTC' })}`;
    document.getElementById('edit-accomplishment-btn').dataset.date = date;
    const detailTableBody = document.querySelector('#accomplishment-detail-table tbody');
    detailTableBody.innerHTML = '<tr><td colspan="2">Loading details...</td></tr>';

    // Use the new, correct getProjectTasks function to get a map of all task names
    const allTasks = await getProjectTasks(projectId);
    const taskMap = new Map(allTasks.map(t => [t.uniqueId, t.displayName]));

    // Fetch the reports for the specific date
    const reportsForDate = await db.accomplishments.where('date').equals(date).toArray();
    // Filter down to only reports for this project (since accomplishments table has no projectId)
    const projectReports = reportsForDate.filter(r => {
        const taskUniqueId = r.type === 'changeOrderItem' ? `co-${r.taskId}` : 
                             (r.subIndex !== null ? `sub-${r.taskId}-${r.subIndex}` : `qty-${r.taskId}`);
        return taskMap.has(taskUniqueId);
    });

    if (projectReports.length === 0) {
        detailTableBody.innerHTML = '<tr><td colspan="2">No accomplishments recorded for this date.</td></tr>';
        return;
    }

    detailTableBody.innerHTML = '';
    projectReports.forEach(report => {
        const taskUniqueId = report.type === 'changeOrderItem' ? `co-${report.taskId}` : 
                             (report.subIndex !== null ? `sub-${report.taskId}-${report.subIndex}` : `qty-${report.taskId}`);
        const taskName = taskMap.get(taskUniqueId) || 'Unknown Task';
        
        const row = detailTableBody.insertRow();
        row.innerHTML = `
            <td>${taskName}</td>
            <td>${report.percentComplete.toFixed(2)}%</td>
        `;
    });
};

const editAccomplishmentReport = async (projectId, date) => {
    // Show the correct view and pre-fill the form for editing
    showView(accomplishmentView);
    accomplishmentEntryView.classList.remove('hidden');
    document.getElementById('accomplishment-list-view').classList.add('hidden');
    document.getElementById('accomplishment-detail-view').classList.add('hidden');
    accomplishmentDateInput.value = date;
    accomplishmentDateInput.setAttribute('readonly', true);
    document.getElementById('view-past-reports-btn').classList.add('hidden');

    // Get the comprehensive list of all tasks using our reliable, updated function
    const allTasks = await getProjectTasks(projectId);
    
    // Fetch all accomplishment records for the specific date using the correct 'date' index
    const reportsForDate = await db.accomplishments.where({ date }).toArray();
    
    // Create a map of the reports using the uniqueId format for easy lookup
    const reportMap = new Map();
    reportsForDate.forEach(r => {
        let key;
        if (r.type === 'changeOrderItem') {
            key = `co-${r.taskId}`;
        } else { // type is 'quantity'
            key = (r.subIndex !== undefined && r.subIndex !== null)
                ? `sub-${r.taskId}-${r.subIndex}`
                : `qty-${r.taskId}`;
        }
        reportMap.set(key, r);
    });

    accomplishmentTableBody.innerHTML = '';
    for (const task of allTasks) {
        const report = reportMap.get(task.uniqueId);
        const overallProgress = task.percentComplete || 0;
        const progressOnDate = report ? report.percentComplete : 0;
        // This is the progress already recorded BEFORE the date we are editing
        const progressBeforeDate = overallProgress - progressOnDate;

        const row = accomplishmentTableBody.insertRow();
        // Set the necessary data attributes for the submit handler
        row.dataset.uniqueId = task.uniqueId;
        row.dataset.type = task.type;
        if (task.type === 'subquantity') {
            row.dataset.quantityId = task.quantityId;
            row.dataset.subquantityIndex = task.subIndex;
        } else {
            row.dataset.quantityId = task.id; // This is the numeric taskId
        }
        if (report) row.dataset.accomplishmentId = report.id;
        
        row.innerHTML = `
            <td>${task.displayName}</td>
            <td><progress value="${progressBeforeDate}" max="100"></progress> ${progressBeforeDate.toFixed(2)}%</td>
            <td><input type="number" class="progress-input" value="${progressOnDate}" min="0" max="${(100 - progressBeforeDate).toFixed(2)}" step="any"> %</td>
        `;
    }
};

const getConstructionReadyProjects = async () => {
    const allProjects = await db.projects.orderBy('projectName').toArray();
    const allBoqs = await db.boqs.toArray();
    const boqProjectIds = new Set(allBoqs.map(b => b.projectId));
    return allProjects.filter(p => boqProjectIds.has(p.id));
};

const displayTrackingGanttProjects = async () => {
    const projects = await getConstructionReadyProjects();
    const listDiv = document.getElementById('tracking-gantt-projects-list');
    listDiv.innerHTML = '';
    if (projects.length === 0) {
        listDiv.innerHTML = '<p>No projects with a generated BOQ found.</p>';
        return;
    }
    projects.forEach(p => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary view-tracking-gantt-btn" data-id="${p.id}" data-name="${p.projectName}">View Chart</button>`;
        listDiv.appendChild(item);
    });
};

const displayTrackingSCurveProjects = async () => {
    const projects = await getConstructionReadyProjects();
    const listDiv = document.getElementById('tracking-s-curve-projects-list');
    listDiv.innerHTML = '';
    if (projects.length === 0) {
        listDiv.innerHTML = '<p>No projects with a generated BOQ found.</p>';
        return;
    }
    projects.forEach(p => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary view-tracking-s-curve-btn" data-id="${p.id}" data-name="${p.projectName}">View Chart</button>`;
        listDiv.appendChild(item);
    });
};

const displayLookaheadProjects = async () => {
    const projects = await getConstructionReadyProjects();
    const listDiv = document.getElementById('lookahead-projects-list');
    listDiv.innerHTML = '';
    if (projects.length === 0) {
        listDiv.innerHTML = '<p>No projects with a generated BOQ found.</p>';
        return;
    }
    projects.forEach(p => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.innerHTML = `<h3>${p.projectName}</h3><button class="btn btn-primary select-lookahead-project-btn" data-id="${p.id}" data-name="${p.projectName}">Select</button>`;
        listDiv.appendChild(item);
    });
};

const showLookAheadReportView = (projectId, projectName) => {
    currentConstructionProjectId = projectId;
    document.getElementById('lookahead-project-list-view').classList.add('hidden');
    document.getElementById('lookahead-report-view').classList.remove('hidden');
    document.getElementById('lookahead-project-name').textContent = `Look-Ahead: ${projectName}`;
    document.getElementById('lookahead-start-date').valueAsDate = new Date();
    document.getElementById('lookahead-report-content').innerHTML = `<p class="placeholder-text">Please select a start date and click "Generate Report" to see the look-ahead schedule.</p>`;
    document.getElementById('lookahead-kpi-container').innerHTML = '';
};

const showTrackingGanttChart = async (projectId, projectName) => {
    currentConstructionProjectId = projectId; 
    document.getElementById('tracking-gantt-project-list-view').classList.add('hidden');
    trackingGanttChartView.classList.remove('hidden');
    trackingGanttProjectName.textContent = `Tracking Gantt: ${projectName}`;

    const ganttContainer = document.getElementById('tracking-gantt-chart-target');
    ganttContainer.innerHTML = 'Loading Chart...';

    const data = await getPertCpmData(projectId, true);
    const project = await db.projects.get(projectId);

    if (!project.startDate) {
        ganttContainer.innerHTML = '<p>A project start date has not been set...</p>';
        return;
    }
    if (!data || data.quantities.length === 0) {
        ganttContainer.innerHTML = 'No tasks to display.';
        return;
    }
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const projectStartDate = new Date(project.startDate);
    projectStartDate.setMinutes(projectStartDate.getMinutes() + projectStartDate.getTimezoneOffset());

    let tasksForGantt = data.quantities.map(q => {
        const task = data.tasks.get(q.id);
        if (!task) return null;
        const progress = q.percentComplete || 0;
        const startDate = new Date(projectStartDate);
        startDate.setDate(startDate.getDate() + task.es);
        const endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + task.duration);
        let status_class = '';
        if (progress >= 100) status_class = 'bar-done';
        else if (today > endDate) status_class = 'bar-behind';
        else if (today >= startDate && today <= endDate) {
            const duration = Math.max(1, task.duration);
            const daysElapsed = (today - startDate) / (1000 * 60 * 60 * 24) + 1;
            const plannedProgress = (daysElapsed / duration) * 100;
            status_class = (progress >= plannedProgress) ? 'bar-on-track' : 'bar-behind';
        }
        const dependencies = Array.from(task.predecessors)
            .filter(pId => data.tasks.has(pId))
            .map(pId => `task_${pId}`)
            .join(', ');
        return {
            id: `task_${q.id}`, name: task.name,
            start: startDate.toISOString().split('T')[0],
            end: endDate.toISOString().split('T')[0],
            progress: progress, dependencies: dependencies,
            custom_class: status_class
        };
    }).filter(Boolean);

    const sortBy = document.getElementById('tracking-gantt-sort').value;
    tasksForGantt.sort((a, b) => {
        if (sortBy === 'name') return a.name.localeCompare(b.name);
        if (sortBy === 'progress') return a.progress - b.progress;
        return new Date(a.start) - new Date(b.start);
    });

    ganttContainer.innerHTML = '';
    trackingGanttChart = new Gantt("#tracking-gantt-chart-target", tasksForGantt, {
        view_mode: 'Week',
        custom_popup_html: function(task) {
            const pertTask = data.tasks.get(task.id.replace('task_', ''));
            const duration = pertTask ? pertTask.duration : 'N/A';
            return `<div class="gantt-popup-wrapper">
                <strong>${task.name}</strong>
                <p>Progress: ${task.progress.toFixed(1)}%</p>
                <p>Duration: ${duration} days</p>
            </div>`;
        }
    });
};

const renderTrackingSCurve = async (projectId, projectName) => {
    currentConstructionProjectId = projectId;
    document.getElementById('tracking-s-curve-project-list-view').classList.add('hidden');
    trackingSCurveChartView.classList.remove('hidden');
    trackingSCurveProjectName.textContent = `Tracking S-Curve: ${projectName}`;

    const plannedData = await getSCurveData(projectId, true);
    const project = await db.projects.get(projectId);

    if (!plannedData || !project.startDate) {
        if (trackingSCurveChart) trackingSCurveChart.destroy();
        alert("Cannot generate S-Curve. Ensure the project has a start date and a locked BOQ.");
        return;
    }
    const { grandTotalCost, projectDuration } = plannedData;
    const projectStartDate = new Date(project.startDate);
    projectStartDate.setMinutes(projectStartDate.getMinutes() + projectStartDate.getTimezoneOffset());

    const { allDupas } = await getAllTasksForReport(projectId, true);
    const quantities = await db.quantities.where({ projectId }).toArray();
    const approvedChangeOrders = await db.changeOrders.where({ projectId, status: 'Approved' }).toArray();
    const approvedChangeOrderIds = approvedChangeOrders.map(co => co.id);
    const changeOrderItems = approvedChangeOrderIds.length > 0 ? await db.changeOrderItems.where('changeOrderId').anyOf(approvedChangeOrderIds).toArray() : [];
    
    const quantityTaskIds = quantities.map(q => q.id);
    const coTaskIds = changeOrderItems.map(item => item.id);
    const qtyAccomplishments = await db.accomplishments.where('taskId').anyOf(quantityTaskIds).and(r => r.type === 'quantity').toArray();
    const coAccomplishments = coTaskIds.length > 0 ? await db.accomplishments.where('taskId').anyOf(coTaskIds).and(r => r.type === 'changeOrderItem').toArray() : [];
    const allAccomplishments = [...qtyAccomplishments, ...coAccomplishments];

    const accomplishmentValuesByDay = new Map();
    if (allAccomplishments.length > 0) {
        const dupaMap = new Map(allDupas.map(d => [d.quantityId || d.changeOrderItemId, d]));
        const parentQuantityMap = new Map(quantities.map(q => [q.id, q]));
        for (const acc of allAccomplishments) {
            let taskCost = 0;
            if (acc.type === 'changeOrderItem') taskCost = calculateDupaTotalCost(dupaMap.get(acc.taskId));
            else {
                const parentDupa = dupaMap.get(acc.taskId);
                const parentQuantity = parentQuantityMap.get(acc.taskId);
                if (parentQuantity?.subquantities?.length > 0) taskCost = calculateDupaTotalCost(parentDupa) / parentQuantity.subquantities.length;
                else taskCost = calculateDupaTotalCost(parentDupa);
            }
            const earnedValue = taskCost * (acc.percentComplete / 100);
            const reportDate = new Date(acc.date);
            reportDate.setMinutes(reportDate.getMinutes() + reportDate.getTimezoneOffset());
            const projectDay = Math.round((reportDate - projectStartDate) / (1000 * 60 * 60 * 24));
            if (projectDay >= 0) accomplishmentValuesByDay.set(projectDay, (accomplishmentValuesByDay.get(projectDay) || 0) + earnedValue);
        }
    }

    const actualPercentage = new Array(projectDuration).fill(null);
    if (accomplishmentValuesByDay.size > 0 || project.startDate) {
        let cumulativeValue = 0;
        accomplishmentValuesByDay.set(0, accomplishmentValuesByDay.get(0) || 0);
        const sortedDays = [...accomplishmentValuesByDay.keys()].sort((a, b) => a - b);
        sortedDays.forEach(day => {
            cumulativeValue += accomplishmentValuesByDay.get(day);
            if (day < projectDuration) actualPercentage[day] = (cumulativeValue / grandTotalCost) * 100;
        });
        let lastDay = 0, lastValue = 0;
        for (let i = 0; i < projectDuration; i++) {
            if (actualPercentage[i] !== null) {
                const nextValue = actualPercentage[i], nextDay = i;
                if (nextDay > lastDay) {
                    const daysBetween = nextDay - lastDay, valueStep = (nextValue - lastValue) / daysBetween;
                    for (let j = 1; j < daysBetween; j++) actualPercentage[lastDay + j] = lastValue + (valueStep * j);
                }
                lastDay = nextDay;
                lastValue = nextValue;
            }
        }
        const today = new Date(), daysElapsed = Math.floor((today - projectStartDate) / (1000 * 60 * 60 * 24));
        if (daysElapsed > lastDay && lastDay < projectDuration) {
             for (let i = lastDay + 1; i <= daysElapsed && i < projectDuration; i++) actualPercentage[i] = lastValue;
        }
    }
    
    // **NEW**: Create styling arrays for the data points
    const pointRadii = new Array(projectDuration).fill(2); // Small default radius
    const pointColors = new Array(projectDuration).fill('rgba(255, 99, 132, 0.5)');
    for (const day of accomplishmentValuesByDay.keys()) {
        if (day > 0 && day < projectDuration) {
            pointRadii[day] = 5; // Larger radius for actual report days
            pointColors[day] = 'rgb(255, 99, 132)'; // Solid color for actual report days
        }
    }

    if (trackingSCurveChart) trackingSCurveChart.destroy();
    trackingSCurveChart = new Chart(trackingSCurveCanvas, {
        type: 'line',
        data: {
            labels: plannedData.labels,
            datasets: [
                { label: 'Planned Cumulative %', data: plannedData.plannedPercentage, borderColor: 'rgb(75, 192, 192)', tension: 0.4, fill: false },
                {
                    label: 'Actual Cumulative %',
                    data: actualPercentage,
                    borderColor: 'rgb(255, 99, 132)',
                    spanGaps: true, tension: 0.1, fill: false,
                    // **NEW**: Apply the point styling
                    pointRadius: pointRadii,
                    pointBackgroundColor: pointColors,
                    pointHoverRadius: 7
                }
            ]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            scales: { y: { beginAtZero: true, max: 100, ticks: { callback: value => value + '%' } } },
            plugins: { title: { display: true, text: 'Planned vs. Actual S-Curve (As-Built)' } }
        }
    });
};

const generateLookAheadReport = async () => {
    const projectId = currentConstructionProjectId;
    const startDateStr = document.getElementById('lookahead-start-date').value;
    const durationWeeks = parseInt(document.getElementById('lookahead-duration').value);
    const contentDiv = document.getElementById('lookahead-report-content');
    const kpiDiv = document.getElementById('lookahead-kpi-container');

    contentDiv.innerHTML = `<p class="placeholder-text">Generating report...</p>`;
    kpiDiv.innerHTML = '';

    if (!startDateStr) {
        alert('Please select a start date for the report.');
        contentDiv.innerHTML = `<p class="placeholder-text">Please select a start date and click "Generate Report".</p>`;
        return;
    }

    const project = await db.projects.get(projectId);
    if (!project.startDate) {
        alert('This project has no actual start date. Please file at least one accomplishment report before generating a look-ahead.');
        contentDiv.innerHTML = `<p class="placeholder-text">Project has no start date.</p>`;
        return;
    }

    const pertData = await getPertCpmData(projectId, true);
    if (!pertData) {
        alert('Could not generate schedule data for this project.');
        return;
    }
    
    const { tasks: pertTasks, allDupas } = pertData;
    const allTasksWithProgress = await getAllAccomplishmentTasks(projectId);
    const taskProgressMap = new Map(allTasksWithProgress.map(t => [t.uniqueId, t]));

    const dupaMap = new Map();
    if (allDupas) {
        allDupas.forEach(d => {
            const key = d.quantityId || d.changeOrderItemId;
            dupaMap.set(key, d);
        });
    }

    let totalProjectValue = 0;
    let accomplishedProjectValue = 0;
    allTasksWithProgress.forEach(task => {
        totalProjectValue += task.cost || 0;
        accomplishedProjectValue += (task.cost || 0) * ((task.percentComplete || 0) / 100);
    });
    const overallProgress = totalProjectValue > 0 ? (accomplishedProjectValue / totalProjectValue) * 100 : 0;
    kpiDiv.innerHTML = `<strong>Overall Project Completion: ${overallProgress.toFixed(2)}%</strong>`;

    const reportStartDate = new Date(startDateStr);
    const reportEndDate = new Date(reportStartDate);
    reportEndDate.setDate(reportEndDate.getDate() + durationWeeks * 7);

    const projectStartDate = new Date(project.startDate);
    
    const dayInMillis = 1000 * 60 * 60 * 24;
    const reportStartDay = Math.floor((reportStartDate - projectStartDate) / dayInMillis);
    const reportEndDay = reportStartDay + (durationWeeks * 7);

    const parentTasksInWindow = Array.from(pertTasks.values()).filter(task =>
        (typeof task.id === 'number' || (typeof task.id === 'string' && task.id.includes('co-'))) &&
        task.ls < reportEndDay &&
        task.ef > reportStartDay
    );

    // New logic: Expand parent tasks into their sub-tasks
    const finalTasksForReport = [];
    for (const parentTask of parentTasksInWindow) {
        const subTasks = allTasksWithProgress.filter(t => t.type === 'subquantity' && t.quantityId === parentTask.id);
        if (subTasks.length > 0) {
            subTasks.forEach(sub => {
                finalTasksForReport.push({ ...sub, ...parentTask, id: sub.id, name: sub.displayName, originalParent: parentTask });
            });
        } else {
            const originalTask = allTasksWithProgress.find(t => t.id === parentTask.id);
            if(originalTask) {
                 finalTasksForReport.push({ ...originalTask, ...parentTask, name: originalTask.displayName, originalParent: parentTask });
            }
        }
    }

    if (finalTasksForReport.length === 0) {
        contentDiv.innerHTML = `<p class="placeholder-text">No tasks scheduled for this period.</p>`;
        return;
    }
    
    finalTasksForReport.sort((a,b) => a.es - b.es);

    let reportHtml = '';
    for (const task of finalTasksForReport) {
        const taskMaster = taskProgressMap.get(task.uniqueId);
        
        let isAtRisk = false;
        let predecessorHtml = '<ul>';
        if (task.originalParent.predecessors.size === 0) {
            predecessorHtml += '<li>None (Project Start)</li>';
        } else {
            for (const predId of task.originalParent.predecessors) {
                const predMaster = allTasksWithProgress.find(t => t.id === predId);
                if (predMaster) {
                    const predProgress = predMaster.percentComplete || 0;
                    if (predProgress < 100) isAtRisk = true;
                    predecessorHtml += `<li>${predMaster.displayName} (${predProgress.toFixed(0)}% complete)</li>`;
                }
            }
        }
        predecessorHtml += '</ul>';
        
        const dupaId = task.type === 'subquantity' ? task.quantityId : task.id;
        const dupa = dupaMap.get(dupaId);
        let resourceHtml = '<ul>';
        if (dupa && dupa.directCosts) {
             const items = dupa.directCosts.map(dc => {
                switch(dc.type) {
                    case 'labor': return `<li>${dc.laborType} (${dc.mandays} mandays)</li>`;
                    case 'equipment': return `<li>${dc.name} (${dc.hours} hours)</li>`;
                    case 'material': return `<li>${dc.name} (${dc.quantity} ${dc.unit})</li>`;
                    default: return '';
                }
            }).join('');
            resourceHtml += items || '<li>No resources specified in DUPA.</li>';
        } else {
            resourceHtml += '<li>DUPA not found.</li>';
        }
        resourceHtml += '</ul>';

        const earlyStartDate = new Date(projectStartDate);
        earlyStartDate.setDate(projectStartDate.getDate() + task.es);
        const lateFinishDate = new Date(projectStartDate);
        lateFinishDate.setDate(projectStartDate.getDate() + task.lf);

        reportHtml += `
            <div class="lookahead-task ${isAtRisk ? 'at-risk' : ''}">
                <div class="lookahead-task-header">
                    <h3>
                        <span>${task.name}</span>
                        <span class="status ${isAtRisk ? 'at-risk' : 'on-track'}">${isAtRisk ? 'At Risk' : 'On Track'}</span>
                    </h3>
                    <small>Scheduled Window: ${earlyStartDate.toLocaleDateString()} - ${lateFinishDate.toLocaleDateString()}</small>
                </div>
                <div class="lookahead-task-body">
                    <div>
                        <h4>Constraints (Predecessors)</h4>
                        ${predecessorHtml}
                    </div>
                    <div>
                        <h4>Required Resources</h4>
                        ${resourceHtml}
                    </div>
                </div>
            </div>
        `;
    }

    contentDiv.innerHTML = reportHtml;
};


function initializeConstructionModule() {
    accomplishmentView.addEventListener('click', (e) => {
        if (e.target.classList.contains('view-accomplishment-btn')) {
            showAccomplishmentForm(parseInt(e.target.dataset.id), e.target.dataset.name);
        }
    });
    document.getElementById('accomplishment-list-view').addEventListener('click', (e) => {
        if (e.target.classList.contains('view-accomplishment-detail-btn')) {
            showAccomplishmentDetail(currentConstructionProjectId, e.target.dataset.date);
        }
    });
    document.getElementById('edit-accomplishment-btn').addEventListener('click', (e) => {
        editAccomplishmentReport(currentConstructionProjectId, e.target.dataset.date);
    });
    document.getElementById('back-to-accomplishment-entry').addEventListener('click', () => {
        showAccomplishmentForm(currentConstructionProjectId, accomplishmentProjectName.textContent);
    });
    backToAccomplishmentProjectsBtn.addEventListener('click', showAccomplishment);
    
    accomplishmentForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const date = accomplishmentDateInput.value;
    const isEditMode = accomplishmentDateInput.hasAttribute('readonly');

    if (!date) {
        alert('Please select a date.');
        return;
    }

    const updates = [];
    accomplishmentTableBody.querySelectorAll('tr[data-unique-id]').forEach(row => {
        const progressInput = row.querySelector('.progress-input');
        const progressToday = progressInput.value ? parseFloat(progressInput.value) : 0;
        if (isNaN(progressToday) || progressToday <= 0) return;

        const update = {
            type: row.dataset.type,
            progressToday: progressToday,
        };
        if (update.type === 'subquantity') {
            update.taskId = parseInt(row.dataset.quantityId);
            update.subIndex = parseInt(row.dataset.subquantityIndex);
        } else {
            update.taskId = parseInt(row.dataset.quantityId);
        }
        updates.push(update);
    });

    if (updates.length === 0) {
        alert('No progress updates to save.');
        return;
    }

    try {
        await db.transaction('rw', db.accomplishments, db.quantities, db.changeOrderItems, async () => {
            const recordsToAdd = updates.map(update => {
                const record = {
                    date: date,
                    percentComplete: update.progressToday,
                    taskId: update.taskId,
                    subIndex: null,
                    type: update.type === 'subquantity' ? 'quantity' : update.type
                };
                if (update.type === 'subquantity') {
                    record.subIndex = update.subIndex;
                }
                return record;
            });
            await db.accomplishments.bulkAdd(recordsToAdd);

            const tasksToRecalculate = new Map();
            updates.forEach(upd => {
                const key = `${upd.type}-${upd.taskId}`;
                if (!tasksToRecalculate.has(key)) {
                    tasksToRecalculate.set(key, { type: upd.type, id: upd.taskId });
                }
            });

            for (const task of tasksToRecalculate.values()) {
                if (task.type === 'changeOrderItem') {
                    const allReports = await db.accomplishments.where({ type: 'changeOrderItem', taskId: task.id }).toArray();
                    const totalProgress = allReports.reduce((sum, r) => sum + r.percentComplete, 0);
                    await db.changeOrderItems.update(task.id, { percentComplete: Math.min(100, totalProgress) });
                } else { 
                    const parentQuantity = await db.quantities.get(task.id);
                    if (!parentQuantity) continue;

                    if (Array.isArray(parentQuantity.subquantities) && parentQuantity.subquantities.length > 0) {
                        let totalSubProgress = 0;
                        for (let i = 0; i < parentQuantity.subquantities.length; i++) {
                            const subReports = await db.accomplishments.where({ type: 'quantity', taskId: task.id, subIndex: i }).toArray();
                            const subTotal = subReports.reduce((sum, r) => sum + r.percentComplete, 0);
                            totalSubProgress += Math.min(100, subTotal);
                        }
                        const finalParentProgress = totalSubProgress / parentQuantity.subquantities.length;
                        await db.quantities.update(task.id, { percentComplete: finalParentProgress });
                    } else {
                        const allReports = await db.accomplishments.where({ type: 'quantity', taskId: task.id }).toArray();
                        const totalProgress = allReports.reduce((sum, r) => sum + r.percentComplete, 0);
                        await db.quantities.update(task.id, { percentComplete: Math.min(100, totalProgress) });
                    }
                }
            }
        });

        alert(`Accomplishment report saved successfully!`);
        showAccomplishmentForm(currentConstructionProjectId, accomplishmentProjectName.textContent);

    } catch (error) {
        console.error("Failed to save accomplishment report:", error);
        alert('An error occurred. Please check the browser console for details.');
    }
});

    trackingGanttView.addEventListener('click', e => {
        if (e.target.classList.contains('view-tracking-gantt-btn')) {
            showTrackingGanttChart(parseInt(e.target.dataset.id), e.target.dataset.name);
        }
    });
    backToTrackingGanttProjectsBtn.addEventListener('click', showTrackingGantt);
    document.getElementById('tracking-gantt-view-day').addEventListener('click', () => { if (trackingGanttChart) trackingGanttChart.change_view_mode('Day'); });
    document.getElementById('tracking-gantt-view-week').addEventListener('click', () => { if (trackingGanttChart) trackingGanttChart.change_view_mode('Week'); });
    document.getElementById('tracking-gantt-view-month').addEventListener('click', () => { if (trackingGanttChart) trackingGanttChart.change_view_mode('Month'); });
    document.getElementById('tracking-gantt-sort').addEventListener('change', () => {
        if (currentConstructionProjectId) {
            const projectName = trackingGanttProjectName.textContent.replace('Tracking Gantt: ', '');
            showTrackingGanttChart(currentConstructionProjectId, projectName);
        }
    });
    
    trackingSCurveView.addEventListener('click', e => {
        if (e.target.classList.contains('view-tracking-s-curve-btn')) {
            renderTrackingSCurve(parseInt(e.target.dataset.id), e.target.dataset.name);
        }
    });
    backToTrackingSCurveProjectsBtn.addEventListener('click', showTrackingSCurve);

    document.getElementById('lookahead-projects-list').addEventListener('click', (e) => {
        if (e.target.classList.contains('select-lookahead-project-btn')) {
            showLookAheadReportView(parseInt(e.target.dataset.id), e.target.dataset.name);
        }
    });
    document.getElementById('back-to-lookahead-projects').addEventListener('click', showLookahead);
    document.getElementById('generate-lookahead-btn').addEventListener('click', generateLookAheadReport);
        document.getElementById('accomplishment-sort').addEventListener('change', () => {
        showAccomplishmentForm(currentConstructionProjectId, accomplishmentProjectName.textContent);
    });
    document.getElementById('accomplishment-group').addEventListener('change', () => {
        showAccomplishmentForm(currentConstructionProjectId, accomplishmentProjectName.textContent);
    });
}
// --- End of construction.js ---
</file>

<file path="js/views.js">
// Author: Gemini
// OS support: Cross-platform
// Description: Controls view switching and navigation for the SPA.

let dashboardView, projectsView, projectSummaryView, takeoffView, dupaView, sequencingView, reportsView, accomplishmentView, accomplishmentListView, accomplishmentDetailView, trackingGanttView, trackingSCurveView, changeOrdersView, revisedReportsView, lookaheadView, materialsLibraryView, dupaLibraryView, libraryManagementView;
let allViews = [];

let takeoffProjectListView, takeoffQuantitiesView, dupaProjectListView, dupaQuantityListView, dupaFormView, sequencingProjectListView, sequencingTasksView, boqProjectListView, boqDisplayView, pertCpmDisplayView, ganttChartDisplayView, sCurveDisplayView, pertCpmNetworkView, resourceScheduleView;
let revisedBoqProjectListView, revisedBoqDisplayView, revisedPertCpmDisplayView;
let dupaReportModal, dupaReportModalClose, dupaReportTitle, dupaReportContent, coItemTypeModal, coItemTypeModalClose, coExistingItemModal, coExistingItemModalClose, importPreviewModal, importPreviewModalClose, libraryPickerModal, libraryPickerModalClose, libraryPickerTitle, libraryPickerSearch, libraryPickerList, libraryPickerCrewMultiplier, libraryPickerCrewCount;
let navDashboard, navProjects, navTakeoff, navDupa, navSequencing, navReports, navChangeOrders, navAccomplishment, navTrackingGantt, navTrackingSCurve, navRevisedReports, navLookahead, navMaterialsLibrary, navDupaLibrary, navLibraryManagement;
let backToTakeoffListBtn, backToDupaProjectsBtn, backToDupaQuantitiesBtn, backToSequencingProjectsBtn, backToBoqProjectsBtn, backToBoqViewBtn, backToPertCpmViewBtn, backToPertCpmViewFromSCurveBtn, backToPertCpmFromNetworkBtn, backToPertCpmFromResourceBtn, backToRevisedBoqProjectsBtn, backToRevisedBoqViewBtn;

const openDupaReportModal = () => dupaReportModal.style.display = 'block';
const closeDupaReportModal = () => dupaReportModal.style.display = 'none';
const openCoItemTypeModal = () => coItemTypeModal.style.display = 'block';
const closeCoItemTypeModal = () => coItemTypeModal.style.display = 'none';
const openCoExistingItemModal = () => coExistingItemModal.style.display = 'block';
const closeCoExistingItemModal = () => coExistingItemModal.style.display = 'none';
const openImportPreviewModal = () => importPreviewModal.style.display = 'block';
const closeImportPreviewModal = () => importPreviewModal.style.display = 'none';
const openLibraryPickerModal = () => libraryPickerModal.style.display = 'block';
const closeLibraryPickerModal = () => libraryPickerModal.style.display = 'none';

const openLibraryPicker = (config) => {
    libraryPickerTitle.textContent = config.title;
    libraryPickerSearch.value = '';
    libraryPickerCrewMultiplier.classList.toggle('hidden', !config.isCrewPicker);
    libraryPickerCrewCount.value = 1;
    
    const renderList = (items) => {
        libraryPickerList.innerHTML = '';
        if (items.length === 0) {
            libraryPickerList.innerHTML = '<p>No items found.</p>';
            return;
        }
        items.forEach(item => {
            const div = document.createElement('div');
            div.className = 'list-item';
            div.dataset.id = item.id;
            div.style.cursor = 'pointer';
            let itemText = `<h3>${item.name}</h3>`;
            if (item.type) itemText += `<span>(${item.type})</span>`;
            if (item.productivityRate) itemText += `<span> - ${item.productivityRate} ${item.productivityUnit}</span>`;
            div.innerHTML = itemText;
            libraryPickerList.appendChild(div);
        });
    };

    renderList(config.dataSource);

    libraryPickerSearch.oninput = () => {
        const filter = libraryPickerSearch.value.toLowerCase();
        const filteredItems = config.dataSource.filter(item => 
            config.searchKeys.some(key => item[key].toLowerCase().includes(filter))
        );
        renderList(filteredItems);
    };

    libraryPickerList.onclick = (e) => {
        const itemElement = e.target.closest('.list-item');
        if (itemElement) {
            const itemId = parseInt(itemElement.dataset.id);
            const selectedItem = config.dataSource.find(item => item.id === itemId);
            if (selectedItem) {
                const multiplier = config.isCrewPicker ? parseInt(libraryPickerCrewCount.value) : 1;
                config.onSelect(selectedItem, multiplier);
                closeLibraryPickerModal();
            }
        }
    };
    
    openLibraryPickerModal();
};

const setActiveNav = (activeLink) => {
    const allNavLinks = document.querySelectorAll('.dropdown-content a, .dropbtn');
    const allDropBtns = document.querySelectorAll('.dropbtn');
    allNavLinks.forEach(l => l.classList.remove('active'));
    allDropBtns.forEach(b => b.classList.remove('active'));
    if (activeLink) {
        activeLink.classList.add('active');
        const parentDropdown = activeLink.closest('.dropdown');
        if (parentDropdown) {
            parentDropdown.querySelector('.dropbtn').classList.add('active');
        }
    }
};
const showView = (activeView) => allViews.forEach(v => v.classList.toggle('hidden', v !== activeView));

const showDashboard = () => { showView(dashboardView); setActiveNav(navDashboard); updateDashboard(); };
const showProjects = () => { showView(projectsView); setActiveNav(navProjects); displayProjects(); };
const showTakeOff = () => {
    showView(takeoffView);
    setActiveNav(navTakeoff);
    takeoffQuantitiesView.classList.add('hidden');
    takeoffProjectListView.classList.remove('hidden');
    displayTakeOffProjects();
};
const showDupa = () => {
    showView(dupaView);
    setActiveNav(navDupa);
    dupaQuantityListView.classList.add('hidden');
    dupaFormView.classList.add('hidden');
    dupaProjectListView.classList.remove('hidden');
    displayDupaProjects();
};
const showSequencing = () => {
    showView(sequencingView);
    setActiveNav(navSequencing);
    sequencingTasksView.classList.add('hidden');
    sequencingProjectListView.classList.remove('hidden');
    displaySequencingProjects();
};
const showReports = () => {
    showView(reportsView);
    setActiveNav(navReports);
    showReportsProjectList();
};
const showChangeOrders = () => {
    showView(changeOrdersView);
    setActiveNav(navChangeOrders);
    document.getElementById('co-list-view').classList.add('hidden');
    document.getElementById('co-project-list-view').classList.remove('hidden');
    displayCoProjects();
};
const showAccomplishment = () => {
    showView(accomplishmentView);
    setActiveNav(navAccomplishment);
    document.getElementById('accomplishment-entry-view').classList.add('hidden');
    document.getElementById('accomplishment-list-view').classList.add('hidden');
    document.getElementById('accomplishment-detail-view').classList.add('hidden');
    document.getElementById('accomplishment-project-list-view').classList.remove('hidden');
    displayAccomplishmentProjects();
};
const showTrackingGantt = () => {
    showView(trackingGanttView);
    setActiveNav(navTrackingGantt);
    document.getElementById('tracking-gantt-chart-view').classList.add('hidden');
    document.getElementById('tracking-gantt-project-list-view').classList.remove('hidden');
    displayTrackingGanttProjects();
};
const showTrackingSCurve = () => {
    showView(trackingSCurveView);
    setActiveNav(navTrackingSCurve);
    document.getElementById('tracking-s-curve-chart-view').classList.add('hidden');
    document.getElementById('tracking-s-curve-project-list-view').classList.remove('hidden');
    displayTrackingSCurveProjects();
};
const showRevisedReports = () => {
    showView(revisedReportsView);
    setActiveNav(navRevisedReports);
    revisedBoqDisplayView.classList.add('hidden');
    revisedPertCpmDisplayView.classList.add('hidden');
    revisedBoqProjectListView.classList.remove('hidden');
    displayRevisedBoqProjects();
};
const showLookahead = () => {
    showView(lookaheadView);
    setActiveNav(navLookahead);
    document.getElementById('lookahead-report-view').classList.add('hidden');
    document.getElementById('lookahead-project-list-view').classList.remove('hidden');
    displayLookaheadProjects();
};
const showMaterialsLibrary = () => {
    showView(materialsLibraryView);
    setActiveNav(navMaterialsLibrary);
    displayMaterials();
};
const showDupaLibrary = () => {
    showView(dupaLibraryView);
    setActiveNav(navDupaLibrary);
    displayResources();
    displayCrews();
};
const showLibraryManagement = () => {
    showView(libraryManagementView);
    setActiveNav(navLibraryManagement);
};

function initializeViewsModule() {
    dashboardView = document.getElementById('dashboard-view');
    projectsView = document.getElementById('projects-view');
    projectSummaryView = document.getElementById('project-summary-view');
    takeoffView = document.getElementById('takeoff-view');
    dupaView = document.getElementById('dupa-view');
    sequencingView = document.getElementById('sequencing-view');
    reportsView = document.getElementById('reports-view');
    accomplishmentView = document.getElementById('accomplishment-view');
    accomplishmentListView = document.getElementById('accomplishment-list-view');
    accomplishmentDetailView = document.getElementById('accomplishment-detail-view');
    trackingGanttView = document.getElementById('tracking-gantt-view');
    trackingSCurveView = document.getElementById('tracking-s-curve-view');
    changeOrdersView = document.getElementById('change-orders-view');
    revisedReportsView = document.getElementById('revised-reports-view');
    lookaheadView = document.getElementById('lookahead-view');
    materialsLibraryView = document.getElementById('materials-library-view');
    dupaLibraryView = document.getElementById('dupa-library-view');
    libraryManagementView = document.getElementById('library-management-view');
    
    allViews = [dashboardView, projectsView, projectSummaryView, takeoffView, dupaView, sequencingView, reportsView, accomplishmentView, accomplishmentListView, accomplishmentDetailView, trackingGanttView, trackingSCurveView, lookaheadView, changeOrdersView, revisedReportsView, materialsLibraryView, dupaLibraryView, libraryManagementView];

    takeoffProjectListView = document.getElementById('takeoff-project-list-view');
    takeoffQuantitiesView = document.getElementById('takeoff-quantities-view');
    dupaProjectListView = document.getElementById('dupa-project-list-view');
    dupaQuantityListView = document.getElementById('dupa-quantity-list-view');
    dupaFormView = document.getElementById('dupa-form-view');
    sequencingProjectListView = document.getElementById('sequencing-project-list-view');
    sequencingTasksView = document.getElementById('sequencing-tasks-view');
    boqProjectListView = document.getElementById('boq-project-list-view');
    boqDisplayView = document.getElementById('boq-display-view');
    pertCpmDisplayView = document.getElementById('pert-cpm-display-view');
    ganttChartDisplayView = document.getElementById('gantt-chart-display-view');
    sCurveDisplayView = document.getElementById('s-curve-display-view');
    pertCpmNetworkView = document.getElementById('pert-cpm-network-view');
    resourceScheduleView = document.getElementById('resource-schedule-view');

    revisedBoqProjectListView = document.getElementById('revised-boq-project-list-view');
    revisedBoqDisplayView = document.getElementById('revised-boq-display-view');
    revisedPertCpmDisplayView = document.getElementById('revised-pert-cpm-display-view');

    dupaReportModal = document.getElementById('dupa-details-modal');
    dupaReportModalClose = document.querySelector('.dupa-details-modal-close');
    dupaReportTitle = document.getElementById('dupa-details-title');
    dupaReportContent = document.getElementById('dupa-details-content');
    coItemTypeModal = document.getElementById('co-item-type-modal');
    coItemTypeModalClose = document.querySelector('.co-item-type-modal-close');
    coExistingItemModal = document.getElementById('co-existing-item-modal');
    coExistingItemModalClose = document.querySelector('.co-existing-item-modal-close');
    importPreviewModal = document.getElementById('import-preview-modal');
    importPreviewModalClose = document.querySelector('.import-preview-modal-close');
    libraryPickerModal = document.getElementById('library-picker-modal');
    libraryPickerModalClose = document.getElementById('library-picker-modal-close');
    libraryPickerTitle = document.getElementById('library-picker-title');
    libraryPickerSearch = document.getElementById('library-picker-search');
    libraryPickerList = document.getElementById('library-picker-list');
    libraryPickerCrewMultiplier = document.getElementById('library-picker-crew-multiplier');
    libraryPickerCrewCount = document.getElementById('library-picker-crew-count');

    navDashboard = document.getElementById('nav-dashboard');
    navProjects = document.getElementById('nav-projects');
    navTakeoff = document.getElementById('nav-takeoff');
    navDupa = document.getElementById('nav-dupa');
    navSequencing = document.getElementById('nav-sequencing');
    navReports = document.getElementById('nav-reports');
    navChangeOrders = document.getElementById('nav-change-orders');
    navAccomplishment = document.getElementById('nav-accomplishment');
    navTrackingGantt = document.getElementById('nav-tracking-gantt');
    navTrackingSCurve = document.getElementById('nav-tracking-s-curve');
    navRevisedReports = document.getElementById('nav-revised-reports');
    navLookahead = document.getElementById('nav-lookahead');
    navMaterialsLibrary = document.getElementById('nav-materials-library');
    navDupaLibrary = document.getElementById('nav-dupa-library');
    navLibraryManagement = document.getElementById('nav-library-management');

    backToTakeoffListBtn = document.getElementById('back-to-takeoff-list');
    backToDupaProjectsBtn = document.getElementById('back-to-dupa-projects');
    backToDupaQuantitiesBtn = document.getElementById('back-to-dupa-quantities');
    backToSequencingProjectsBtn = document.getElementById('back-to-sequencing-projects');
    backToBoqProjectsBtn = document.getElementById('back-to-boq-projects');
    backToBoqViewBtn = document.getElementById('back-to-boq-view');
    backToPertCpmViewBtn = document.getElementById('back-to-pert-cpm-view');
    backToPertCpmViewFromSCurveBtn = document.getElementById('back-to-pert-cpm-view-from-s-curve');
    backToPertCpmFromNetworkBtn = document.getElementById('back-to-pert-cpm-from-network-btn');
    backToPertCpmFromResourceBtn = document.getElementById('back-to-pert-cpm-from-resource-btn');
    backToRevisedBoqProjectsBtn = document.getElementById('back-to-revised-boq-projects');
    backToRevisedBoqViewBtn = document.getElementById('back-to-revised-boq-view');
    
    navDashboard.addEventListener('click', (e) => { e.preventDefault(); showDashboard(); });
    navProjects.addEventListener('click', (e) => { e.preventDefault(); showProjects(); });
    navTakeoff.addEventListener('click', (e) => { e.preventDefault(); showTakeOff(); });
    navDupa.addEventListener('click', (e) => { e.preventDefault(); showDupa(); });
    navSequencing.addEventListener('click', (e) => { e.preventDefault(); showSequencing(); });
    navReports.addEventListener('click', (e) => { e.preventDefault(); showReports(); });
    navChangeOrders.addEventListener('click', (e) => { e.preventDefault(); showChangeOrders(); });
    navAccomplishment.addEventListener('click', (e) => { e.preventDefault(); showAccomplishment(); });
    navTrackingGantt.addEventListener('click', (e) => { e.preventDefault(); showTrackingGantt(); });
    navTrackingSCurve.addEventListener('click', (e) => { e.preventDefault(); showTrackingSCurve(); });
    navRevisedReports.addEventListener('click', (e) => { e.preventDefault(); showRevisedReports(); });
    navLookahead.addEventListener('click', (e) => { e.preventDefault(); showLookahead(); });
    navMaterialsLibrary.addEventListener('click', (e) => { e.preventDefault(); showMaterialsLibrary(); });
    navDupaLibrary.addEventListener('click', (e) => { e.preventDefault(); showDupaLibrary(); });
    navLibraryManagement.addEventListener('click', (e) => { e.preventDefault(); showLibraryManagement(); });

    document.getElementById('back-to-projects-from-summary').addEventListener('click', showProjects);
    document.getElementById('view-past-reports-btn').addEventListener('click', () => showAccomplishmentList(currentConstructionProjectId));
    document.getElementById('back-to-accomplishment-list').addEventListener('click', () => showAccomplishmentList(currentConstructionProjectId));

    backToTakeoffListBtn.addEventListener('click', showTakeOff);
    backToDupaProjectsBtn.addEventListener('click', showDupa);
    backToDupaQuantitiesBtn.addEventListener('click', () => showDupaQuantitiesForProject(currentDupaProjectId, dupaProjectName.textContent));
    backToSequencingProjectsBtn.addEventListener('click', showSequencing);
    backToBoqProjectsBtn.addEventListener('click', showReports);
    
    backToBoqViewBtn.addEventListener('click', () => {
        pertCpmDisplayView.classList.add('hidden');
        ganttChartDisplayView.classList.add('hidden');
        sCurveDisplayView.classList.add('hidden');
        pertCpmNetworkView.classList.add('hidden');
        resourceScheduleView.classList.add('hidden');
        boqDisplayView.classList.remove('hidden');
    });

    const goBackToPertCpm = () => {
        ganttChartDisplayView.classList.add('hidden');
        sCurveDisplayView.classList.add('hidden');
        pertCpmNetworkView.classList.add('hidden');
        resourceScheduleView.classList.add('hidden');
        pertCpmDisplayView.classList.remove('hidden');
    };

    backToPertCpmViewBtn.addEventListener('click', goBackToPertCpm);
    backToPertCpmViewFromSCurveBtn.addEventListener('click', goBackToPertCpm);
    backToPertCpmFromNetworkBtn.addEventListener('click', goBackToPertCpm);
    backToPertCpmFromResourceBtn.addEventListener('click', goBackToPertCpm);

    backToRevisedBoqProjectsBtn.addEventListener('click', showRevisedReports);
    backToRevisedBoqViewBtn.addEventListener('click', () => {
        revisedPertCpmDisplayView.classList.add('hidden');
        revisedBoqDisplayView.classList.remove('hidden');
    });
}
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construction Management</title>
    <link rel="stylesheet" href="css/style.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.css">
    <script src="https://cdn.jsdelivr.net/npm/frappe-gantt@0.6.1/dist/frappe-gantt.min.js"></script>
</head>

<body>
    <div class="page-container">
        <nav class="navbar">
            <a href="#" class="nav-brand">ConstructApp</a>
                <ul>
                    <li class="dropdown">
                        <a href="#" class="dropbtn" id="nav-preconstruction">Pre-construction</a>
                        <div class="dropdown-content">
                            <a href="#" id="nav-dashboard">Dashboard</a>
                            <a href="#" id="nav-projects">Projects</a>
                            <a href="#" id="nav-takeoff">Take Off</a>
                            <a href="#" id="nav-dupa">DUPA</a>
                            <a href="#" id="nav-sequencing">Task Sequencing</a>
                            <a href="#" id="nav-reports">Pre-construction Reports</a>
                            <a href="#" id="nav-change-orders">Change Orders</a>
                        </div>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropbtn" id="nav-construction">Construction</a>
                        <div class="dropdown-content">
                            <a href="#" id="nav-accomplishment">Accomplishment Report</a>
                            <a href="#" id="nav-tracking-gantt">Tracking Gantt Chart</a>
                            <a href="#" id="nav-tracking-s-curve">Tracking S-Curve</a>
                            <a href="#" id="nav-revised-reports">Revised Reports</a>
                            <a href="#" id="nav-lookahead">Look-Ahead Report</a>
                        </div>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropbtn" id="nav-libraries">Libraries</a>
                        <div class="dropdown-content">
                            <a href="#" id="nav-materials-library">Materials Library</a>
                            <a href="#" id="nav-dupa-library">DUPA Labor & Equipment</a>
                            <a href="#" id="nav-library-management">Import/Export Library</a>
                        </div>
                    </li>
                </ul>
        </nav>

        <main class="content">
            <div id="dashboard-view">
    <header class="page-header">
        <h1>Dashboard</h1>
    </header>
    <div class="dashboard-grid-new">
        <div class="summary-card">
            <h2 class="card-title">On-Going Projects</h2>
            <p id="ongoing-project-count">0</p>
        </div>
        <div class="summary-card">
            <h2 class="card-title">Completed Projects</h2>
            <p id="completed-project-count">0</p>
        </div>
        <div class="summary-card">
            <h2 class="card-title">Pending Change Orders</h2>
            <p id="pending-co-count">0</p>
        </div>
        <div class="summary-card">
            <h2 class="card-title">Value of Active Projects</h2>
            <p id="active-contract-value">₱0</p>
        </div>
        <div class="dashboard-chart-container">
            <h2 class="card-title">Projects by Status</h2>
            <canvas id="project-status-chart"></canvas>
        </div>
        <div class="dashboard-list-container">
            <h2 class="card-title">Projects Requiring Attention</h2>
            <ul id="attention-projects-list"></ul>
        </div>
    </div>
    <div class="dashboard-gantt-container">
    <div class="page-header" style="margin-bottom: 1rem;">
        <h2 class="card-title" style="margin-bottom: 0;">Ongoing Project Timelines</h2>
        <div class="gantt-controls">
            <div class="form-group" style="margin-bottom: 0;">
            <select id="dashboard-gantt-sort" class="btn btn-secondary">
                <option value="start_date">Sort by Start Date</option>
                <option value="name">Sort by Name</option>
                <option value="progress">Sort by Progress</option>
            </select>
            </div>
            <span>View Mode:</span>
            <button id="dashboard-gantt-view-day" class="btn btn-secondary">Day</button>
            <button id="dashboard-gantt-view-week" class="btn btn-secondary">Week</button>
            <button id="dashboard-gantt-view-month" class="btn btn-secondary">Month</button>
        </div>
    </div>
    <div class="gantt-chart-container" id="dashboard-gantt-chart-target"></div>
</div>
</div>

            <div id="projects-view" class="hidden">
                <header class="page-header">
                    <h1>Projects</h1>
                    <div>
                        <input type="file" id="import-project-input" class="hidden" accept=".json">
                        <button id="import-project-btn" class="btn btn-secondary">Import Project</button>
                        <button id="copy-project-btn" class="btn btn-secondary">Copy Project</button>
                        <button id="add-project-btn" class="btn btn-primary">Add New Project</button>
                    </div>
                </header>
                <div class="table-container">
                    <table id="projects-table">
                        <thead>
                            <tr>
                                <th>Project Name</th>
                                <th>Status</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
            <div id="project-summary-view" class="hidden">
    <header class="page-header">
        <div>
            <button id="back-to-projects-from-summary" class="btn btn-secondary">&larr; Back to Projects List</button>
            <h1 id="summary-project-name"></h1>
        </div>
    </header>
    <div class="summary-container">
        <div class="summary-grid">
            <div class="summary-item"><strong>Client</strong> <span id="summary-client-name"></span></div>
            <div class="summary-item"><strong>Address</strong> <span id="summary-address"></span></div>
            <div class="summary-item"><strong>Status</strong> <span id="summary-status"></span></div>
            <div class="summary-item"><strong>Project Manager</strong> <span id="summary-project-manager"></span></div>
            <div class="summary-item"><strong>Client Contact</strong> <span id="summary-client-contact"></span></div>
            <div class="summary-item"><strong>Contract Amount</strong> <span id="summary-contract-amount"></span></div>
            <div class="summary-item"><strong>Contract Date</strong> <span id="summary-contract-date"></span></div>
            <div class="summary-item"><strong>Target Start Date</strong> <span id="summary-target-start"></span></div>
            <div class="summary-item"><strong>Contract Duration</strong> <span id="summary-duration"></span></div>
            <div class="summary-item"><strong>Lot Area</strong> <span id="summary-lot-area"></span></div>
            <div class="summary-item"><strong>Floor Area</strong> <span id="summary-floor-area"></span></div>
            <div class="summary-item"><strong>Floors</strong> <span id="summary-floors"></span></div>
        </div>
        <div class="summary-description">
            <strong>Description</strong>
            <p id="summary-description"></p>
        </div>
    </div>
</div>
            <div id="takeoff-view" class="hidden">
                <div id="takeoff-project-list-view">
                    <header class="page-header">
                        <h1>Take Off - Select a Project</h1>
                    </header>
                    <div id="takeoff-projects-list" class="list-container"></div>
                </div>
                <div id="takeoff-quantities-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-takeoff-list" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="quantities-project-name"></h1>
                        </div>
                        <button id="add-quantity-btn" class="btn btn-primary">Add Quantity</button>
                    </header>
                    <div class="table-container">
                        <table id="quantities-table">
                            <thead>
                                <tr>
                                    <th>Scope of Work</th>
                                    <th>Quantity</th>
                                    <th>Unit</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="dupa-view" class="hidden">
                <div id="dupa-project-list-view">
                    <header class="page-header">
                        <h1>DUPA - Select a Project</h1>
                    </header>
                    <div id="dupa-projects-list" class="list-container"></div>
                </div>
                <div id="dupa-quantity-list-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-dupa-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="dupa-project-name"></h1>
                        </div>
                    </header>
                    <div id="dupa-quantities-list" class="list-container"></div>
                </div>
            <div id="dupa-form-view" class="hidden">
                <header class="page-header">
                    <div>
                        <button id="back-to-dupa-quantities" class="btn btn-secondary">&larr; Back to Quantities</button>
                        <h2 id="dupa-quantity-name"></h2>
                    </div>
                </header>
                <form id="dupa-form">
                    <input type="hidden" id="dupaQuantityId">
                    <input type="hidden" id="dupaId">
                    <div class="form-group">
                        <label for="dupaDuration">Duration (Days)</label>
                        <input type="number" id="dupaDuration" step="1" min="0" required>
                    </div>
                    <div class="dupa-section">
                        <h3 style="display: flex; justify-content: space-between;">
                            <span>Direct Costs</span>
                            <span id="total-direct-cost-summary" class="cost-summary"></span>
                        </h3>

                        <h4 style="display: flex; justify-content: space-between; align-items: center;">
                            <span>Labor</span>
                            <span id="labor-subtotal" class="cost-summary"></span>
                        </h4>
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 1rem;">
                            <button type="button" id="add-labor-btn" class="btn-add" title="Add Blank Row">+</button>
                            <button type="button" id="add-labor-from-library-btn" class="btn btn-secondary btn-sm">Add Labor from Library</button>
                            <button type="button" id="add-crew-from-library-btn" class="btn btn-secondary btn-sm">Add Crew from Library</button>
                        </div>
                        <table class="dupa-table"><thead><tr><th>Labor Type</th><th>Mandays</th><th>Rate (PHP)</th><th>Total</th><th></th></tr></thead><tbody id="labor-tbody"></tbody></table>

                        <h4 style="display: flex; justify-content: space-between; align-items: center;">
                            <span>Materials</span>
                            <span id="material-subtotal" class="cost-summary"></span>
                        </h4>
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 1rem;">
                            <button type="button" id="add-material-btn" class="btn-add" title="Add Blank Row">+</button>
                            <button type="button" id="add-material-from-library-btn" class="btn btn-secondary btn-sm">Add Material from Library</button>
                        </div>
                        <table class="dupa-table"><thead><tr><th>Material Name</th><th>Qty</th><th>Unit</th><th>Unit Price (PHP)</th><th>Total</th><th></th></tr></thead><tbody id="material-tbody"></tbody></table>

                        <h4 style="display: flex; justify-content: space-between; align-items: center;">
                            <span>Equipment</span>
                            <span id="equipment-subtotal" class="cost-summary"></span>
                        </h4>
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 1rem;">
                            <button type="button" id="add-equipment-btn" class="btn-add" title="Add Blank Row">+</button>
                            <button type="button" id="add-equipment-from-library-btn" class="btn btn-secondary btn-sm">Add Equipment from Library</button>
                        </div>
                        <table class="dupa-table"><thead><tr><th>Equipment Name</th><th>Hours</th><th>Rate (PHP)</th><th>Total</th><th></th></tr></thead><tbody id="equipment-tbody"></tbody></table>
                    </div>
                    <div class="dupa-section">
                        <h3 style="display: flex; justify-content: space-between;">
                            <span>Indirect Costs</span>
                            <span id="total-indirect-cost-summary" class="cost-summary"></span>
                        </h3>
                        <div class="indirect-grid" style="grid-template-columns: auto 150px 1fr; gap: 1rem 2rem;">
                            <label for="ocmPercent">OCM (%)</label>
                            <input type="number" id="ocmPercent" step="0.01" min="0" placeholder="e.g., 15">
                            <span id="ocm-amount" class="cost-summary"></span>
                            
                            <label for="profitPercent">Contractor's Profit (%)</label>
                            <input type="number" id="profitPercent" step="0.01" min="0" placeholder="e.g., 10">
                            <span id="profit-amount" class="cost-summary"></span>

                            <label for="taxesPercent">Taxes (%)</label>
                            <input type="number" id="taxesPercent" step="0.01" min="0" placeholder="e.g., 5">
                            <span id="tax-amount" class="cost-summary"></span>
                        </div>
                    </div>

                    <div class="dupa-section">
                        <h3>Summary</h3>
                        <div class="indirect-grid" style="grid-template-columns: auto 1fr;">
                            <strong>Grand Total</strong> <span id="summary-grand-total" class="cost-summary"></span>
                            <strong>Quantity</strong> <span id="summary-quantity" class="cost-summary" style="text-align: right;"></span>
                            <strong>Final Unit Price</strong> <span id="summary-unit-price" class="cost-summary"></span>
                        </div>
                    </div>

                    <button type="submit" class="btn btn-primary">Save DUPA</button>
                </form>
            </div>
            </div>

            <div id="sequencing-view" class="hidden">
                <div id="sequencing-project-list-view">
                    <header class="page-header">
                        <h1>Task Sequencing - Select a Project</h1>
                    </header>
                    <div id="sequencing-projects-list" class="list-container"></div>
                </div>
                <div id="sequencing-tasks-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-sequencing-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="sequencing-project-name"></h1>
                        </div>
                        <div class="report-controls" style="padding: 0; background: none;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <select id="sequence-group" class="btn btn-secondary">
                                    <option value="none">Group by: None</option>
                                    <option value="category">Group by: Category</option>
                                </select>
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <select id="sequence-sort" class="btn btn-secondary">
                                    <option value="schedule">Sort by: Schedule</option>
                                    <option value="name">Sort by: Name (A-Z)</option>
                                </select>
                            </div>
                        </div>
                    </header>
                    <div class="sequencing-layout">
                        <div class="sequencing-main-panel">
                            <div class="sequencing-section">
                                <h3>Project Sequence Overview</h3>
                                <div class="table-container">
                                    <table id="sequences-overview-table">
                                        <thead>
                                            <tr>
                                                <th>Predecessors</th>
                                                <th>Task</th>
                                                <th>Successors</th>
                                                <th>Actions</th>
                                            </tr>
                                        </thead>
                                        <tbody id="sequences-overview-tbody"></tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <aside class="sequencing-side-panel">
                            <div class="sequencing-section">
                                <h4>Unsequenced Tasks</h4>
                                <ul id="unsequenced-tasks-list"></ul>
                            </div>
                        </aside>
                    </div>
                </div>
            </div>

            <div id="reports-view" class="hidden">
                <div id="boq-project-list-view">
                    <header class="page-header">
                        <h1>Reports - Select a Project for BOQ</h1>
                    </header>
                    <div id="boq-projects-list" class="list-container"></div>
                </div>
                <div id="boq-display-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-boq-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="boq-project-name"></h1>
                            <p id="boq-status-message" class="status-message"></p>
                        </div>
                        <div>
                            <button id="view-pert-cpm-btn" class="btn btn-primary hidden">View PERT-CPM</button>
                            <button id="delete-boq-btn" class="btn btn-danger hidden">Delete BOQ & Unlock Data</button>
                        </div>
                    </header>
                    <div class="table-container">
                        <table id="boq-table">
                            <thead>
                                <tr>
                                    <th>Scope of Work</th>
                                    <th>Quantity</th>
                                    <th>Unit</th>
                                    <th>Unit Price</th>
                                    <th>Total Amount</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="boq-tbody"></tbody>
                            <tfoot id="boq-tfoot"></tfoot>
                        </table>
                    </div>
                </div>
                <div id="pert-cpm-display-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-boq-view" class="btn btn-secondary">&larr; Back to BOQ</button>
                            <h1 id="pert-cpm-project-name"></h1>
                        </div>
                        <div>
                            <button id="view-gantt-chart-btn" class="btn btn-primary">View Gantt Chart</button>
                            <button id="view-s-curve-btn" class="btn btn-primary">View S-Curve</button>
                            <button id="view-network-diagram-btn" class="btn btn-primary">View Network Diagram</button>
                            <button id="view-resource-schedule-btn" class="btn btn-primary">Resource Schedule</button>
                        </div>
                    </header>
                    <div class="table-container">
                        <table id="pert-cpm-table">
                            <thead>
                                <tr>
                                    <th>Task (Scope of Work)</th>
                                    <th>Duration</th>
                                    <th>Early Start (ES)</th>
                                    <th>Early Finish (EF)</th>
                                    <th>Late Start (LS)</th>
                                    <th>Late Finish (LF)</th>
                                    <th>Slack</th>
                                </tr>
                            </thead>
                            <tbody id="pert-cpm-tbody"></tbody>
                        </table>
                    </div>
                </div>
                <div id="gantt-chart-display-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-pert-cpm-view" class="btn btn-secondary">&larr; Back to PERT-CPM</button>
                            <h1 id="gantt-chart-project-name"></h1>
                        </div>
                        <div class="gantt-controls">
                            <div class="form-group" style="margin-bottom: 0;">
                                <select id="reports-gantt-sort" class="btn btn-secondary">
                                    <option value="start_date">Sort by Start Date</option>
                                    <option value="name">Sort by Name</option>
                                    <option value="duration">Sort by Duration</option>
                                </select>
                            </div>
                            <span>View Mode:</span>
                            <button id="gantt-view-day" class="btn btn-secondary">Day</button>
                            <button id="gantt-view-week" class="btn btn-secondary">Week</button>
                            <button id="gantt-view-month" class="btn btn-secondary">Month</button>
                        </div>
                    </header>
                    <div class="gantt-chart-container" id="gantt-chart-target"></div>
                </div>
                <div id="s-curve-display-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-pert-cpm-view-from-s-curve" class="btn btn-secondary">&larr; Back to PERT-CPM</button>
                            <h1 id="s-curve-project-name"></h1>
                        </div>
                    </header>
                    <div class="chart-container">
                        <canvas id="s-curve-chart"></canvas>
                    </div>
                </div>
                <div id="pert-cpm-network-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-pert-cpm-from-network-btn" class="btn btn-secondary">&larr; Back to PERT-CPM</button>
                            <h1 id="network-diagram-project-name"></h1>
                        </div>
                    </header>
                    <div class="mermaid-container">
                        <div class="mermaid"></div>
                    </div>
                </div> 
                <div id="resource-schedule-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-pert-cpm-from-resource-btn" class="btn btn-secondary">&larr; Back to PERT-CPM</button>
                            <h1 id="resource-schedule-project-name"></h1>
                        </div>
                    </header>
                    <div class="table-container" id="resource-schedule-container"></div>
                </div>
            </div>

            <div id="change-orders-view" class="hidden">
                <div id="co-project-list-view">
                    <header class="page-header">
                        <h1>Change Orders - Select a Project</h1>
                    </header>
                    <div id="co-projects-list" class="list-container"></div>
                </div>
                <div id="co-list-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-co-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="co-project-name"></h1>
                        </div>
                        <button id="add-co-btn" class="btn btn-primary">Add Change Order</button>
                    </header>
                    <div class="table-container">
                        <table id="co-table">
                            <thead><tr><th>Order #</th><th>Description</th><th>Date</th><th>Status</th><th>Amount</th><th>Actions</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
            <div id="revised-reports-view" class="hidden">
                <div id="revised-boq-project-list-view">
                    <header class="page-header">
                        <h1>Revised Reports - Select a Project</h1>
                    </header>
                    <div id="revised-boq-projects-list" class="list-container"></div>
                </div>
                <div id="revised-boq-display-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-revised-boq-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="revised-boq-project-name"></h1>
                        </div>
                        <div>
                            <button id="view-revised-pert-cpm-btn" class="btn btn-primary">View Revised PERT-CPM</button>
                        </div>
                    </header>
                    <div class="table-container" id="revised-boq-table-container"></div>
                </div>
                <div id="revised-pert-cpm-display-view" class="hidden">
                     <header class="page-header">
                        <div>
                            <button id="back-to-revised-boq-view" class="btn btn-secondary">&larr; Back to Revised BOQ</button>
                            <h1 id="revised-pert-cpm-project-name"></h1>
                        </div>
                    </header>
                    <div class="table-container" id="revised-pert-cpm-table-container"></div>
                </div>
            </div>
            <div id="lookahead-view" class="hidden">
                <div id="lookahead-project-list-view">
                    <header class="page-header">
                        <h1>Look-Ahead Report - Select a Project</h1>
                    </header>
                    <div id="lookahead-projects-list" class="list-container"></div>
                </div>

                <div id="lookahead-report-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-lookahead-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="lookahead-project-name"></h1>
                        </div>
                    </header>

                    <div class="report-controls">
                        <div class="form-group">
                            <label for="lookahead-start-date">Report Start Date</label>
                            <input type="date" id="lookahead-start-date">
                        </div>
                        <div class="form-group">
                            <label for="lookahead-duration">Look-Ahead Period</label>
                            <select id="lookahead-duration">
                                <option value="2">2 Weeks</option>
                                <option value="3" selected>3 Weeks</option>
                                <option value="4">4 Weeks</option>
                            </select>
                        </div>
                        <button id="generate-lookahead-btn" class="btn btn-primary">Generate Report</button>
                    </div>

                    <div id="lookahead-kpi-container"></div>
                    <div id="lookahead-report-content">
                        <p class="placeholder-text">Please select a start date and click "Generate Report" to see the look-ahead schedule.</p>
                    </div>
                </div>
            </div>
            <div id="materials-library-view" class="hidden">
    <header class="page-header">
        <h1>Materials Library</h1>
        <button id="add-new-material-btn" class="btn btn-primary">Add New Material</button>
    </header>
    <div class="library-controls">
        <input type="search" id="material-search-input" placeholder="Search materials...">
    </div>
    <div class="table-container">
        <table id="materials-table">
            <thead>
                <tr>
                    <th>Material Name</th>
                    <th>Unit</th>
                    <th>Unit Price (PHP)</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<div id="dupa-library-view" class="hidden">
    <header class="page-header">
        <h1>DUPA Labor & Equipment Library</h1>
    </header>
    
    <div class="library-section">
        <div class="page-header">
            <h2>Resources (Individual Labor & Equipment)</h2>
            <button id="add-new-resource-btn" class="btn btn-primary">Add New Resource</button>
        </div>
        <div class="library-controls">
            <input type="search" id="resource-search-input" placeholder="Search resources...">
        </div>
        <div class="table-container">
            <table id="resources-table">
                <thead>
                    <tr>
                        <th>Resource Name</th>
                        <th>Type</th>
                        <th>Rate (PHP)</th>
                        <th>Unit</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>

    <div class="library-section">
        <div class="page-header">
            <h2>Crews (Pre-defined Teams)</h2>
            <button id="add-new-crew-btn" class="btn btn-primary">Add New Crew</button>
        </div>
        <div class="library-controls">
            <input type="search" id="crew-search-input" placeholder="Search crews...">
        </div>
        <div class="table-container">
            <table id="crews-table">
                <thead>
                    <tr>
                        <th>Crew Name</th>
                        <th>Productivity</th>
                        <th style="width: 280px;">Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
</div>
<div id="library-management-view" class="hidden">
    <header class="page-header">
        <h1>Import/Export Library</h1>
    </header>

    <div class="library-section">
        <h2>Export Library</h2>
        <p>This will save your entire Materials, Resources, and Crews library to a single JSON file.</p>
        <button id="export-library-btn" class="btn btn-primary">Export Full Library</button>
    </div>

    <div class="library-section">
        <h2>Import Library</h2>
        <p><strong>Warning:</strong> Importing a library file will completely erase and replace your existing library data. This action cannot be undone.</p>
        <input type="file" id="import-library-input" class="hidden" accept=".json">
        <button id="import-library-btn" class="btn btn-secondary">Import from File</button>
    </div>
</div>

<div id="material-modal" class="modal">
    <div class="modal-content">
        <span class="close-button material-modal-close">&times;</span>
        <h2 id="material-modal-title">Add New Material</h2>
        <form id="material-form">
            <input type="hidden" id="material-id">
            <div class="form-group"><label for="material-name">Material Name</label><input type="text" id="material-name" required></div>
            <div class="form-group"><label for="material-unit">Unit (e.g., kg, pcs, cu.m)</label><input type="text" id="material-unit" required></div>
            <div class="form-group"><label for="material-price">Unit Price (PHP)</label><input type="number" step="any" id="material-price" required></div>
            <button type="submit" class="btn btn-primary">Save Material</button>
        </form>
    </div>
</div>

<div id="resource-modal" class="modal">
    <div class="modal-content">
        <span class="close-button resource-modal-close">&times;</span>
        <h2 id="resource-modal-title">Add New Resource</h2>
        <form id="resource-form">
            <input type="hidden" id="resource-id">
            <div class="form-group"><label for="resource-name">Resource Name (e.g., Mason, Excavator)</label><input type="text" id="resource-name" required></div>
            <div class="form-group">
                <label for="resource-type">Type</label>
                <select id="resource-type" required>
                    <option value="labor">Labor</option>
                    <option value="equipment">Equipment</option>
                </select>
            </div>
            <div class="form-group"><label for="resource-rate">Rate (PHP)</label><input type="number" step="any" id="resource-rate" required></div>
            <div class="form-group"><label for="resource-unit">Unit (e.g., manday, hour)</label><input type="text" id="resource-unit" required></div>
            <button type="submit" class="btn btn-primary">Save Resource</button>
        </form>
    </div>
</div>

<div id="crew-modal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <span class="close-button crew-modal-close">&times;</span>
        <h2 id="crew-modal-title">Add New Crew</h2>
        <form id="crew-form">
            <input type="hidden" id="crew-id">
            <div class="form-group"><label for="crew-name">Crew Name (e.g., Concrete Pouring Team)</label><input type="text" id="crew-name" required></div>
            <div class="form-group"><label for="crew-productivity-rate">Productivity Rate (e.g., 10)</label><input type="number" step="any" id="crew-productivity-rate" required></div>
            <div class="form-group"><label for="crew-productivity-unit">Productivity Unit (e.g., cu.m/day)</label><input type="text" id="crew-productivity-unit" required></div>
            
            <hr style="margin: 2rem 0;">

            <div class="composition-editor">
            <div class="resource-list-panel">
                <h4>Available Resources</h4>
                <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; align-items: center;">
                    <input type="search" class="composition-search" id="available-resource-search" placeholder="Search all..." style="flex-grow: 1; margin-bottom: 0;">
                    <button type="button" id="crew-modal-add-labor-btn" class="btn btn-secondary btn-sm" title="Show only Labor resources">Add Labor</button>
                </div>
                <ul id="available-resources-list"></ul>
            </div>
                <div class="resource-list-panel">
                    <h4>Resources in this Crew</h4>
                    <div class="table-container" style="max-height: 400px; overflow-y: auto;">
                        <table id="crew-composition-table">
                            <thead>
                                <tr>
                                    <th>Resource</th>
                                    <th>Quantity</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <button type="submit" class="btn btn-primary" style="margin-top: 1.5rem;">Save Crew</button>
        </form>
    </div>
</div>
            <div id="accomplishment-view" class="hidden">
                <div id="accomplishment-project-list-view">
                    <header class="page-header">
                        <h1>Accomplishment Reports - Select a Project</h1>
                    </header>
                    <div id="accomplishment-projects-list" class="list-container"></div>
                </div>
                <div id="accomplishment-entry-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-accomplishment-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="accomplishment-project-name"></h1>
                        </div>
                        <div class="report-controls" style="padding: 0; background: none;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label for="accomplishment-group" style="display: none;">Group By</label>
                                <select id="accomplishment-group" class="btn btn-secondary">
                                    <option value="none">Group by: None</option>
                                    <option value="category">Group by: Category</option>
                                </select>
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label for="accomplishment-sort" style="display: none;">Sort By</label>
                                <select id="accomplishment-sort" class="btn btn-secondary">
                                    <option value="schedule">Sort by: Schedule</option>
                                    <option value="name">Sort by: Name (A-Z)</option>
                                    <option value="progress">Sort by: Progress (Lowest)</option>
                                </select>
                            </div>
                            <button id="view-past-reports-btn" class="btn btn-primary">View Past Reports</button>
                        </div>
                    </header>
                    <form id="accomplishment-form" class="form-group">
                        <label for="accomplishment-date">Accomplishment Date:</label>
                        <input type="date" id="accomplishment-date" required>
                        <div class="table-container" style="margin-top: 1.5rem;">
                            <table id="accomplishment-table">
                                <thead>
                                    <tr>
                                        <th>Scope of Work</th>
                                        <th>Overall Progress (%)</th>
                                        <th>Progress Today (%)</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                        <button type="submit" class="btn btn-primary" style="margin-top: 1.5rem;">Save Report</button>
                    </form>
                </div>
            </div>
            <div id="accomplishment-list-view" class="hidden">
                <header class="page-header">
                    <div>
                        <button id="back-to-accomplishment-entry" class="btn btn-secondary">&larr; Back to Report Entry</button>
                        <h1 id="accomplishment-list-project-name"></h1>
                    </div>
                </header>
                <div class="table-container">
                    <table id="accomplishment-history-table">
                        <thead>
                            <tr>
                                <th>Report Date</th>
                                <th>Progress Reported This Day</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

<div id="accomplishment-detail-view" class="hidden">
    <header class="page-header">
        <div>
            <button id="back-to-accomplishment-list" class="btn btn-secondary">&larr; Back to Report List</button>
            <h1 id="accomplishment-detail-title"></h1>
        </div>
        <button id="edit-accomplishment-btn" class="btn btn-warning">Edit This Report</button>
    </header>
    <div class="table-container">
        <table id="accomplishment-detail-table">
            <thead>
                <tr>
                    <th>Scope of Work</th>
                    <th>Progress Recorded on this Date (%)</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

            <div id="tracking-gantt-view" class="hidden">
                 <div id="tracking-gantt-project-list-view">
                    <header class="page-header">
                        <h1>Tracking Gantt Chart - Select a Project</h1>
                    </header>
                    <div id="tracking-gantt-projects-list" class="list-container"></div>
                </div>
                <div id="tracking-gantt-chart-view" class="hidden">
                     <header class="page-header">
                        <div>
                            <button id="back-to-tracking-gantt-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="tracking-gantt-project-name"></h1>
                        </div>
                        <div class="gantt-controls">
                            <div class="form-group" style="margin-bottom: 0;">
                                <select id="tracking-gantt-sort" class="btn btn-secondary">
                                    <option value="start_date">Sort by Start Date</option>
                                    <option value="name">Sort by Name</option>
                                    <option value="progress">Sort by Progress</option>
                                </select>
                            </div>
                            <span>View Mode:</span>
                            <button id="tracking-gantt-view-day" class="btn btn-secondary">Day</button>
                            <button id="tracking-gantt-view-week" class="btn btn-secondary">Week</button>
                            <button id="tracking-gantt-view-month" class="btn btn-secondary">Month</button>
                        </div>
                    </header>
                    <div class="gantt-chart-container" id="tracking-gantt-chart-target"></div>
                </div>
            </div>

            <div id="tracking-s-curve-view" class="hidden">
                <div id="tracking-s-curve-project-list-view">
                    <header class="page-header">
                        <h1>Tracking S-Curve - Select a Project</h1>
                    </header>
                    <div id="tracking-s-curve-projects-list" class="list-container"></div>
                </div>
                <div id="tracking-s-curve-chart-view" class="hidden">
                    <header class="page-header">
                        <div>
                            <button id="back-to-tracking-s-curve-projects" class="btn btn-secondary">&larr; Back to Projects</button>
                            <h1 id="tracking-s-curve-project-name"></h1>
                        </div>
                    </header>
                    <div class="chart-container">
                        <canvas id="tracking-s-curve-chart"></canvas>
                    </div>
                </div>
            </div>
        </main>
        <footer class="app-footer">
            <p>© 2025 Daniel Pollentes. All Rights Reserved.</p>
        </footer>

        <div id="project-modal" class="modal">
            <div class="modal-content">
                <span class="close-button project-modal-close">&times;</span>
                <h2 id="modal-title">Add Project</h2>
                <form id="project-form">
    <input type="hidden" id="projectId">
    <div class="form-group"><label for="projectName">Project Name</label><input type="text" id="projectName" required></div>
    <div class="form-group"><label for="projectAddress">Address</label><input type="text" id="projectAddress" required></div>
    <div class="form-group"><label for="clientName">Client Name</label><input type="text" id="clientName" required></div>
    <div class="form-group"><label for="projectDescription">Project Description</label><textarea id="projectDescription" rows="4"></textarea></div>
    
    <div class="details-grid">
        <div class="form-group"><label for="lotArea">Lot Area (m²)</label><input type="number" step="any" id="lotArea"></div>
        <div class="form-group"><label for="floorArea">Total Floor Area (m²)</label><input type="number" step="any" id="floorArea"></div>
        <div class="form-group"><label for="numFloors">Number of Floors</label><input type="number" step="1" id="numFloors"></div>
        <div class="form-group"><label for="contractAmount">Contract Amount (PHP)</label><input type="number" step="any" id="contractAmount"></div>
        <div class="form-group"><label for="targetStartDate">Target Start Date</label><input type="date" id="targetStartDate"></div>
        <div class="form-group"><label for="contractDuration">Contract Duration (Days)</label><input type="number" step="1" id="contractDuration"></div>
        <div class="form-group"><label for="contractDate">Contract Date</label><input type="date" id="contractDate"></div>
        <div class="form-group"><label for="projectManager">Project Manager</label><input type="text" id="projectManager"></div>
        <div class="form-group"><label for="clientContact">Client Contact</label><input type="text" id="clientContact"></div>
    </div>

    <div class="form-group">
        <label for="projectStatus">Project Status</label>
        <select id="projectStatus">
            <option value="On-Going">On-Going</option>
            <option value="Bidding">Bidding</option>
            <option value="On-Hold">On-Hold</option>
            <option value="Completed">Completed</option>
            <option value="Cancelled">Cancelled</option>
        </select>
    </div>

    <button type="submit" class="btn btn-primary">Save Project</button>
</form>
            </div>
        </div>
        <div id="quantity-modal" class="modal">
            <div class="modal-content">
                <span class="close-button quantity-modal-close">&times;</span>
                <h2 id="quantity-modal-title">Add Quantity</h2>
                <form id="quantity-form">
    <input type="hidden" id="quantityId">
    <div class="form-group"><label for="category">Category</label><input type="text" id="category" list="category-list" placeholder="e.g., Concrete, Framing, Finishes" required><datalist id="category-list"></datalist></div>
    <div class="form-group"><label for="scopeOfWork">Scope of Work (Main Item)</label><input type="text" id="scopeOfWork" required></div>
    <div class="form-group"><label for="unit">Unit (e.g., m², ft, pcs)</label><input type="text" id="unit" required></div>
    <div class="form-group"><label for="quantity">Total Quantity</label><input type="number" step="any" id="quantity" required></div>
    
    <hr>
    
    <div class="sub-items-section">
        <div class="page-header" style="margin-bottom: 1rem;">
            <h4 style="margin: 0;">Sub-Quantities (Optional Breakdown)</h4>
            <button type="button" id="add-subquantity-btn" class="btn btn-secondary">Add Sub-Item</button>
        </div>
        <p style="font-size: 0.9rem; color: var(--grey-color); margin-top: -1rem; margin-bottom: 1rem;">If you add sub-items here, the "Total Quantity" above will be automatically calculated from their sum.</p>
        <div class="table-container">
            <table id="subquantities-table">
                <thead>
                    <tr>
                        <th>Sub-Item Name</th>
                        <th>Quantity</th>
                        <th></th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <hr>
    <button type="submit" class="btn btn-primary">Save Quantity</button>
</form>
            </div>
        </div>
        <div id="sequence-edit-modal" class="modal">
            <div class="modal-content">
                <span class="close-button sequence-modal-close">&times;</span>
                <h2 id="sequence-modal-title">Edit Sequence</h2>
                <form id="sequence-edit-form">
                    <input type="hidden" id="editingTaskId">
                    <div class="sequencing-section">
                        <p>Select one or more tasks that must happen <strong>before</strong> or <strong>after</strong> this task.</p>
                        <div class="sequence-links-grid">
                            <div>
                                <label for="modal-predecessors-multiselect">Precedents (come before)</label>
                                <select id="modal-predecessors-multiselect" multiple></select>
                            </div>
                            <div>
                                <label for="modal-successors-multiselect">Successors (come after)</label>
                                <select id="modal-successors-multiselect" multiple></select>
                            </div>
                        </div>
                        <button type="submit" class="btn btn-primary">Save Links</button>
                    </div>
                </form>
            </div>
        </div>
        <div id="copy-project-modal" class="modal">
            <div class="modal-content">
                <span class="close-button copy-project-modal-close">&times;</span>
                <h2>Copy Project</h2>
                <form id="copy-project-form">
                    <div class="form-group">
                        <label for="source-project-select">Source Project</label>
                        <select id="source-project-select" required></select>
                    </div>
                    <div class="form-group">
                        <label for="new-project-name-copy">New Project Name</label>
                        <input type="text" id="new-project-name-copy" required>
                    </div>
                    <button type="submit" class="btn btn-primary">Copy Project</button>
                </form>
            </div>
        </div>
        <div id="dupa-details-modal" class="modal">
            <div class="modal-content">
                <span class="close-button dupa-details-modal-close">&times;</span>
                <h2 id="dupa-details-title">DUPA Breakdown</h2>
                <div id="dupa-details-content"></div>
            </div>
        </div>
        <div id="co-modal" class="modal">
            <div class="modal-content" style="max-width: 800px;">
                <span class="close-button co-modal-close">&times;</span>
                <h2 id="co-modal-title">New Change Order</h2>
                <form id="co-form">
                    <input type="hidden" id="co-id">
                    <div class="form-group"><label for="co-description">Description</label><input type="text" id="co-description" required></div>
                    <div class="form-group"><label for="co-date">Date</label><input type="date" id="co-date" required></div>
                    <div class="form-group"><label for="co-status">Status</label><select id="co-status"><option value="Pending">Pending</option><option value="Approved">Approved</option><option value="Rejected">Rejected</option></select></div>
                    
                    <h4 style="margin-top:2rem; border-top:1px solid #ccc; padding-top:1rem;">Line Items</h4>
                    <div class="table-container">
                        <table id="co-items-table">
                            <thead><tr><th>Scope of Work</th><th>Qty</th><th>Unit</th><th>Amount</th><th>Actions</th></tr></thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    <button type="button" id="add-co-item-btn" class="btn btn-secondary" style="margin-top:1rem;">Add Item</button>
                    <hr>
                    <button type="submit" class="btn btn-primary">Save Change Order</button>
                </form>
            </div>
        </div>
        <div id="co-item-dupa-modal" class="modal">
            <div class="modal-content">
                <span class="close-button co-item-dupa-modal-close">&times;</span>
                <h2 id="co-item-dupa-title">Cost Breakdown for Item</h2>
                <form id="co-item-dupa-form">
                     <input type="hidden" id="co-item-id">
                     <input type="hidden" id="co-original-quantity-id">
                     <div class="form-group"><label for="co-item-scope">Scope of Work</label><input type="text" id="co-item-scope" required></div>
                     <div class="form-group"><label for="co-item-quantity">Quantity</label><input type="number" step="any" id="co-item-quantity" required></div>
                     <div class="form-group"><label for="co-item-unit">Unit</label><input type="text" id="co-item-unit" required></div>
                     <hr>
                     <div class="form-group"><label for="co-item-dupa-duration">Duration (Days)</label><input type="number" id="co-item-dupa-duration" step="1" min="0" required></div>
                     <div class="dupa-section">
                        <h4 style="margin-top: 0;">Direct Costs</h4>
                        <h5>Labor <button type="button" id="co-add-labor-btn" class="btn-add">+</button></h5>
                        <table class="dupa-table"><thead><tr><th>Labor Type</th><th>Mandays</th><th>Rate (PHP)</th><th></th></tr></thead><tbody id="co-labor-tbody"></tbody></table>
                        <h5>Materials <button type="button" id="co-add-material-btn" class="btn-add">+</button></h5>
                        <table class="dupa-table"><thead><tr><th>Material Name</th><th>Qty</th><th>Unit</th><th>Unit Price (PHP)</th><th></th></tr></thead><tbody id="co-material-tbody"></tbody></table>
                        <h5>Equipment <button type="button" id="co-add-equipment-btn" class="btn-add">+</button></h5>
                        <table class="dupa-table"><thead><tr><th>Equipment Name</th><th>Hours</th><th>Rate (PHP)</th><th></th></tr></thead><tbody id="co-equipment-tbody"></tbody></table>
                    </div>
                     <div class="form-group"><label for="co-item-dupa-ocm">OCM (%)</label><input type="number" step="any" id="co-item-dupa-ocm" value="10"></div>
                     <div class="form-group"><label for="co-item-dupa-profit">Profit (%)</label><input type="number" step="any" id="co-item-dupa-profit" value="15"></div>
                     <div class="form-group"><label for="co-item-dupa-taxes">Taxes (%)</label><input type="number" step="any" id="co-item-dupa-taxes" value="5"></div>
                     <button type="submit" class="btn btn-primary">Save Item Details</button>
                </form>
            </div>
        </div>
        <div id="co-item-type-modal" class="modal">
            <div class="modal-content">
                <span class="close-button co-item-type-modal-close">&times;</span>
                <h2>Select Item Type</h2>
                <p>Is this a new scope of work, or are you modifying an existing item from the original contract?</p>
                <div style="display: flex; justify-content: space-around; margin-top: 2rem;">
                    <button type="button" id="co-select-new-item-btn" class="btn btn-primary">New Scope Item</button>
                    <button type="button" id="co-select-existing-item-btn" class="btn btn-secondary">Modify Existing Item</button>
                </div>
            </div>
        </div>
        <div id="co-existing-item-modal" class="modal">
            <div class="modal-content">
                <span class="close-button co-existing-item-modal-close">&times;</span>
                <h2>Modify Existing Scope Item</h2>
                <form id="co-existing-item-form">
                    <div class="form-group">
                        <label for="co-original-item-select">Original Scope Item</label>
                        <select id="co-original-item-select" required></select>
                    </div>
                    <div class="form-group">
                        <label for="co-item-quantity-change">Quantity Change (use a negative number for deduction)</label>
                        <input type="number" step="any" id="co-item-quantity-change" required>
                    </div>
                    <button type="submit" class="btn btn-primary">Add Modification</button>
                </form>
            </div>
        </div>
        
    
        <script src="js/dexie.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script src="js/db.js"></script>
        
        <script src="js/views.js"></script>
        <script src="js/dashboard.js"></script>
        <script src="js/materials.js"></script>
        <script src="js/dupa_library.js"></script>
        <script src="js/library_management.js"></script>
        <script src="js/projects.js"></script>
        <script src="js/takeoff.js"></script>
        <script src="js/dupa.js"></script>
        <script src="js/sequencing.js"></script>
        <script src="js/construction.js"></script>
        <script src="js/reports.js"></script>
        
        <script src="js/change_orders.js"></script>
        
        <script src="js/app.js"></script>
        <div id="delete-boq-modal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="close-delete-boq-modal">&times;</span>
                <h2>Confirm Deletion</h2>
                <p><strong>Warning:</strong> Are you sure you want to permanently delete this locked BOQ?</p>
                <p>This will unlock all pre-construction data (Quantities, DUPAs) and permanently delete all construction progress (Accomplishment Reports) for this project. <strong>This action cannot be undone.</strong></p>
                <div style="display: flex; justify-content: flex-end; gap: 1rem; margin-top: 2rem;">
                    <button id="cancel-delete-boq-btn" class="btn btn-secondary">Cancel</button>
                    <button id="confirm-delete-boq-btn" class="btn btn-danger">Confirm & Delete</button>
                </div>
            </div>
        </div>
        <div id="generate-boq-modal" class="modal">
        <div class="modal-content">
                <span class="close-button" id="close-generate-boq-modal">&times;</span>
                <h2>Generate Bill of Quantities?</h2>
                <p>No locked BOQ was found for this project.</p>
                <p><strong>Warning:</strong> Generating a BOQ will lock all pre-construction data (Quantities and DUPAs) for this project. You will NOT be able to edit them after this point unless you delete the BOQ.</p>
                <p>Are you sure you want to proceed?</p>
                <div style="display: flex; justify-content: flex-end; gap: 1rem; margin-top: 2rem;">
                    <button id="cancel-generate-boq-btn" class="btn btn-secondary">Cancel</button>
                    <button id="confirm-generate-boq-btn" class="btn btn-primary">Generate & Lock BOQ</button>
                </div>
            </div>
        </div>
        <div id="start-date-modal" class="modal">
            <div class="modal-content">
                <h2>Project Start Date Required</h2>
                <p>This is the first accomplishment report for this project. Please set the project's official start date to continue.</p>
                <div class="form-group">
                    <label for="modal-start-date-input">Project Start Date</label>
                    <input type="date" id="modal-start-date-input" required>
                </div>
                <div style="display: flex; justify-content: flex-end; margin-top: 2rem;">
                    <button id="set-start-date-btn" class="btn btn-primary">Set Date & Continue</button>
                </div>
            </div>
            </div>

        <div id="import-preview-modal" class="modal">
            <div class="modal-content" style="max-width: 700px;">
                <span class="close-button import-preview-modal-close">&times;</span>
                <h2>Import Preview</h2>
                <p>The following items were found in the file. Duplicates are items with a name (or name + type) that already exists in your library.</p>
                <div id="import-preview-content" style="max-height: 40vh; overflow-y: auto; border: 1px solid #eee; padding: 15px; border-radius: 6px;">
                    </div>
                <div style="display: flex; justify-content: flex-end; gap: 1rem; margin-top: 2rem;">
                    <button id="import-cancel-btn" class="btn btn-secondary">Cancel</button>
                    <button id="import-proceed-duplicates-btn" class="btn btn-warning">Import All (Overwrite Duplicates)</button>
                    <button id="import-proceed-new-btn" class="btn btn-primary">Import New Items Only</button>
                </div>
            </div>
        </div>


        <div id="library-picker-modal" class="modal">
            <div class="modal-content">
                <span class="close-button" id="library-picker-modal-close">&times;</span>
                <h2 id="library-picker-title">Select from Library</h2>
                <div class="form-group">
                    <input type="search" id="library-picker-search" placeholder="Search...">
                </div>
                <div id="library-picker-crew-multiplier" class="form-group hidden">
                    <label for="library-picker-crew-count">Number of Crews to Add</label>
                    <input type="number" id="library-picker-crew-count" value="1" min="1" step="1">
                </div>
                <ul id="library-picker-list" class="list-container" style="max-height: 40vh; overflow-y: auto;">
                    </ul>
            </div>
        </div>
        
    <script src="js/dexie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    </body>
</html>
</file>

</files>
